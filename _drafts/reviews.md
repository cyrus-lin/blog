## 设计模式

* 观察者（Observer），`LiveData`
* 单例（Singleton），double check
* 适配器（Adapter），`RecyclerView.Adapter`
* 装饰器（Decorator），`ContextWrapper`
* 责任链（Chain of Responsibility），`OkHttp` 大体上就是个责任链模式
* 建造者（Builder）
* 工厂（Factory）

## 实现 LRU

`map` + 双端链表，链尾是最近使用过的，链头是最久未使用的
* `get(key)`，通过 `map` 可以在 O(1) 时间内找到 `value`，然后把 `value` 从双端链表中断开并移到链尾，双端链表的特性使得「断开」操作很容易实现
* `put(key, value)`，把 `value` 添加到链尾，当超过容量限制时，从链头逐个移除 `value` 直到满足容量限制

## 几个重要的排序算法

* 归并排序 O(nlogn)
`step` 从 1 逐步递增，合并两个长度为 `step` 的已排序区间，当 `step` > length/2 时，已排序区间就等于整个数组
合并两个有序区间很简单，用「双指针法」即可

* 快速排序 O(nlogn)
双指针，一个在头一个在尾，取第一个元素为「基准」（挖出一个坑），从尾部找一个比「基准」小的填入坑，然后又从头部找一个比「基准」大的填入尾部的坑，循环往复直到双指针碰头，那么这个位置就是「基准」的位置
每一轮都可以找出一个元素的排序后的位置，从整体看，这个元素和它左右两块是已排序的
然后递归操作左右两块区间直到区间长度为 1

* 堆排序 O(nlogn)
利用「堆」这个特殊的数据结构来排序（大顶堆、小顶堆）
恰好堆也是用数组实现的，初始已排序区间的长度为 1，逐步扩大长度相当于逐个添加一个新元素到堆
添加一个新元素到堆，相当于添加到数组尾部，逻辑上看就是添加到二叉树叶子那层最左边，为了让堆继续满足性质，需要把新元素逐层地跟它的父节点比较：新节点大于父节点则交换（大顶堆，小顶堆则相反）
当已排序区间 == 数组时，整个数组就排好序了

## 五层网络

|              |                    |
|--------------|--------------------|
| 应用层        | HTTP               |
| 传输层        | TCP、UDP           |
| 网络层        | IP 地址（替代 MAC 地址，形成网络），ARP（通过 IP 地址查询得到 MAC 地址）|
| 链接层        | 以太网协议（Ethernet），帧（Frame），MAC 地址，广播（同一网络的所有计算机都会受到消息，它们比较帧的 MAC 地址和自己的 MAC 地址是否相同来决定是否接收）|
| 物理层（实体层）| adf                |

## 抽象类和接口的区别

抽象类是对实体的抽象，而接口是对特征的抽象；所以 Java 类最多只能继承自一个抽象类，但却可是实现多个特征

## 多线程同步的方法

 * `synchronized`
 * `volatile`
 * `Lock` & `Condition` & `Atoimc`

## `HashMap` 和 `HashTable` 的区别

* 都是数组 + 链表的实现（链表是为了解决 hash 冲突）
* `HashTable` 是线程安全的（大多数方法都加了 `synchronized`），而 `HashMap` 不是
* `HashMap` 允许为 `null` 的 key 和 value，而 `HashTable` 则不允许
* `HashMap` 重算了 hash code：`(h = key.hashCode()) ^ (h >>> 16)`，而 `HashTable` 直接使用 `hashCode()`

## 怎么解决 ANR 问题

先把 `/data/anr/trace.txt` 拉下来，搜索包名定位到 app 进程那一段，找到 `main` 线程，看看主线程是不是出于异常状态（比如 `Blocked`、`Sleeping`）
如果主线程状态异常，那么查看主线程的调用堆栈，看看是哪段代码导致主线程进入异常状态
像 `Blocked` 有可能是锁导致的，能看到主线程被哪个锁阻塞，那个锁被哪个线程持有
有时候主线程没发现异常，看调用堆栈发现主线程正在执行 binder 相关操作，此时有可能是阻塞在这里（等待 binder 对面那端的响应）

还找不到问题，就在 logcat 里搜索 anr 找到 anr 相关日志，它会有一个 CPU 负载统计，如果 io 占比很大说明卡在 io 上了，继续往上找找看当时正在做什么文件操作，或者在 trace 文件里找找

