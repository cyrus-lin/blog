## 设计模式

* 观察者（Observer），`LiveData`
* 单例（Singleton），double check
* 适配器（Adapter），`RecyclerView.Adapter`
* 装饰器（Decorator），`ContextWrapper`
* 责任链（Chain of Responsibility），`OkHttp` 大体上就是个责任链模式
* 建造者（Builder）
* 工厂（Factory）

## 实现 LRU

`map` + 双端链表，链尾是最近使用过的，链头是最久未使用的
* `get(key)`，通过 `map` 可以在 O(1) 时间内找到 `value`，然后把 `value` 从双端链表中断开并移到链尾，双端链表的特性使得「断开」操作很容易实现
* `put(key, value)`，把 `value` 添加到链尾，当超过容量限制时，从链头逐个移除 `value` 直到满足容量限制

## 几个重要的排序算法

* 归并排序 O(nlogn)
`step` 从 1 逐步递增，合并两个长度为 `step` 的已排序区间，当 `step` > length/2 时，已排序区间就等于整个数组
合并两个有序区间很简单，用「双指针法」即可

* 快速排序 O(nlogn)
双指针，一个在头一个在尾，取第一个元素为「基准」（挖出一个坑），从尾部找一个比「基准」小的填入坑，然后又从头部找一个比「基准」大的填入尾部的坑，循环往复直到双指针碰头，那么这个位置就是「基准」的位置
每一轮都可以找出一个元素的排序后的位置，从整体看，这个元素和它左右两块是已排序的
然后递归操作左右两块区间直到区间长度为 1

* 堆排序 O(nlogn)
利用「堆」这个特殊的数据结构来排序（大顶堆、小顶堆）
恰好堆也是用数组实现的，初始已排序区间的长度为 1，逐步扩大长度相当于逐个添加一个新元素到堆
添加一个新元素到堆，相当于添加到数组尾部，逻辑上看就是添加到二叉树叶子那层最左边，为了让堆继续满足性质，需要把新元素逐层地跟它的父节点比较：新节点大于父节点则交换（大顶堆，小顶堆则相反）
当已排序区间 == 数组时，整个数组就排好序了

## 五层网络
|              |                    |
|--------------|--------------------|
| 应用层        | HTTP               |
| 传输层        | TCP、UDP           |
| 网络层        | IP 地址（替代 MAC 地址，形成网络），ARP（通过 IP 地址查询得到 MAC 地址）|
| 链接层        | 以太网协议（Ethernet），帧（Frame），MAC 地址，广播（同一网络的所有计算机都会受到消息，它们比较帧的 MAC 地址和自己的 MAC 地址是否相同来决定是否接收）|
| 物理层（实体层）| adf                |


