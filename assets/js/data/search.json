[ { "title": "浅析 LeakCanary", "url": "/posts/leakcanary/", "categories": "内存优化", "tags": "LeakCanary, 内存", "date": "2021-04-12 12:00:00 +0800", "snippet": "发现泄漏对象四种引用类型 强引用 平时写代码最常用的引用类型，对象只要被强引用就不会被 GC 软引用 SoftReference 只有当内存不足时才会被 GC 弱引用 WeakReference 会被正常 GC 虚引用 PhantomReference 会被正常 GC，因为 get() 总是返回 null，一般用来跟踪对象的生命周期 所有的引用类型都可以在构造时与一个 ReferenceQueue 关联，当引用的对象被 GC 后，这个 Re..." }, { "title": "HashMap 的一些知识点", "url": "/posts/hashmap/", "categories": "JDK, Collection", "tags": "HashMap, 红黑树", "date": "2021-04-05 12:00:00 +0800", "snippet": "HashMap 的桶由链表变为红黑树（树化）的过程红黑树的特性 节点为红色或者黑色 根节点必须是黑的 红色节点的左右子节点必须为黑色 一个节点到叶子节点的每条路径必须包含相同数目的黑色节点颜色变换和两种选择添加新节点后，因为新节点总是红色的，那么会有几种情况出现： 新节点是根节点，也就是说树是空的，根据规则二，把新节点设为黑色即可 新节点的父节点是黑色，或者父节点是根，满足规则 父节点是红色，违反规则三，需要进行 平衡 操作平衡操作主要是根据情况组合使用下面三种转换（方块表示一棵满足红黑树规则的子树）：几个问题为什么要进行旋转？由于 P（父节点 和 X（新节点）都为红色，违..." }, { "title": "JUC 下一些线程安全的容器", "url": "/posts/juc-collection/", "categories": "JDK, JUC", "tags": "JUC, 线程安全", "date": "2021-03-31 12:00:00 +0800", "snippet": "写时复制（Copy On Write）CopyOnWriteArrayList使用 写时复制 实现的线程安全版 ArrayList，当发生修改操作时（add、set、remove）才加锁，将原数组复制一份并在上面修改成为新数组，最后用新数组替换原数组public boolean add(E e) { synchronized (lock) { Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elem..." }, { "title": "什么是 https ？", "url": "/posts/https/", "categories": "网络", "tags": "https", "date": "2021-03-30 12:00:00 +0800", "snippet": "https = http + tlstcp 三次握手建立连接后，再进行 tls 握手/协商得到一个秘钥，然后双方使用这个秘钥加密（对称加密）明文的 http 为密文后再发送，同样双方收到密文后也用这个秘钥解密得到明文对称加密 使用同一秘钥加密和解密，性能高，http 明文就是通过对称加密后才进行传输的，对称加密算法有：DES、3DES、AES 等；但秘钥交换是个问题，所以需要非对称加密的帮助非对称加密 公钥加密则私钥解密，私钥加密则公钥解密，性能比对称加密要差，不适合加解密大量的数据，但很适合于解决秘钥交换的问题，常用的有：RSA、DSA 等tls 协商的过程Client Hello客户..." }, { "title": "TCP 的三次握手和四次挥手", "url": "/posts/tcp-handshake-goodbye/", "categories": "网络", "tags": "tcp", "date": "2021-03-13 12:00:00 +0800", "snippet": "序号和确认号 从 TCP 连接建立的开始，到 TCP 连接的断开，你要传输的所有数据的每一个字节都要编号，这个序号称为 字节序号 如果一个 TCP 报文的 报文序号 为 301，它携带了 100 字节的数据，就表示这 100 个字节的数据的字节序号范围是 [301, 400]，该报文携带的第一个字节序号是 301，最后一个字节序号是 400 每传送一个 TCP 报文都要等待对方回复一个确认，但这种方式效率太低，在 TCP 协议中，一般采用累积确认的方式，即每次传送多个连续 TCP 报文，可以只对最后一个 TCP 报文进行确认。对方通过回复一个 确认号 来表示已经接收到了哪个 TCP..." }, { "title": "解析 Tinker 是如何实现热修复的", "url": "/posts/how-tinker-work/", "categories": "Android, Library", "tags": "hotfix", "date": "2021-03-12 12:00:00 +0800", "snippet": "简介Tinker 是微信团队开源的一款 android 热修复框架，它的使用流程大体是： client 安装 V1.apk 提交了一些 hotfix，打包出 V2.apk 利用 Tinker 提供的差分工具，在 server 计算出补丁包 patch1.apk，并下发给 client client 收到补丁包后，在后台给 V1.apk 打上 patch1.apk 得到 V2.apk（V1.apk + patch1.apk = V2.apk） app 在下次启动时，将加载 V2.apk它的工作目录大概是这样的：- /data/user/0/tinker.sample.androi..." }, { "title": "Application 是如何被创建和初始化的？", "url": "/posts/how-application-being-created-and-init/", "categories": "Android, Framework", "tags": "Application, AMS, Zygote", "date": "2021-03-02 12:00:00 +0800", "snippet": "时序图从 startActivity 开始，比如打开一个 app 的首页，当 app 未启动时就会走创建 Application 这条路AMS 承担的工作其中的转折点在 resumeTopActivityInnerLocked，发现 app process 不存在，走启动 app process 的流程private boolean ActivityStack.resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) { // ... Launching this app&#39;s act..." }, { "title": "线程池 ThreadPool 的实现", "url": "/posts/threadpool/", "categories": "Android, Art", "tags": "threadpool", "date": "2021-02-19 12:00:00 +0800", "snippet": "基础知识线程池有几个重要的参数： maximumPoolSize 最大线程数量，如果新提交的任务因为 workQueue 的容量限制而无法入队，则会尝试新开一个线程执行任务，而如果此时总线程数超过 maximumPoolSize 的限制，那么不再新开一个线程而是提交失败 corePoolSize 核心线程数量，当任务执行完毕，线程也将结束它的生命周期，但最少不会低于 corePoolSize keepAliveTime 空闲线程的存活时间，执行完任务的线程会存活至少 keepAliveTime，再根据当前线程数量和 corePoolSize 决定要不要结束生命 workQueue..." }, { "title": "Lock（五）Condition 的语言实现：Object.wait 和 Object.notify", "url": "/posts/wait-notify/", "categories": "Android, Art", "tags": "wait, notify", "date": "2021-02-11 12:00:00 +0800", "snippet": "在 Lock（三）利用 Lock 实现 Condition 我们介绍了如何用 Lock 来实现 Condition，而 Condition 对标的是 Object.wait 和 Object.notify我们来看看 ART 是怎么实现 wait/notify 的（最好先了解下 synchronized 的基础知识）ConditionVariable对 futex/mutex 的封装，宏 ART_USE_FUTEXES 决定底层是使用 futex 还是 mutex；它不是「条件变量」，Monitor 才是（而且它还包含 Lock 的角色）// art/runtime/base/mutex...." }, { "title": "Lock（四）synchronized 的语言实现", "url": "/posts/synchronized-implementation/", "categories": "Android, Art", "tags": "synchronized", "date": "2021-02-08 12:00:00 +0800", "snippet": "monitor 指令在 Lock（二）AQS 源码分析以及 Lock 的实现 这篇文章里介绍了基于 AQS 的 Lock，它是双向链表的排队队列和系统调用 futex 实现的其实 java 语言规范里自带了 Lock 的实现：synchronized 关键字，下面看看 ART 是怎么实现它的先写一个使用了 synchronized 的测试方法package com.example.myapplication;public class Hello { private final Object lock = new Object(); public void say(String..." }, { "title": "Lock（三）利用 Lock 实现 Condition", "url": "/posts/condition-by-lock/", "categories": "Android, Art", "tags": "Lock, Condition", "date": "2021-01-24 12:00:00 +0800", "snippet": "Condition 简介Condition 主要有两类方法： await，释放锁并阻塞线程直到 signal 被调用，恢复后会重新获得锁 signal，唤醒阻塞在这个 Condition 上的一个或全部线程利用条件变量前需要先获得锁所以 Condition 的所有方法都需要加锁lock.lock();// ...condition.await();// ...lock.unlock();Condition 的 await/signal 对标 Object 的 wait/notify，wait/notify 使用对象监视器实现的，而 await/signal 使用 Lock 实现的（L..." }, { "title": "常见面试题备忘", "url": "/posts/reviews/", "categories": "面试", "tags": "面试", "date": "2021-01-19 12:00:00 +0800", "snippet": "设计模式 观察者（Observer），LiveData 单例（Singleton），double check 适配器（Adapter），RecyclerView.Adapter 装饰器（Decorator），ContextWrapper 代理模式（Proxy），例如 VPN、Retrofit 责任链（Chain of Responsibility），OkHttp 大体上就是个责任链模式 建造者（Builder） 工厂（Factory）代理模式强调不能直接访问一个对象，只能通过代理间接访问，不能直接访问的原因比如：权限校验、操作日志、RPC装饰器模式强调增强对象的功能：把一..." }, { "title": "Lock（二）AQS 源码分析以及 Lock 的实现", "url": "/posts/aqs-lock-implementation/", "categories": "Android, Art", "tags": "Lock, AQS", "date": "2021-01-13 12:00:00 +0800", "snippet": "AQS 是 Semaphore、ReentrantLock 和 ReentrantReadWriteLock 的基础，它们紧密地结合在一块，分析 AQS 除了要明晰排队队列的操作，还要结合 Semaphore、ReentrantLock 和 ReentrantReadWriteLock 看看是怎么利用排队队列实现锁和信号量的AQS 是基于 CLH 锁修改而来的，它的排队队列也是双向链表public abstract class AbstractQueuedSynchronizer { private transient volatile Node head; // 队头节点 ..." }, { "title": "Lock（一）AQS 基础", "url": "/posts/aqs-basic/", "categories": "Android, Art", "tags": "Lock, AQS", "date": "2021-01-10 12:00:00 +0800", "snippet": "自旋锁（Spin Lock）获得锁的时候，不阻塞线程，而是跟平常一样继续获得 CPU 时间，继续执行代码/逻辑，那就是自旋锁；比如下面的 lock()// 一个简单的自旋锁的实现class SpinLock { private val cas = AtomicReference&amp;lt;Thread&amp;gt;() fun lock() { while (!cas.compareAndSet(null, Thread.currentThread())) {} } fun unlock() { cas.compareAndSet..." }, { "title": "Android 图形栈（三）render thread", "url": "/posts/render-thread/", "categories": "Android, Framework", "tags": "vsync, render thread", "date": "2020-12-27 12:00:00 +0800", "snippet": "接着上一篇文章，在上篇文章里我们知道了 ui thread 在 view drawing 阶段产生了 DisplayList，而 render thread 会根据 DisplayList 执行真正的渲染工作，主要是 DrawFrameTask.syncFrameState 和 CanvasContext.draw 这两个方法syncFrameState重要的方法有三个：makeCurrent，unpinImages 和 prepareTreeTreeInfo 用来在后续的一系列操作中收集信息，你会看到它在各个方法中作为参数传递bool DrawFrameTask::syncFrameS..." }, { "title": "Android 图形栈（二）ui thread", "url": "/posts/ui-thread-in-vsync/", "categories": "Android, Framework", "tags": "vsync, ui thread", "date": "2020-12-13 12:00:00 +0800", "snippet": "从一段 systrace 开始这是一段 systrace 记录，看得出来页面是比较流畅的，ui thread 全都在一个 VSYNC_app 内完成绘制，surfaceflinger 也在一个 VSYNC_sf 内完成各个层的合成；但有没发现在 ui thread 完成 doFrame 后，总是会有一个 ReaderThread 跟在后面，看名字像是跟渲染相关的线程，它跟 ui 绘制有关系吗？平时我们常说的，只要 ui thread 在一个刷新周期 16ms 内完成 view 的绘制，即可保证页面流畅，真的是这样吗？ViewRootImpl// 从 ViewRootImpl 开始View..." }, { "title": "Android 图形栈（一）vsync", "url": "/posts/vsync/", "categories": "Android, Framework", "tags": "vsync, invalidate", "date": "2020-12-02 12:00:00 +0800", "snippet": "android 的垂直同步模型（vsync）是隐藏在 view 系统后面的很重要的一块，它控制着 view 渲染的节奏；而且 vsync 还是比较复杂的，我们从下到上，先从最熟悉的 View.invalidate 讲起，看看简单的一个 invalidate 后面隐藏着多么复杂的工作从 View.invalidate() 说起看上图，View.invalidate() 主要做了两件事： 将 ViewRootImpl.doTraversal() 加入到 Choreographer 的任务列表里，等待下一次 vsync 信号到来时执行；doTraversal()主要执行 view tree ..." }, { "title": "Scoped Storage（沙盒）", "url": "/posts/scoped-storage/", "categories": "Android, Feature", "tags": "Scoped Storage", "date": "2020-11-19 12:00:00 +0800", "snippet": "以前的存储访问权限先看看以前（ &amp;lt; 10/Q ）的存储访问权限是怎样的从 APP 目录（app-specific directories）的角度看，可以分为： 内部存储（app-specific directories in internal storage） 对于 app 自己，无需申请任何读/写权限 对于其他 app，没有访问权限 外部存储（app-specific directories in external storage） 对于 app 自己，无需申请任何读/写权限 对于其他 app，可以访..." }, { "title": "starting window 和 windowDisablePreview", "url": "/posts/starting-window/", "categories": "Android, Framework", "tags": "windowDisablePreview, starting window", "date": "2020-11-11 12:00:00 +0800", "snippet": "问题中午和同事聊天时，提到一个问题：设计把爱范儿 app 的启动页改成暗黑样式，本来很简单的一个改动，测试却发现启动会有闪屏；下午我看了下效果，发现确实有问题： 把启动页的图片换成暗黑主体的图片后，冷/热启动都会有从白色到黑色的闪动 同事给的 bug fixed 是 windowDisablePreview = true，这导致 app 热启动时，会有很长的一段延迟starting window 是如何出现的网上搜索下，发现是 starting widow 引起的，我决定看看这个 starting window 是怎么打开和关闭的，以及如何设置它的背景色来匹配启动页的黑色背景跟寻上一..." }, { "title": "Activity 启动流程时序图", "url": "/posts/launch-activity-sequence/", "categories": "Android, Framework", "tags": "Activity", "date": "2020-11-03 12:00:00 +0800", "snippet": "记录下启动 Activity 的时序图，方便后面查找" }, { "title": "图解 Glide", "url": "/posts/how-glide-work/", "categories": "Android, Library", "tags": "Glide", "date": "2020-10-31 12:00:00 +0800", "snippet": "网上讲解 Glide 的文章一搜一大把，但几乎都是以文字的形式来讲解；我自己也写过不少 Glide 的笔记，也是文字为主；但是时间长了经常忘了其中的细节，加上 Glide 的源码不太易懂，所以决定用时序图来分析和记录研究 Glide 的过程时序图下面两张图是一次图片加载的大体流程，有读过源码的同学基本上通过这两种图就能回忆起其中的细节；没读过源码的同学也可以先了解下 Glide 里各个类的作用RequestManager - 请求管理器往 Activity/Fragment 添加一个 RequestManagerFragment（没有 View） 用以监听宿主的生命周期，从而实现请求的管..." }, { "title": "阅读源码系列：ANR 是怎么产生的", "url": "/posts/anr/", "categories": "Android, Framework", "tags": "ANR", "date": "2020-10-20 12:00:00 +0800", "snippet": "根据日常的经验我们大概知道，如果 app 没有及时消费 MotionEvent，超过 5s 就会弹出 ANR 对话框；那么 ANR 的逻辑肯定是在事件分发过程中产生的，我们从事件的源头找起，看看 input 事件是怎么产生的input 的分发事件分发是从线程 InputReaderThread 开始的，它的主要工作是： 从目录 /dev/input 获取 input event 看来 android 的输入设备是挂载在 /dev/input 下的，当然会有多个输入设备：屏幕触摸、键盘、手柄等，使用 epoll 监听多个 fd EventHub.getEven..." }, { "title": "一文搞懂事件分发，手势冲突和滑动冲突", "url": "/posts/dispatchtouchevent/", "categories": "Android, Framework", "tags": "TouchEvent, Motion, NestedScrolling", "date": "2020-10-04 12:00:00 +0800", "snippet": "手势冲突是 android 开发中经常遇到的一类问题了，网上讲解此问题的文章也很多，但是大都浅显地过一遍事件分发的调用栈，然后给出一个调用栈流程图；要不就是使用日志大法，用日志来验证自己的想法，完全没有参考价值；这里根据事件分发相关源码，记录下我的理解。MotionEvent 里定义的 ACTION_XXX 还不少有 10 多个，看起来情况很复杂的样子，实际上只需要关注三个：ACTION_DOWN，ACTION_MOVE 和 ACTION_UP，而且在一个手势里它们的顺序是：ACTION_DOWN → ACTION_MOVE → ACTION_MOVE → … → ACTION_UP。跟..." }, { "title": "面试官家常之Handler、MessageQueue 和 Looper", "url": "/posts/handler-messagequeue-looper/", "categories": "Android, Framework", "tags": "Handler, Looper", "date": "2020-09-27 12:00:00 +0800", "snippet": "MessageQueue 是个单向链表，按 Message.when 自然序排它有类似于「生产者 - 消费者」模型的阻塞队列：没有 Message 时，阻塞直到新 Message 入队；否则阻塞到下一个 Message.when// 这里会阻塞nativePollOnce(ptr, nextPollTimeoutMillis);synchronized (this) { // ... ... if (msg != null) { if (now &amp;lt; msg.when) { // Next message is not read..." }, { "title": "git log命令全解析，打log还能这么随心所欲！", "url": "/posts/git-log/", "categories": "Git", "tags": "git", "date": "2020-09-15 12:00:00 +0800", "snippet": "git log 命令非常强大而好用，在复杂系统的版本管理中扮演着重要的角色，但默认的 git log 命令显示出的东西实在太丑，不好好打扮一下根本没法见人，打扮好了用 alias 命令拍个照片，就正式出道了！下面先详细而系统地介绍 git log 的所有配置知识（用我一向简洁清晰的表述方式），熟悉了这些东西，你就可以自由配置自己美丽的 git log 了～最后上个干货，直接给一个我打扮好的 alias 配置，懒人直接跳到最后吧 ！git log 用于查询版本的历史，命令形式如下：git log [&amp;lt;options&amp;gt;] [&amp;lt;since&amp;gt..." }, { "title": "git 的 merge, rebase 和 squash", "url": "/posts/merge-rebase-squash/", "categories": "Git", "tags": "git", "date": "2020-09-05 12:00:00 +0800", "snippet": "在团队合作中，毫无疑问，我们需要一个版本管理工具，相对于 SVN 这种在我们看来是老古董的工具，Git 在年轻化的团队中更受欢迎。并不仅仅是跟着大神们（Linux系）的路子在走，所以感觉很牛逼，而是 Git 真的很牛逼，当然，牛逼的同时你需要的学习曲线也是很陡的。这几天我就遇到了一个问题，其实也不是遇到问题，而是遇到了疑惑，那就是我在 github 系统中 merge 同时的 PR 的时候发现有好几个选项，但是，却说不清楚这几个选项分别代表什么含义，所以就稍微花了点时间了解了下，顺带做个总结。在 merge pr 的时候，默认是有三种选项的，分别是 普通的 merge rebase ..." } ]
