<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Kotlin 里的尾递归优化 - tailrec</title>
    <link href="/blog/2021/04/15/kotlin-tailrec/"/>
    <url>/blog/2021/04/15/kotlin-tailrec/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h2><blockquote><p>这里有一篇文章讲得很好，转载自 <a href="https://blog.csdn.net/qq_34639378/article/details/78397312">浅谈Java中的递归与尾递归</a></p></blockquote><h3 id="首先我们讲讲递归"><a href="#首先我们讲讲递归" class="headerlink" title="首先我们讲讲递归"></a>首先我们讲讲递归</h3><p>递归的本质是，某个方法中调用了自身。本质还是调用一个方法，只是这个方法正好是自身而已，递归因为是在自身中调用自身，所以会带来以下三个显著特点：</p><ol><li>调用的是同一个方法</li><li>因为 1，所以只需要写一个方法，就可以让你轻松调用无数次（不用一个个写，你定个 n 就能有 n 个方法），所以调用的方法数可能非常巨大</li><li>在自身中调用自身，是嵌套调用（栈帧无法回收，开销巨大）</li></ol><p>因为上面 2 和 3 两个特点，所以递归调用最大的诟病就是开销巨大，栈帧和堆一起爆掉，俗称内存溢出（一个误区，不是因为调用自身而开销巨大，而是嵌套加上轻易就能无数次调用，使得递归可以很容易开销巨大），既然会导致内存泄露那肯定要想办法了，方法很简单，那就是尾递归优化</p><h3 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h3><p>尾递归优化是利用上面的第一个特点 “调用同一个方法” 来进行优化的，包括两个东西：</p><h4 id="尾递归的形式"><a href="#尾递归的形式" class="headerlink" title="尾递归的形式"></a>尾递归的形式</h4><p>尾递归其实只是一种对递归的特殊写法，这种写法原本并不会带来跟递归不一样的影响，它只是写法不一样而已，写成这样不会有任何优化效果，该爆的栈和帧都还会爆；具体不一样在哪里，前面说了，递归的本质是某个方法调用了自身，尾递归这种形式就要求：某个方法调用自身这件事，一定是该方法做的 <strong>最后一件事</strong>（所以当有需要返回值的时候会是 <code>return f(n)</code>，没有返回的话就直接是 <code>f(n)</code>）</p><p>要求很简单，就一条，但是有一些常见的误区：</p><ol><li>这个 <code>f(n)</code> 外不能加其他东西，因为这就不是最后一件事了，值返回来后还要再干点其他的活，变量空间还需要保留</li><li>如果有返回值的，你不能：乘个常数 <code>return 3f(n)</code>，乘个 n <code>return n*f(n)</code>，甚至是 <code>f(n)+f(n-1)</code></li></ol><h4 id="编译器对尾递归的优化"><a href="#编译器对尾递归的优化" class="headerlink" title="编译器对尾递归的优化"></a>编译器对尾递归的优化</h4><p>上面说了，你光手动写成尾递归的形式，并没有什么卵用，要实现优化，还需要编译器中加入了对尾递归优化的机制，有了这个机制，编译的时候就会自动利用上面的特点一来进行优化，简单说就是重复利用同一个栈帧，不仅不用释放上一个，连下一个新的都不用开，效率非常高（有人做实验，这个比递推比迭代都要效率高）</p><p>为什么写成尾递归的形式，编译器就能优化了？</p><ol><li>因为在递归调用自身的时候，这一层函数已经没有要做的事情了，虽然被递归调用的函数是在当前的函数里，但是他们之间的关系已经在传参的时候了断了，也就是这一层函数的所有变量什么的都不会再被用到了，所以当前函数虽然没有执行完，不能弹出栈，但它确实已经可以出栈了</li><li>正因为调用的是自身，所以需要的存储空间是一毛一样的，那干脆重新刷新这些空间给下一层利用就好了，不用销毁再另开空间</li></ol><p>所以总结为了解决递归的开销大问题，使用尾递归优化，具体分两步：</p><ol><li>你把递归调用的形式写成尾递归的形式</li><li>编译器碰到尾递归，自动按照某种特定的方式进行优化编译</li></ol><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 没有使用尾递归的形式</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recsum</span>(<span class="hljs-params">x</span>):</span><br>  <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">return</span> x<br>  <span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> x + recsum(x - <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 使用尾递归的形式）</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tailrecsum</span>(<span class="hljs-params">x, running_total=<span class="hljs-number">0</span></span>):</span><br>  <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">return</span> running_total<br>  <span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> tailrecsum(x - <span class="hljs-number">1</span>, running_total + x)<br></code></pre></div></td></tr></table></figure><p>但不是所有语言的编译器都做了尾递归优化。比如 C 实现了，JAVA 没有去实现，说到这里你很容易联想到 JAVA 中的自动垃圾回收机制，同是处理内存问题的机制，尾递归优化跟垃圾回收是不是有什么关系，这是不是就是 JAVA 不实现尾递归优化的原因？ </p><h3 id="所以下面要讲一下垃圾回收（GC）"><a href="#所以下面要讲一下垃圾回收（GC）" class="headerlink" title="所以下面要讲一下垃圾回收（GC）"></a>所以下面要讲一下垃圾回收（GC）</h3><p>首先我们需要谈一下内存机制，这里我们需要了解内存机制的两个部分：栈和堆。下面虽然是在说 JAVA，但是 C 也是差不多的</p><p>在 Java 中， JVM 中的栈记录了线程的方法调用，每个线程拥有一个栈，在某个线程的运行过程中如果有新的方法调用，那么该线程对应的栈就会增加一个存储单元，即栈帧 (<code>frame</code>)。在 <code>frame</code> 中保存有该方法调用的参数、局部变量和返回地址；Java 的参数和局部变量只能是基本类型的变量(比如 <code>int</code>)，或者对象的引用(<code>reference</code>)，因此在栈中只保存有基本类型的变量和对象引用。而引用所指向的对象保存在堆中</p><p>然后由栈和堆的空间管理方式的不同，引出 <strong>垃圾回收</strong> 的概念，当被调用方法运行结束时，该方法对应的帧将被删除，参数和局部变量所占据的空间也随之释放，线程回到原方法继续执行，当所有的栈都清空时程序也随之运行结束</p><p>如上所述，栈(<code>stack</code>)可以自己照顾自己，但堆必须要小心对待。堆是 JVM 中一块可自由分配给对象的区域，当我们谈论垃圾回收 (garbage collection) 时，我们主要回收堆(<code>heap</code>)的空间</p><p>Java 的普通对象存活在堆中，与栈不同堆的空间不会随着方法调用结束而清空（即使它在栈上的引用已经被清空了），因此在某个方法中创建的对象，可以在方法调用结束之后继续存在于堆中，这带来的一个问题是，如果我们不断的创建新的对象，内存空间将最终消耗殆尽</p><p>如果没有垃圾回收机制的话，你就需要手动地显式分配及释放内存，如果你忘了去释放内存，那么这块内存就无法重用了（不管是什么局部变量还是其他的什么）；这块内存被占有了却没被使用，这种场景被称之为 <strong>内存泄露</strong>，所以不管是 C 还是 JAVA，最原始的情况都是需要手动释放堆中的对象，C 到现在也是这样，所以你经常需要考虑对象的生存周期，但是 JAVA 则引入了一个自动垃圾回收的机制，它能智能地释放那些被判定已经没有用的对象 </p><h3 id="现在我们就可以比较一下尾递归优化和垃圾回收了"><a href="#现在我们就可以比较一下尾递归优化和垃圾回收了" class="headerlink" title="现在我们就可以比较一下尾递归优化和垃圾回收了"></a>现在我们就可以比较一下尾递归优化和垃圾回收了</h3><p>他们最本质的区别是：尾递归优化解决的是内存溢出的问题，而垃圾回收解决的是内存泄露的问题</p><ul><li>内存泄露指程序中动态分配内存给一些临时对象，但是对象不会被 GC 所回收，它始终占用内存，即被分配的对象可达但已无用</li><li>内存溢出指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于 Old 段或 Perm 段垃圾回收后，仍然无内存空间容纳新的 Java 对象的情况</li></ul><p>从定义上可以看出内存泄露是内存溢出的一种诱因，不是唯一因素。</p><p>自动垃圾回收机制的特点是：</p><ol><li>解决了所有情况下的内存泄露的问题，但还可以由于其他原因内存溢出</li><li>针对内存中的堆空间，正在运行的方法中的堆中的对象是不会被管理的，因为还有引用（栈帧没有被清空）</li><li>一般简单的自动垃圾回收机制是采用 <strong>引用计数</strong> 机制，每个对象包含一个计数器，当有新的指向该对象的引用时计数器加 1，当引用移除时计数器减 1，当计数器为 0 时认为该对象可以进行垃圾回收</li></ol><p>与之相对，尾递归优化的特点是：</p><ol><li>优化了递归调用时的内存溢出问题</li><li>针对内存中的堆空间和栈空间，正在运行的方法的堆和栈空间正是优化的目标</li><li>只在递归调用的时候使用，而且只能对于写成尾递归形式的递归进行优化</li></ol><h2 id="验证-Kotlin-的尾递归优化"><a href="#验证-Kotlin-的尾递归优化" class="headerlink" title="验证 Kotlin 的尾递归优化"></a>验证 Kotlin 的尾递归优化</h2><p>实现阶乘，<code>factorial</code> 是普通的递归版本，<code>factorialTail</code> 是尾递归版本（Kotlin 里除了要把递归函数写成尾递归的形式，还要添加 <code>tailrec</code> 关键字）</p><p>当计算 <code>5!</code> 时，通过控制台可以看到普通的递归会有 5 个栈帧（相当于从左至右计算：1 * 2 * 3 * 4 * 5）；而尾递归则只有一个栈帧，说明 Kotlin 确实通过尾递归优化减少了递归调用时的栈帧消耗（相当于从右至左计算：5 * 4 * 3 * 2 * 1）</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span>&#123;<br>        <span class="hljs-meta">@JvmStatic</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>            println(factorial(n = <span class="hljs-number">5</span>))<br>            println(factorialTail(step = <span class="hljs-number">5</span>))<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 阶乘的普通递归版本</span><br><span class="hljs-comment"> * 5! = 1 * 2 * 3 * 4 * 5</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">factorial</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (n) &#123;<br>        <span class="hljs-number">0</span>, <span class="hljs-number">1</span> -&gt; &#123;<br>            printStack()<br>            <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> -&gt; factorial(n - <span class="hljs-number">1</span>) * n<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 阶乘的尾递归版本</span><br><span class="hljs-comment"> * 添加关键字 tailrec 看看 Kotlin 会不会对其进行优化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">tailrec</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">factorialTail</span><span class="hljs-params">(step: <span class="hljs-type">Int</span>, value: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">if</span> (step &lt;= <span class="hljs-number">1</span>) &#123;<br>        printStack()<br>        <span class="hljs-keyword">return</span> value<br>    &#125;<br>    <span class="hljs-keyword">return</span> factorialTail(step - <span class="hljs-number">1</span>, step * value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printStack</span><span class="hljs-params">()</span></span> &#123;<br>    Exception().printStackTrace()<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="../../../../image/2021-04-15-kotlin-tailrec/factorial_output.png" alt="factorial_output.png"></p><h2 id="Kotlin-是如何实现尾递归优化的"><a href="#Kotlin-是如何实现尾递归优化的" class="headerlink" title="Kotlin 是如何实现尾递归优化的"></a>Kotlin 是如何实现尾递归优化的</h2><p>打开 class 文件可以看到，其实是把递归写法转换为 <code>while</code> 循环，从而实现「只使用一个栈帧」的目标 </p><p><img src="../../../../image/2021-04-15-kotlin-tailrec/code.png" alt="code.png"></p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kotlin</tag>
      
      <tag>tailrec</tag>
      
      <tag>尾递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析 LeakCanary</title>
    <link href="/blog/2021/04/12/leakcanary/"/>
    <url>/blog/2021/04/12/leakcanary/</url>
    
    <content type="html"><![CDATA[<h2 id="检测泄漏对象"><a href="#检测泄漏对象" class="headerlink" title="检测泄漏对象"></a>检测泄漏对象</h2><h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><table><thead><tr><th>引用类型</th><th>什么时候会被 GC</th></tr></thead><tbody><tr><td>强引用</td><td>平时写代码最常用的引用类型，对象只要被强引用就不会被 GC</td></tr><tr><td>软引用 <code>SoftReference</code></td><td>只有当内存不足时才会被 GC</td></tr><tr><td>弱引用 <code>WeakReference</code></td><td>会被正常 GC</td></tr><tr><td>虚引用 <code>PhantomReference</code></td><td>会被正常 GC，因为 <code>get()</code> 总是返回 null，一般用来跟踪对象的生命周期</td></tr></tbody></table><p>所有的引用类型都可以在构造时与一个 <code>ReferenceQueue</code> 关联，当引用的对象被 GC 后，这个 <code>Reference</code> 将被入队到关联的引用队列里</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/* -- Constructors -- */</span><br><br>    Reference(T referent) &#123;<br>        <span class="hljs-keyword">this</span>(referent, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    Reference(T referent, ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; queue) &#123;<br>        <span class="hljs-keyword">this</span>.referent = referent;<br>        <span class="hljs-keyword">this</span>.queue = queue;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="检测-Activity-泄漏"><a href="#检测-Activity-泄漏" class="headerlink" title="检测 Activity 泄漏"></a>检测 <code>Activity</code> 泄漏</h3><p>通过 <code>ActivityLifecycleCallbacks.onActivityDestroyed</code> 可以收集到 destoryed <code>Activity</code>，这些 <code>Activity</code> 已走完它的生命周期，应该被后续的 GC 回收掉</p><p>用 <code>WeakReference</code> + <code>ReferenceQueue</code> 监控它，并用 <code>watchedObjects = mutableMapOf&lt;String, KeyedWeakReference&gt;()</code> 把它记录起来，key 是 UUID，value 是对这个 <code>Activity</code> 的弱引用；等待 5s，让 GC 线程有足够的机会去发现并回收这个 <code>Activity</code> 对象，如果 5s 后 <code>Activity</code> 仍然没有被 GC（没有出现在引用队列里），那么可以证明这个对象发生了内存泄漏，被强引用导致存活超过它的生命周期</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 收集 destroyed Activity</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityWatcher</span></span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> application: Application,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : InstallableWatcher &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lifecycleCallbacks =<br>    <span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityDestroyed</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>        reachabilityWatcher.expectWeaklyReachable(<br>          activity, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span><br>        )<br>      &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 弱引用这个 Activity 并设置在 5s 后检查此对象有没被 GC</span><br><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">expectWeaklyReachable</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">  watchedObject: <span class="hljs-type">Any</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">  description: <span class="hljs-type">String</span></span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (!isEnabled()) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  removeWeaklyReachableObjects()<br>  <span class="hljs-keyword">val</span> key = UUID.randomUUID()<br>    .toString()<br>  <span class="hljs-keyword">val</span> watchUptimeMillis = clock.uptimeMillis()<br>  <span class="hljs-keyword">val</span> reference =<br>    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)<br>  SharkLog.d &#123;<br>    <span class="hljs-string">&quot;Watching &quot;</span> +<br>      (<span class="hljs-keyword">if</span> (watchedObject <span class="hljs-keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;instance of <span class="hljs-subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +<br>      (<span class="hljs-keyword">if</span> (description.isNotEmpty()) <span class="hljs-string">&quot; (<span class="hljs-variable">$description</span>)&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span>) +<br>      <span class="hljs-string">&quot; with key <span class="hljs-variable">$key</span>&quot;</span><br>  &#125;<br>  watchedObjects[key] = reference<br>  checkRetainedExecutor.execute &#123;<br>    moveToRetained(key)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果没有出现在引用队列里，说明此对象已发生泄漏，发出通知</span><br><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveToRetained</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> &#123;<br>  removeWeaklyReachableObjects()    <span class="hljs-comment">// 出现在引用队列里说明对象已被 GC，可以从 watchedObjects 移除</span><br>  <span class="hljs-keyword">val</span> retainedRef = watchedObjects[key]<br>  <span class="hljs-keyword">if</span> (retainedRef != <span class="hljs-literal">null</span>) &#123;<br>    retainedRef.retainedUptimeMillis = clock.uptimeMillis()<br>    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>拓展一下，上面检测 <code>Activity</code> 泄漏的机制：监控 - 等待 - 检查，其实可以应用到任何对象，包括 <code>Fragment</code>、<code>View</code> 等，于是抽象出一个通用的对象泄漏检测工具：<code>ObjectWatcher</code>，上面的 <code>expectWeaklyReachable</code> 和 <code>moveToRetained</code> 都是在 <code>ObjectWatcher</code> 里实现的</p><h3 id="检测-Fragment-和-View-的泄漏"><a href="#检测-Fragment-和-View-的泄漏" class="headerlink" title="检测 Fragment 和 View 的泄漏"></a>检测 <code>Fragment</code> 和 <code>View</code> 的泄漏</h3><p>利用 <code>FragmentLifecycleCallbacks</code> 发现被 destroyed <code>Fragment</code> 和 <code>View</code>，然后用 <code>ObjectWatcher</code> 监控是否发生泄漏</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AndroidXFragmentDestroyWatcher</span></span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : (Activity) -&gt; <span class="hljs-built_in">Unit</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> fragmentLifecycleCallbacks = <span class="hljs-keyword">object</span> : FragmentManager.FragmentLifecycleCallbacks() &#123;<br><br>    <span class="hljs-comment">// 发现 View</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentViewDestroyed</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">      fm: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">      fragment: <span class="hljs-type">Fragment</span></span></span><br><span class="hljs-function"><span class="hljs-params">    )</span></span> &#123;<br>      <span class="hljs-keyword">val</span> view = fragment.view<br>      <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) &#123;<br>        reachabilityWatcher.expectWeaklyReachable(<br>          view, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroyView() callback &quot;</span> +<br>          <span class="hljs-string">&quot;(references to its views should be cleared to prevent leaks)&quot;</span><br>        )<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 发现 Fragment</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentDestroyed</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">      fm: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">      fragment: <span class="hljs-type">Fragment</span></span></span><br><span class="hljs-function"><span class="hljs-params">    )</span></span> &#123;<br>      reachabilityWatcher.expectWeaklyReachable(<br>        fragment, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroy() callback&quot;</span><br>      )<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="检测-ViewModel-泄漏"><a href="#检测-ViewModel-泄漏" class="headerlink" title="检测 ViewModel 泄漏"></a>检测 <code>ViewModel</code> 泄漏</h3><p><code>Fragment</code> 里的 <code>ViewModel</code> 则是在 <code>FragmentLifecycleCallbacks.onFragmentCreated</code> 时，注入一个 <code>ViewModel</code>，通过反射拿到 <code>ViewModelStore.mMap</code>，这里有所有的 <code>ViewModel</code>，在 <code>ViewModel.onCleared</code> 时把它们加入 <code>ObjectWatcher</code> 进行泄漏检查</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModelClearedWatcher</span></span>(<br>  storeOwner: ViewModelStoreOwner,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : ViewModel() &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModelMap: Map&lt;String, ViewModel&gt;?<br><br>  <span class="hljs-keyword">init</span> &#123;<br>    <span class="hljs-comment">// We could call ViewModelStore#keys with a package spy in androidx.lifecycle instead,</span><br>    <span class="hljs-comment">// however that was added in 2.1.0 and we support AndroidX first stable release. viewmodel-2.0.0</span><br>    <span class="hljs-comment">// does not have ViewModelStore#keys. All versions currently have the mMap field.</span><br>    viewModelMap = <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">val</span> mMapField = ViewModelStore::<span class="hljs-keyword">class</span>.java.getDeclaredField(<span class="hljs-string">&quot;mMap&quot;</span>)<br>      mMapField.isAccessible = <span class="hljs-literal">true</span><br>      <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>      mMapField[storeOwner.viewModelStore] <span class="hljs-keyword">as</span> Map&lt;String, ViewModel&gt;<br>    &#125; <span class="hljs-keyword">catch</span> (ignored: Exception) &#123;<br>      <span class="hljs-literal">null</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span></span> &#123;<br>    viewModelMap?.values?.forEach &#123; viewModel -&gt;<br>      reachabilityWatcher.expectWeaklyReachable(<br>        viewModel, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;viewModel::class.java.name&#125;</span> received ViewModel#onCleared() callback&quot;</span><br>      )<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">      storeOwner: <span class="hljs-type">ViewModelStoreOwner</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">      reachabilityWatcher: <span class="hljs-type">ReachabilityWatcher</span></span></span><br><span class="hljs-function"><span class="hljs-params">    )</span></span> &#123;<br>      <span class="hljs-keyword">val</span> provider = ViewModelProvider(storeOwner, <span class="hljs-keyword">object</span> : Factory &#123;<br>        <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : ViewModel?&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(modelClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T =<br>          ViewModelClearedWatcher(storeOwner, reachabilityWatcher) <span class="hljs-keyword">as</span> T<br>      &#125;)<br>      provider.<span class="hljs-keyword">get</span>(ViewModelClearedWatcher::<span class="hljs-keyword">class</span>.java)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="检测更多类型的泄漏"><a href="#检测更多类型的泄漏" class="headerlink" title="检测更多类型的泄漏"></a>检测更多类型的泄漏</h3><p>对 <code>Service</code> 的检查就比较 hack 了，通过反射替换 <code>ActivityThread.mH.mCallback</code>，通过 <code>Message.waht == H.STOP_SERVICE</code> 定位到 <code>ActivityThread.handleStopService</code> 的调用时机，然后把这个被 stop 的 <code>Service</code> 记录下来；用动态代理实现 <code>IActivityManager</code> 并替换掉 <code>ActivityManager.IActivityManagerSinglteon.mInstance</code>，从而拦截方法 <code>serviceDoneExecuting</code>，此方法的调用表示 <code>Service</code> 生命周期已完结，可以把它交由 <code>ObjectWatcher</code> 进行监控</p><p>这给我启示，对于我们感兴趣的对象（需要警惕泄漏的对象，比如 <code>Bitmap</code>），都可以通过 <code>ObjectWatcher</code> 去检测泄漏问题</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> : <span class="hljs-type">Service &#123;</span></span><br><br>  <span class="hljs-comment">// ...</span><br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onDestroy()<br>    AppWatcher.objectWatcher.watch(<br>      watchedObject = <span class="hljs-keyword">this</span>,<br>      description = <span class="hljs-string">&quot;MyService received Service#onDestroy() callback&quot;</span><br>    )<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="堆转储"><a href="#堆转储" class="headerlink" title="堆转储"></a>堆转储</h2><p>利用 <code>Debug#dumpHprofData(fileName)</code>（但是生成的 hprof 文件很大）</p><h2 id="解析堆转储文件"><a href="#解析堆转储文件" class="headerlink" title="解析堆转储文件"></a>解析堆转储文件</h2><p>利用 <a href="https://square.github.io/leakcanary/shark/">Shark</a>（性能是个问题）</p><h2 id="组织并输出泄漏问题"><a href="#组织并输出泄漏问题" class="headerlink" title="组织并输出泄漏问题"></a>组织并输出泄漏问题</h2><p>通过 <a href="https://square.github.io/leakcanary/shark/">Shark</a> 找到泄漏对象到 GC Root 的路径</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="为什么不需要手动初始化？"><a href="#为什么不需要手动初始化？" class="headerlink" title="为什么不需要手动初始化？"></a>为什么不需要手动初始化？</h3><p><code>LeakCanary</code> 把初始化代码放在 <code>ContentProvider.onCreate()</code> 里（具体是 <code>AppWatcherInstaller</code>），而 <code>ContentProvider.onCreate()</code> 会早于 <code>Application.onCreate</code> 被调用</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// ContentProvider.onCreate 会早于 Application.onCreate</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ActivityThread.handleBindApplication(AppBindData data) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// If the app is being launched for full backup or restore, bring it up in</span><br>    <span class="hljs-comment">// a restricted environment with the base application class.</span><br>    app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// Propagate autofill compat state</span><br>    app.setAutofillOptions(data.autofillOptions);<br>    <span class="hljs-comment">// Propagate Content Capture options</span><br>    app.setContentCaptureOptions(data.contentCaptureOptions);<br>    mInitialApplication = app;<br>    <span class="hljs-comment">// don&#x27;t bring up providers in restricted mode; they may depend on the</span><br>    <span class="hljs-comment">// app&#x27;s custom Application class</span><br>    <span class="hljs-keyword">if</span> (!data.restrictedBackupMode) &#123;<br>        <span class="hljs-keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;<br>            installContentProviders(app, data.providers);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Do this after providers, since instrumentation tests generally start their</span><br>    <span class="hljs-comment">// test thread at this point, and we don&#x27;t want that racing.</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        mInstrumentation.onCreate(data.instrumentationArgs);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>            <span class="hljs-string">&quot;Exception thrown in onCreate() of &quot;</span><br>            + data.instrumentationName + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        mInstrumentation.callApplicationOnCreate(app);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>              <span class="hljs-string">&quot;Unable to create application &quot;</span> + app.getClass().getName()<br>              + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">installContentProviders</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        Context context, List&lt;ProviderInfo&gt; providers)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (ProviderInfo cpi : providers) &#123;<br>        ContentProviderHolder cph = installProvider(context, <span class="hljs-keyword">null</span>, cpi,<br>                <span class="hljs-keyword">false</span> <span class="hljs-comment">/*noisy*/</span>, <span class="hljs-keyword">true</span> <span class="hljs-comment">/*noReleaseNeeded*/</span>, <span class="hljs-keyword">true</span> <span class="hljs-comment">/*stable*/</span>);<br>        <span class="hljs-keyword">if</span> (cph != <span class="hljs-keyword">null</span>) &#123;<br>            cph.noReleaseNeeded = <span class="hljs-keyword">true</span>;<br>            results.add(cph);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化 ContentProvider 并调用生命周期函数 onCreate</span><br><span class="hljs-keyword">private</span> ContentProviderHolder ActivityThread.installProvider(Context context,<br>        ContentProviderHolder holder, ProviderInfo info,<br>        <span class="hljs-keyword">boolean</span> noisy, <span class="hljs-keyword">boolean</span> noReleaseNeeded, <span class="hljs-keyword">boolean</span> stable) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();<br>    LoadedApk packageInfo = peekPackageInfo(ai.packageName, <span class="hljs-keyword">true</span>);<br>    <span class="hljs-keyword">if</span> (packageInfo == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// System startup case.</span><br>        packageInfo = getSystemContext().mPackageInfo;<br>    &#125;<br>    localProvider = packageInfo.getAppFactory()<br>            .instantiateProvider(cl, info.name);<br>    provider = localProvider.getIContentProvider();<br>    <span class="hljs-keyword">if</span> (provider == <span class="hljs-keyword">null</span>) &#123;<br>        Slog.e(TAG, <span class="hljs-string">&quot;Failed to instantiate class &quot;</span> +<br>              info.name + <span class="hljs-string">&quot; from sourceDir &quot;</span> +<br>              info.applicationInfo.sourceDir);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (DEBUG_PROVIDER) Slog.v(<br>        TAG, <span class="hljs-string">&quot;Instantiating local provider &quot;</span> + info.name);<br>    <span class="hljs-comment">// XXX Need to create the correct context for this provider.</span><br>    localProvider.attachInfo(c, info);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> ContentProvider.attachInfo(Context context, ProviderInfo info) &#123;<br>    attachInfo(context, info, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ContentProvider.attachInfo(Context context, ProviderInfo info, <span class="hljs-keyword">boolean</span> testing) &#123;<br>    <span class="hljs-comment">// ...</span><br>    ContentProvider.<span class="hljs-keyword">this</span>.onCreate();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="有什么缺点"><a href="#有什么缺点" class="headerlink" title="有什么缺点"></a>有什么缺点</h3><ol><li><code>LeakCanary</code> 是在 app process 内 heap dump 的，期间进程内的其他线程会被挂起直到 heap dump 完成，这会导致 app 无响应，生产环境下是不可接受的</li><li>hprof 文件往往达到 400M / 500M 这个量级，客户端存储是个问题</li><li>hprof 文件要回传给服务器分析，但是文件太大网络消耗也有很大问题</li><li>如果是在客户端分析 hprof 文件，由于文件太大导致分析进程在很多情况下自己也 OOM 了</li></ol>]]></content>
    
    
    <categories>
      
      <category>内存优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeakCanary</tag>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap 的一些知识点</title>
    <link href="/blog/2021/04/05/hashmap/"/>
    <url>/blog/2021/04/05/hashmap/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap-的桶由链表变为红黑树（树化）的过程"><a href="#HashMap-的桶由链表变为红黑树（树化）的过程" class="headerlink" title="HashMap 的桶由链表变为红黑树（树化）的过程"></a>HashMap 的桶由链表变为红黑树（树化）的过程</h2><h3 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h3><ol><li>节点为红色或者黑色</li><li>根节点必须是黑的</li><li>红色节点的左右子节点必须为黑色</li><li>一个节点到叶子节点的每条路径必须包含相同数目的黑色节点</li></ol><h3 id="颜色变换和两种选择"><a href="#颜色变换和两种选择" class="headerlink" title="颜色变换和两种选择"></a>颜色变换和两种选择</h3><p>添加新节点后，因为新节点总是红色的，那么会有几种情况出现：</p><ol><li>新节点是根节点，也就是说树是空的，根据规则二，把新节点设为黑色即可</li><li>新节点的父节点是黑色，或者父节点是根，满足规则</li><li>父节点是红色，违反规则三，需要进行 <strong>平衡</strong> 操作</li></ol><p>平衡操作主要是根据情况组合使用下面三种转换（方块表示一棵满足红黑树规则的子树）：</p><p><img src="../../../../image/2021-04-05-hashmap/op_1.png" alt="单旋"></p><p><img src="../../../../image/2021-04-05-hashmap/op_2.png" alt="双旋"></p><p><img src="../../../../image/2021-04-05-hashmap/op_3.png" alt="颜色变换"></p><h3 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h3><h4 id="为什么要进行旋转？"><a href="#为什么要进行旋转？" class="headerlink" title="为什么要进行旋转？"></a>为什么要进行旋转？</h4><p>由于 P（父节点 和 X（新节点）都为红色，违反规则三</p><h4 id="为什么新节点总是红色？"><a href="#为什么新节点总是红色？" class="headerlink" title="为什么新节点总是红色？"></a>为什么新节点总是红色？</h4><p>因为添加新节点前的树结构是构建好的，一但我们添加黑色节点，无论添加在哪里都会破坏原有路径上的黑色节点的数量平等关系，所以插入红色节点是正确的选择</p><h4 id="为什么要进行颜色变换？"><a href="#为什么要进行颜色变换？" class="headerlink" title="为什么要进行颜色变换？"></a>为什么要进行颜色变换？</h4><p>如果叶子节点是红色的，那么我们在添加的时候只能添加黑色节点，然而添加任何黑色叶子节点都会违反规则四，所以要对其进行变换。进行变换后叶子节点是黑色的，而且我们默认添加的叶子节点是红色的，添加到红色的新节点后并不会违反规则四，所以这种变换很有用</p><h4 id="第二种双变换中在树的内部怎么出现的红色的节点？"><a href="#第二种双变换中在树的内部怎么出现的红色的节点？" class="headerlink" title="第二种双变换中在树的内部怎么出现的红色的节点？"></a>第二种双变换中在树的内部怎么出现的红色的节点？</h4><p>正是由于上面的颜色变换导致颜色变换后的节点与他的父节点产生了颜色冲突</p><h3 id="HashMap-树化的过程"><a href="#HashMap-树化的过程" class="headerlink" title="HashMap 树化的过程"></a>HashMap 树化的过程</h3><p>当满足下述条件时才将链表树化为红黑树</p><ul><li>桶内元素超过 <code>TREEIFY_THRESHOLD = 8</code>（当桶内元素小于 <code>UNTREEIFY_THRESHOLD = 6</code> 时，红黑树会降级为链表）</li><li>桶的数量超过 <code>MIN_TREEIFY_CAPACITY</code>（小于这个数量只是进行扩容操作）；无论是链表还是红黑树，都是为了解决哈希冲突，如果桶太少则应该首先增加桶的数量降低哈希冲突出现的概率，其次才是用红黑树增加查找效率</li></ul><p>首先将 <code>Node</code> 转变为 <code>TreeNode</code>，此时还是链表结构；第一个节点即为根，后面的节点作为新节点，按规则依次添加到树里：比父节点小则添加到左子树，比父节点大则添加到右子树，从上往下搜索直到要添加的子树为空即为新节点的位置；每次插入新节点后都需要进行 <strong>平衡</strong> 操作</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    <span class="hljs-comment">// ... 将新元素添加至链表尾部（桶），如果桶的大小超过 TREEIFY_THRESHOLD，准备树化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>        <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>            p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                treeifyBin(tab, hash);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果桶的数量 &lt; MIN_TREEIFY_CAPACITY，只是扩容</span><br>    <span class="hljs-keyword">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<br>    <br>    <span class="hljs-comment">// 桶多于 MIN_TREEIFY_CAPACITY 才树化</span><br>    <span class="hljs-comment">// 将桶 tab[index] 里的节点转变为 TreeNode，但 此时还是链表</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>)<br>                hd = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-comment">// hd 是链表头，从它开始树化</span><br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 将还是链表的桶树化，当前是链表头</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeify</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 链表里第一个元素作为红黑树初始的根</span><br>    <span class="hljs-comment">// 遍历链表，逐个添加到红黑树中</span><br>    TreeNode&lt;K,V&gt; root = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="hljs-keyword">this</span>, next; x != <span class="hljs-keyword">null</span>; x = next) &#123;<br>        next = (TreeNode&lt;K,V&gt;)x.next;<br>        x.left = x.right = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            x.parent = <span class="hljs-keyword">null</span>;<br>            x.red = <span class="hljs-keyword">false</span>;<br>            root = x;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            K k = x.key;<br>            <span class="hljs-keyword">int</span> h = x.hash;<br>            Class&lt;?&gt; kc = <span class="hljs-keyword">null</span>;<br><br>            <span class="hljs-comment">// 从根开始，自上而下找位置</span><br>            <span class="hljs-comment">// 比父节点小则插入到左子树，比父节点大则插入到右子树，直到所插入的位置为 null</span><br>            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;<br><br>                <span class="hljs-comment">// x - 新节点，p - 父节点，h - 新节点 hash，ph - parent hash</span><br>                <span class="hljs-comment">// dir == -1，新节点比父节点小，添加到左子树；dir == 1，新节点比父节点大，添加到右子树</span><br>                <span class="hljs-keyword">int</span> dir, ph;<br>                K pk = p.key;<br>                <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)<br>                    dir = -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)<br>                    dir = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc == <span class="hljs-keyword">null</span> &amp;&amp;<br>                          (kc = comparableClassFor(k)) == <span class="hljs-keyword">null</span>) ||<br>                         (dir = compareComparables(kc, k, pk)) == <span class="hljs-number">0</span>)<br>                    dir = tieBreakOrder(k, pk);<br><br>                <span class="hljs-comment">// xp - 新节点的父节点</span><br>                <span class="hljs-comment">// 一直找，直到新节点需要插入的位置是为 null，那么就把新节点放在那</span><br>                TreeNode&lt;K,V&gt; xp = p;<br>                <span class="hljs-keyword">if</span> ((p = (dir &lt;= <span class="hljs-number">0</span>) ? p.left : p.right) == <span class="hljs-keyword">null</span>) &#123;<br>                    x.parent = xp;<br>                    <span class="hljs-keyword">if</span> (dir &lt;= <span class="hljs-number">0</span>)<br>                        xp.left = x;<br>                    <span class="hljs-keyword">else</span><br>                        xp.right = x;<br>                    <span class="hljs-comment">// 插入新节点后可能会破坏红黑树的平衡，每次插入后都要执行平衡操作</span><br>                    root = balanceInsertion(root, x);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    moveRootToFront(tab, root);<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 插入新节点后需要平衡红黑树</span><br><span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">balanceInsertion</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span> </span>&#123;<br>    x.red = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 新节点总是红色的</span><br><br>    <span class="hljs-comment">// xp - 新节点的 parent，xpp - 新节点的祖父，xppl - 祖父的左孩子，xppr - 祖父的右孩子</span><br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;<br><br>        <span class="hljs-comment">// 新节点没有父节点，说明它是根节点，根节点必须是黑色</span><br>        <span class="hljs-keyword">if</span> ((xp = x.parent) == <span class="hljs-keyword">null</span>) &#123;<br>            x.red = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br><br>        <span class="hljs-comment">// 1，不是根节点且父节点是黑色，满足红黑树的条件，返回即可</span><br>        <span class="hljs-comment">// 2，祖父为 null 说明父节点为根，根一定是黑色，新节点为红色，满足条件</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">// 父节点是红色且有祖父节点，那就比较麻烦了，必须要进行旋转和颜色变换操作，此时父节点是祖父的左孩子    </span><br>        <span class="hljs-keyword">if</span> (xp == (xppl = xpp.left)) &#123;<br><br>            <span class="hljs-comment">// 新节点是红色，父节点也是红色，父节点旁边的兄弟节点也是红色（由于当前红黑树除新节点外是平衡的，所以祖父肯定是黑色）</span><br>            <span class="hljs-comment">// 那么进行颜色变换：将父节点和它的兄弟节点变为黑色，祖父变为红色，对应图三</span><br>            <span class="hljs-comment">// 祖父变色后，可能引起祖父上面不平衡，所以下次循环要操作祖父</span><br>            <span class="hljs-keyword">if</span> ((xppr = xpp.right) != <span class="hljs-keyword">null</span> &amp;&amp; xppr.red) &#123;<br>                xppr.red = <span class="hljs-keyword">false</span>;<br>                xp.red = <span class="hljs-keyword">false</span>;<br>                xpp.red = <span class="hljs-keyword">true</span>;<br>                x = xpp;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br><br>                <span class="hljs-comment">// 父节点的兄弟为黑色 or 为空，那么就要通过旋转解决两个红色节点相连的问题</span><br>                <span class="hljs-comment">// 新节点是右孩子，对应图二的双旋，这里是第一次的左旋</span><br>                <span class="hljs-keyword">if</span> (x == xp.right) &#123;<br>                    root = rotateLeft(root, x = xp);<br>                    xpp = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.parent;<br>                &#125;<br><br>                <span class="hljs-comment">// 继续上面的（左旋）后的第二次右旋</span><br>                <span class="hljs-comment">// 或者对应图一的单旋（右旋）</span><br>                <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                    xp.red = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">if</span> (xpp != <span class="hljs-keyword">null</span>) &#123;<br>                        xpp.red = <span class="hljs-keyword">true</span>;<br>                        root = rotateRight(root, xpp);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 同样是旋转和颜色变换操作，只不过父节点现在是祖父的右孩子，流程跟上面差不多的</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (xppl != <span class="hljs-keyword">null</span> &amp;&amp; xppl.red) &#123;<br>                xppl.red = <span class="hljs-keyword">false</span>;<br>                xp.red = <span class="hljs-keyword">false</span>;<br>                xpp.red = <span class="hljs-keyword">true</span>;<br>                x = xpp;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (x == xp.left) &#123;<br>                    root = rotateRight(root, x = xp);<br>                    xpp = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.parent;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                    xp.red = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">if</span> (xpp != <span class="hljs-keyword">null</span>) &#123;<br>                        xpp.red = <span class="hljs-keyword">true</span>;<br>                        root = rotateLeft(root, xpp);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="扩容的过程"><a href="#扩容的过程" class="headerlink" title="扩容的过程"></a>扩容的过程</h2><h3 id="计算扩容大小和下一次扩容阈值"><a href="#计算扩容大小和下一次扩容阈值" class="headerlink" title="计算扩容大小和下一次扩容阈值"></a>计算扩容大小和下一次扩容阈值</h3><p>扩容时，容量翻倍，下一次扩容阈值 <code>threshold</code> 也翻倍；特殊情况是当前容量小于默认初始容量 <code>DEFAULT_INITIAL_CAPACITY = 16</code> 时，<code>threshold</code> 不翻倍而是取扩容后的负载因子倍数</p><p>第一次扩容时 <code>table</code> 尚未初始化，当前容量为零，如果构造函数有设置 <code>initialCapacity</code>，则扩容后的大小为 <code>initialCapacity</code>，下一次扩容阈值为 <code>initialCapacity * loadFactor</code>；否则扩容后大小和负载因子都取默认值</p><p>第一次扩容时，<code>threshold</code> 取 <code>initialCapacity * loadFactor</code>，而 <code>loadFactor</code> 总是小于等于 1 的，所以 <code>threshold</code> 总是小于等于 <code>capacity</code>，后续即使翻倍 <code>threshold</code> 也是小于等于 <code>capacity</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// table 已被初始化的情况（table != null）</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br><br>        <span class="hljs-comment">// 限制最大容量（MAXIMUM_CAPACITY = 1 &lt;&lt; 30）</span><br>        <span class="hljs-comment">// 因为容量是个 int 值，要限制下不至于溢出</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br><br>        <span class="hljs-comment">// 最常见的情况：capacity 和 threshold 翻一倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br><br>    <span class="hljs-comment">// 第一次扩容，table 还未被初始化但是 threshold 有值，那么把它作为扩容后的容量</span><br>    <span class="hljs-comment">// 对应 HashMap(initialCapacity, loadFactor)，HashMap(initialCapacity) 和 HashMap(Map&lt;? extends K, ? extends V&gt; m) 这三种情况</span><br>    <span class="hljs-comment">// 前两种情况 threshold 可以通过 initialCapacity 算出来，后一种情况可以通过 Map 大小算出来</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br><br>    <span class="hljs-comment">// table 还未被初始化并且 threshold 也没有值，对应 HashMap()</span><br>    <span class="hljs-comment">// 没有传入 initialCapacity，threshold 没有参考值所以为零，那么使用默认值</span><br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br><br>    <span class="hljs-comment">// 1，当 table 尚未初始化且 threshold/initialCapacity 有值</span><br>    <span class="hljs-comment">// 2，当 table 已初始化但扩容前的容量 &lt; DEFAULT_INITIAL_CAPACITY</span><br>    <span class="hljs-comment">// 下一次扩容大小 newThr 为扩容后到达负载因子的水平</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="重新-hash"><a href="#重新-hash" class="headerlink" title="重新 hash"></a>重新 hash</h3><ol><li>只有一个元素，重新 hash 算出新位置即可</li><li>链表的情况，因为 <code>capacity</code> 总是 2 的次方，<code>capacity</code> 形如 <code>100000</code> 而 <code>capacity - 1</code> 形如 <code>011111</code>，通过 <code>e.hash &amp; oldCap) == 0</code> 把链表拆分为两个链表 low（高位为 0）和 high（高位为 1），low 留在原位 <code>newTab[j]</code>，high 迁移到 <code>newTab[j + oldCap]</code></li><li>如果是红黑树，跟链表一样先拆分和迁移，如果链表里元素数量小于等于 <code>UNTREEIFY_THRESHOLD = 6</code> 则转化为链表，否则重新构建红黑树</li></ol><p>为什么拆分链表是可行的？假设当前容量 4 扩容后为 8，那么 hash 的右值为 <code>0011</code> 和 <code>0111</code>（object.hash() * (capacity - 1)，扩容的翻倍操作实际上是左移一位），可以看到区别就是高位对应的 object.hash() 值，高位 hash 为零即使扩容了位置也不变，高位 hash 为 1 则迁移到 oldCap + j 的位置上（obj 相当于高位对应的部分，j 则是低位对应的部分）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    <span class="hljs-comment">// ...</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;  <span class="hljs-comment">// 遍历旧 table</span><br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br><br>                <span class="hljs-comment">// 如果桶中只有一个元素，重新计算位置并迁移</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br><br>                <span class="hljs-comment">// 红黑树，拆分并重建红黑树    </span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br><br>                <span class="hljs-comment">// 桶里是链表，根据高位是 0 还是 1 把链表拆分为两个链表（low 和 high）</span><br>                <span class="hljs-comment">// low 留在原来的位置，hihg 迁移到新位置</span><br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br><br><span class="hljs-comment">// 红黑树重新 hash 的过程</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> bit)</span> </span>&#123;<br>    <span class="hljs-comment">// 跟链表一样根据高位拆分为 low（0）和 high（1）两个链表</span><br>    TreeNode&lt;K,V&gt; b = <span class="hljs-keyword">this</span>;<br>    TreeNode&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>    TreeNode&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lc = <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="hljs-keyword">null</span>; e = next) &#123;<br>        next = (TreeNode&lt;K,V&gt;)e.next;<br>        e.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> ((e.hash &amp; bit) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((e.prev = loTail) == <span class="hljs-keyword">null</span>)<br>                loHead = e;<br>            <span class="hljs-keyword">else</span><br>                loTail.next = e;<br>            loTail = e;<br>            ++lc;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> ((e.prev = hiTail) == <span class="hljs-keyword">null</span>)<br>                hiHead = e;<br>            <span class="hljs-keyword">else</span><br>                hiTail.next = e;<br>            hiTail = e;<br>            ++hc;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拆分后，如果 &lt; UNTREEIFY_THRESHOLD 则转为链表，否则重新构建红黑树</span><br>    <span class="hljs-keyword">if</span> (loHead != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)<br>            tab[index] = loHead.untreeify(map);<br>        <span class="hljs-keyword">else</span> &#123;<br>            tab[index] = loHead;<br>            <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// (else is already treeified)</span><br>                loHead.treeify(tab);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)<br>            tab[index + bit] = hiHead.untreeify(map);<br>        <span class="hljs-keyword">else</span> &#123;<br>            tab[index + bit] = hiHead;<br>            <span class="hljs-keyword">if</span> (loHead != <span class="hljs-keyword">null</span>)<br>                hiHead.treeify(tab);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/e136ec79235c">30张图带你彻底理解红黑树</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>JDK</category>
      
      <category>Collection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC 下一些线程安全的容器</title>
    <link href="/blog/2021/03/31/juc-collection/"/>
    <url>/blog/2021/03/31/juc-collection/</url>
    
    <content type="html"><![CDATA[<h2 id="写时复制（Copy-On-Write）"><a href="#写时复制（Copy-On-Write）" class="headerlink" title="写时复制（Copy On Write）"></a>写时复制（Copy On Write）</h2><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><code>CopyOnWriteArrayList</code></h3><p>使用 <strong>写时复制</strong> 实现的线程安全版 <code>ArrayList</code>，当发生修改操作时（add、set、remove）才加锁，将原数组复制一份并在上面修改成为新数组，最后用新数组替换原数组</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-keyword">int</span> len = elements.length;<br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>也就是说所有的修改操作都不会修改原数组，这样所有的读操作（get、iterate）都可以不加锁，从而实现高效的读（虽然有可能会读到旧数据）；因为它的写操作是很昂贵的（复制一份出来），但同时它的读操作和迭代很高效（不上锁），所以它适用于读操作远大于写操作的情况；<code>CopyOnWriteArraySet</code> 内部是通过 <code>CopyOnWriteArrayList</code> 实现的</p><h2 id="分段加锁"><a href="#分段加锁" class="headerlink" title="分段加锁"></a>分段加锁</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h3><p>跟 <code>HashMap</code> 一样采用数组 + 链表的实现，链表又叫做桶 or 箱子（bin）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>写时采用 <strong>分段加锁</strong>，不对整个写操作 or <code>table</code> 加锁，而只对所在的桶加锁，其他线程依然可以进行读操作 or 对其他桶进行写操作</p><p>整个 <code>ConcurrentHashMap</code> 都没有使用 <code>Lock</code> 进行阻塞，而是尽可能采用自旋 + CAS（乐观锁，是实现无锁操作的重要函数），最后才用 <code>synchronized</code>（参考文章，它的锁膨胀过程中掺杂自旋和阻塞）对桶上锁</p><p><code>tabAt</code>、<code>setTabAt</code> 和 <code>casTabAt</code> 使对 <code>table</code> 的操作具有可见性和原子性，避免了对 <code>table</code> 上锁</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;<br>    <span class="hljs-comment">// 没有对整个写操作加锁，也没有对 table 加锁</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());<br>    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// CAS 失败会自旋，是乐观锁</span><br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;<br><br>        <span class="hljs-comment">// 如果 table == null，则进行初始化；初始化后每个桶是 null</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();<br>        <br>        <span class="hljs-comment">// 所在的桶为 null，不加锁直接用 CAS 操作添加新桶头，失败的话自旋</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,<br>                         <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br><br>            <span class="hljs-comment">// 找到所在的不为 null 的桶，对单个桶上锁</span><br>            V oldVal = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br><br>                    <span class="hljs-comment">// 沿着链表从头开始走，如果找到 key 值相等的节点则覆盖旧的 value</span><br>                    <span class="hljs-comment">// 否则作为新节点添加到链表尾部</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-keyword">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// ... 链表被树化为红黑树的情况参考 HashMap 的文章</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 初始化 table，自旋 + CAS</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-keyword">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            Thread.yield(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">int</span> n = (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br><br><span class="hljs-comment">// 使数组的读/写操作像 volatile 成员变量一样具有线程可见性</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;<br>    U.putObjectVolatile(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);<br>&#125;<br><br><span class="hljs-comment">// 在数组上实现 CAS 操作</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i,</span></span><br><span class="hljs-function"><span class="hljs-params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> U.compareAndSwapObject(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然都是线程安全的 map，但 <code>ConcurrentHashMap</code> 的分段加锁对比 <code>HashTable</code> 的整个方法加锁优势就体现出来了，高并发下优势会愈加明显</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// HashTable 对整个写操作加锁</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-comment">// Make sure the value is not null</span><br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    &#125;<br><br>    <span class="hljs-comment">// Makes sure the key is not already in the hashtable.</span><br>    HashtableEntry&lt;?,?&gt; tab[] = table;<br>    <span class="hljs-keyword">int</span> hash = key.hashCode();<br>    <span class="hljs-keyword">int</span> index = (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    HashtableEntry&lt;K,V&gt; entry = (HashtableEntry&lt;K,V&gt;)tab[index];<br>    <span class="hljs-keyword">for</span>(; entry != <span class="hljs-keyword">null</span> ; entry = entry.next) &#123;<br>        <span class="hljs-keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;<br>            V old = entry.value;<br>            entry.value = value;<br>            <span class="hljs-keyword">return</span> old;<br>        &#125;<br>    &#125;<br><br>    addEntry(hash, key, value, index);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>读操作完全不加锁，但是 <code>Node.val</code> 和 <code>Node.next</code> 是 <code>volatile</code> 修饰的，所以 <code>Node</code> 的线程可见性是有保证的</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-keyword">int</span> n, eh; K ek;<br>    <span class="hljs-keyword">int</span> h = spread(key.hashCode());<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-keyword">null</span> ? p.val : <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V val;<br>    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a><code>BlockingQueue</code></h2><p>它提供的阻塞操作包括：</p><p>|————————————|————————-|<br>| <code>put(e)</code>                           | 入队                     |<br>| <code>offer(e, timeout, unit)</code>          | 设置超时的入队             |<br>| <code>take()</code>                           | 出队                     |<br>| <code>poll(timeout, unit)</code>              | 设置超时的出队             |<br>| <code>drainTo(collection, maxElements)</code> | 批量出队并添加到另一个集合中 |</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><code>ArrayBlockingQueue</code></h3><p>基于数组、容量有限的阻塞队列，通过构造函数指定队列的容量</p><p>用两个指针 <code>takeIndex</code>(队头，指向下一次出队的位置) 和 <code>putIndex</code>（队尾，指向下一次入队的位置） 模拟队列，它们初始为 0（最左边），随着元素的入队 <code>putIndex</code> 往右移动，随着元素的出队 <code>takeIndex</code> 也往右移动，当它们越过数组最后边时会重置到最左边，<code>count</code> 确保 <code>takeIndex</code> 不会违规越过 <code>putIndex</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">/** The queued items */</span><br>    <span class="hljs-keyword">final</span> Object[] items;<br><br>    <span class="hljs-comment">/** items index for next take, poll, peek or remove */</span><br>    <span class="hljs-keyword">int</span> takeIndex;<br><br>    <span class="hljs-comment">/** items index for next put, offer, or add */</span><br>    <span class="hljs-keyword">int</span> putIndex;<br><br>    <span class="hljs-comment">/** Number of elements in the queue */</span><br>    <span class="hljs-keyword">int</span> count;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>出队/入队时用了 <code>Lock</code> 和 <code>Condition</code> 实现阻塞和唤醒，出队时如果为空则阻塞在 <code>notEmpty</code> 上，入队时如果满了则阻塞在 <code>notFull</code>，入队后唤醒阻塞在 <code>notEmpty</code> 上的线程，出队后唤醒阻塞在 <code>notFull</code> 上的线程</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">/** Main lock guarding all access */</span><br>    <span class="hljs-keyword">final</span> ReentrantLock lock;<br><br>    <span class="hljs-comment">/** Condition for waiting takes */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><br>    <span class="hljs-comment">/** Condition for waiting puts */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Inserts element at current put position, advances, and signals.</span><br><span class="hljs-comment">     * Call only when holding lock.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(E x)</span> </span>&#123;<br>        <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>        <span class="hljs-comment">// assert items[putIndex] == null;</span><br>        <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;<br>        items[putIndex] = x;<br>        <span class="hljs-keyword">if</span> (++putIndex == items.length) putIndex = <span class="hljs-number">0</span>;<br>        count++;<br>        notEmpty.signal();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Extracts element at current take position, advances, and signals.</span><br><span class="hljs-comment">     * Call only when holding lock.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span><br>        <span class="hljs-comment">// assert items[takeIndex] != null;</span><br>        <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        E x = (E) items[takeIndex];<br>        items[takeIndex] = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="hljs-number">0</span>;<br>        count--;<br>        <span class="hljs-keyword">if</span> (itrs != <span class="hljs-keyword">null</span>)<br>            itrs.elementDequeued();<br>        notFull.signal();<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;  <br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a><code>LinkedBlockingQueue</code></h3><p>基于链表、无限容量（当然也可以通过构造函数设置最大容量）的阻塞队列，链表是单向的，<code>head</code> 指向队头也就是出队的位置，<code>last</code> 指向队尾也就是出队的位置</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Linked list node class.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        E item;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * One of:</span><br><span class="hljs-comment">         * - the real successor Node</span><br><span class="hljs-comment">         * - this Node, meaning the successor is head.next</span><br><span class="hljs-comment">         * - null, meaning there is no successor (this is the last node)</span><br><span class="hljs-comment">         */</span><br>        Node&lt;E&gt; next;<br><br>        Node(E x) &#123; item = x; &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/** The capacity bound, or Integer.MAX_VALUE if none */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity;<br><br>    <span class="hljs-comment">/** Current number of elements */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Head of linked list.</span><br><span class="hljs-comment">     * Invariant: head.item == null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; head;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Tail of linked list.</span><br><span class="hljs-comment">     * Invariant: last.next == null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> </span>&#123;<br>        <span class="hljs-comment">// assert putLock.isHeldByCurrentThread();</span><br>        <span class="hljs-comment">// assert last.next == null;</span><br>        last = last.next = node;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// assert takeLock.isHeldByCurrentThread();</span><br>        <span class="hljs-comment">// assert head.item == null;</span><br>        Node&lt;E&gt; h = head;<br>        Node&lt;E&gt; first = h.next;<br>        h.next = h; <span class="hljs-comment">// help GC</span><br>        head = first;<br>        E x = first.item;<br>        first.item = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>跟 <code>ArrayBlockingQueue</code> 一样用了两个条件变量：<code>notEmpty</code> 和 <code>notFull</code> 来阻塞/唤醒生产者和消费者；为啥会有 <code>notFull</code> 的情况呢，不是无限容量吗？因为它可以设置一个最大容量</p><p>不同的是 <code>LinkedBlockingQueue</code> 用了两个锁，<code>takeLock</code> 给出队加锁，<code>putLock</code> 给入队加锁，出队和入队之所以可以并行是有 <code>count</code> 在确保数量正确</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">/** The capacity bound, or Integer.MAX_VALUE if none */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity;<br><br>    <span class="hljs-comment">/** Current number of elements */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-comment">/** Lock held by take, poll, etc */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-comment">/** Wait queue for waiting takes */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty = takeLock.newCondition();<br><br>    <span class="hljs-comment">/** Lock held by put, offer, etc */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-comment">/** Wait queue for waiting puts */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull = putLock.newCondition();<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><code>PriorityBlockingQueue</code></h3><p>上面两个阻塞队列是 <code>FIFO</code> 排序的，而这个可以用 <code>Comparator</code> 和 <code>Comparable</code> 自定义优先级</p><p>底层用 <strong>小顶堆</strong> 实现的优先队列，小顶堆是用数组实现的二叉树（左右节点要大于父节点）；入队元素添加到叶子那层的最左边，然后自下往上跟父节点比较，如果小则交换，这个操作叫 <code>siftUp</code>；出队元素固定是树的根节点，出队后把最后一个节点作为根节点，从上往下跟左右节点比较，如果大则交换，这个操作叫 <code>siftDown</code>（参考 <a href="../../../../2021/02/19/threadpool/">这篇文章</a> 里堆的介绍）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Priority queue represented as a balanced binary heap: the two</span><br><span class="hljs-comment">     * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The</span><br><span class="hljs-comment">     * priority queue is ordered by comparator, or by the elements&#x27;</span><br><span class="hljs-comment">     * natural ordering, if comparator is null: For each node n in the</span><br><span class="hljs-comment">     * heap and each descendant d of n, n &lt;= d.  The element with the</span><br><span class="hljs-comment">     * lowest value is in queue[0], assuming the queue is nonempty.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Object[] queue;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">siftUpUsingComparator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, T x, Object[] array,</span></span><br><span class="hljs-function"><span class="hljs-params">                                       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; cmp)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> parent = (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>            Object e = array[parent];<br>            <span class="hljs-keyword">if</span> (cmp.compare(x, (T) e) &gt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            array[k] = e;<br>            k = parent;<br>        &#125;<br>        array[k] = x;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">siftDownUsingComparator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, T x, Object[] array,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                    <span class="hljs-keyword">int</span> n,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                    Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; cmp)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> half = n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (k &lt; half) &#123;<br>                <span class="hljs-keyword">int</span> child = (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>                Object c = array[child];<br>                <span class="hljs-keyword">int</span> right = child + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; cmp.compare((T) c, (T) array[right]) &gt; <span class="hljs-number">0</span>)<br>                    c = array[child = right];<br>                <span class="hljs-keyword">if</span> (cmp.compare(x, (T) c) &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                array[k] = c;<br>                k = child;<br>            &#125;<br>            array[k] = x;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然底层是数组但可以扩容，也即无限容量；扩容操作也很细致地分为两步：</p><ul><li>分配一块新内存，用 int 和 CAS 操作实现自旋（也许是认为分配新内存很快，所以用乐观锁？）</li><li>复制数组用 <code>Lock</code></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryGrow</span><span class="hljs-params">(Object[] array, <span class="hljs-keyword">int</span> oldCap)</span> </span>&#123;<br>    <span class="hljs-comment">// 分配内存，自旋</span><br>    lock.unlock(); <span class="hljs-comment">// must release and then re-acquire main lock</span><br>    Object[] newArray = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (allocationSpinLock == <span class="hljs-number">0</span> &amp;&amp;<br>        U.compareAndSwapInt(<span class="hljs-keyword">this</span>, ALLOCATIONSPINLOCK, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="hljs-number">64</span>) ?<br>                                   (oldCap + <span class="hljs-number">2</span>) : <span class="hljs-comment">// grow faster if small</span><br>                                   (oldCap &gt;&gt; <span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// possible overflow</span><br>                <span class="hljs-keyword">int</span> minCap = oldCap + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (minCap &lt; <span class="hljs-number">0</span> || minCap &gt; MAX_ARRAY_SIZE)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();<br>                newCap = MAX_ARRAY_SIZE;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)<br>                newArray = <span class="hljs-keyword">new</span> Object[newCap];<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            allocationSpinLock = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newArray == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// back off if another thread is allocating</span><br>        Thread.yield();<br><br>    <span class="hljs-comment">// 复制数组才上悲观锁</span><br>    lock.lock();<br>    <span class="hljs-keyword">if</span> (newArray != <span class="hljs-keyword">null</span> &amp;&amp; queue == array) &#123;<br>        queue = newArray;<br>        System.arraycopy(array, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, oldCap);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>跟 <code>ArrayBlockingQueue</code> 一样，入队/出队用同一把锁，因为无容量限制所以只需一个条件变量 <code>notEmpty</code>（<code>notFull</code> 的情况不会出现）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Lock used for all public operations.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Condition for blocking when empty.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="总结比较"><a href="#总结比较" class="headerlink" title="总结比较"></a>总结比较</h3><ul><li>需要自定义优先级用 <code>PriorityBlockingQueue</code>，需要无限容量用 <code>LinkedBlockingQueue</code></li><li><code>LinkedBlockingQueue</code> 入队出队分别使用两把锁，也就是说入队出队可以并行，在高并发下会比使用同一把锁的 <code>ArrayBlockingQueue</code> 性能要好</li><li><code>ArrayBlockingQueue</code> 在内存利用率上会比 <code>LinkedBlockingQueue</code> 要好（<code>Node</code> 需要额外的空间），而且底层数组在构造函数时就已预先分配内存，使用时无需动态申请内存，内存波动较小；而动态申请内存的 <code>LinkedBlockingQueue</code> 可能会增加 JVM GC 的负担</li></ul>]]></content>
    
    
    <categories>
      
      <category>JDK</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
      <tag>线程安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是 https ？</title>
    <link href="/blog/2021/03/30/https/"/>
    <url>/blog/2021/03/30/https/</url>
    
    <content type="html"><![CDATA[<p><code>https = http + tls</code></p><p><code>tcp</code> 三次握手建立连接后，再进行 <code>tls</code> 握手/协商得到一个秘钥，然后双方使用这个秘钥加密（对称加密）明文的 http 为密文后再发送，同样双方收到密文后也用这个秘钥解密得到明文</p><p><strong>对称加密</strong> 使用同一秘钥加密和解密，性能高，http 明文就是通过对称加密后才进行传输的，对称加密算法有：<code>DES</code>、<code>3DES</code>、<code>AES</code> 等；但秘钥交换是个问题，所以需要非对称加密的帮助</p><p><strong>非对称加密</strong> 公钥加密则私钥解密，私钥加密则公钥解密，性能比对称加密要差，不适合加解密大量的数据，但很适合于解决秘钥交换的问题，常用的有：<code>RSA</code>、<code>DSA</code> 等</p><h2 id="tls-协商的过程"><a href="#tls-协商的过程" class="headerlink" title="tls 协商的过程"></a>tls 协商的过程</h2><h3 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h3><p>客户端发送：<strong>客户端随机数</strong>（client random）和客户端支持的 <strong>加密套件列表</strong></p><h3 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h3><p>服务端从客户端支持的加密套件中选择一个，然后发送：<strong>服务端随机数</strong>（server random）和 <strong>选用的套件</strong>，比如 <code>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</code> 就是：</p><ul><li>密钥协商使用 <code>ECDHE</code></li><li>签名算法使用 <code>RSA</code></li><li>加密 http 明文所使用的对称加密算法是 <code>AES</code>，密钥长度 256，分组模式 <code>GCM</code></li><li>摘要算法使用 <code>SHA384</code></li></ul><h3 id="Server-Certificate"><a href="#Server-Certificate" class="headerlink" title="Server Certificate"></a>Server Certificate</h3><p>服务端发送 <strong>CA 证书</strong></p><h3 id="Server-Key-Exchange"><a href="#Server-Key-Exchange" class="headerlink" title="Server Key Exchange"></a>Server Key Exchange</h3><p>服务端生成一个随机数作为 <strong>服务端椭圆曲线私钥</strong>，选择一个 <strong>椭圆曲线</strong>（比如 named_curve）和 <strong>椭圆曲线基点 G</strong>，根据 G 和服务端椭圆曲线私钥生成 <strong>服务端椭圆曲线公钥</strong></p><p>为了确保服务端椭圆曲线公钥不被篡改，服务端用 RSA + 服务端 CA 私钥给服务端椭圆曲线公钥做个签名 <strong>signature</strong></p><p>最后发送椭圆曲线、G、服务端椭圆曲线公钥和 signature 给客户端</p><h3 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a>Server Hello Done</h3><p>服务端告诉客户端我这边的信息已经发送完毕</p><h3 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h3><p>客户端进行 CA 证书校验；同样生成一个随机数作为 <strong>客户端椭圆曲线私钥</strong>，根据服务端给的 G 和客户端椭圆曲线私钥生成 <strong>客户端椭圆曲线公钥</strong> 发给服务端（服务端 CA 公钥加密签名防篡改）</p><p>此时客户端算出椭圆曲线秘钥 = f(客户端椭圆曲线私钥，服务端椭圆曲线公钥)，服务端也算出椭圆曲线秘钥 = f(服务端椭圆曲线私钥，客户端椭圆曲线公钥)</p><p>而两端算出的 <strong>椭圆曲线秘钥</strong> 是一致的，但这还没有结束，对 http 明文进行加密的 <strong>主秘钥</strong> = server random + client random + 椭圆曲线秘钥</p><h3 id="Change-Cipher-Spec"><a href="#Change-Cipher-Spec" class="headerlink" title="Change Cipher Spec"></a>Change Cipher Spec</h3><p>服务端和客户端都通知对方，后续的数据传输将使用 RSA + 主秘钥加密了</p><h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h3><p>第一个由 tls 记录层协议进行加密保护的信息，双方需要验证对方发送的 Finished 信息，保证协商的密钥是可用的，保证协商过程中，没有被篡改</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>https 使用对称加密（比如 <code>RSA</code>）对 http 明文进行加密传输，这个秘钥叫 <strong>主秘钥</strong>，但要确保 <strong>秘钥交换</strong> 过程是安全的；那怎样的交换过程是安全的呢？当然不交换，服务端和客户端各自按照一定的规则生成相同秘钥最安全！</p><p>上面说到主秘钥 = server random + client random + 椭圆曲线秘钥，server random 和 client random 都是公开的不安全的（引入它俩的目的是增加随机性），那么主秘钥的安全性全靠椭圆曲线秘钥了</p><p>客户端椭圆曲线秘钥 = f(客户端椭圆曲线私钥，服务端椭圆曲线公钥)，服务端椭圆曲线秘钥 = f(服务端椭圆曲线私钥，客户端椭圆曲线公钥)，公钥都是公开的所以由私钥确保安全性，而私钥都是随机产生且不经过网络传输的，所以椭圆曲线秘钥是安全的（椭圆曲线的数学特性确保其客户端和服务端算出的是一致的）</p><p>总的来说 <code>ECDHE</code> 靠本地计算替代网络传输保证了秘钥的安全</p><h2 id="提问时间"><a href="#提问时间" class="headerlink" title="提问时间"></a>提问时间</h2><h3 id="怎么证明CA机构的公钥是可信的"><a href="#怎么证明CA机构的公钥是可信的" class="headerlink" title="怎么证明CA机构的公钥是可信的"></a>怎么证明CA机构的公钥是可信的</h3><p>CA 证书是从上到下一级一级地签发下来的，操作系统内置 root CA，可以从下到上逐级确认</p><h3 id="如何防范中间人攻击"><a href="#如何防范中间人攻击" class="headerlink" title="如何防范中间人攻击"></a>如何防范中间人攻击</h3><p>计算报文的 hash，并用服务器的私钥加密生成数字签名；客户端用服务器的公钥解密数字签名得到报文 hash 并与实际计算出的报文 hash 值比对，即可判断出报文有没被修改过</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 的三次握手和四次挥手</title>
    <link href="/blog/2021/03/13/tcp-handshake-goodbye/"/>
    <url>/blog/2021/03/13/tcp-handshake-goodbye/</url>
    
    <content type="html"><![CDATA[<p><img src="../../../../image/2021-03-23-tcp-handshake-goodbye/tcp_header.jpeg" alt="tpc_header.jpeg"></p><h2 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h2><ul><li>从 TCP 连接建立的开始，到 TCP 连接的断开，你要传输的所有数据的每一个字节都要编号，这个序号称为 <strong>字节序号</strong></li><li>如果一个 TCP 报文的 <strong>报文序号</strong> 为 301，它携带了 100 字节的数据，就表示这 100 个字节的数据的字节序号范围是 [301, 400]，该报文携带的第一个字节序号是 301，最后一个字节序号是 400</li><li>每传送一个 TCP 报文都要等待对方回复一个确认，但这种方式效率太低，在 TCP 协议中，一般采用累积确认的方式，即每次传送多个连续 TCP 报文，可以只对最后一个 TCP 报文进行确认。对方通过回复一个 <strong>确认号</strong> 来表示已经接收到了哪个 TCP 报文。比如发送方发送了一个序号为 301 的 TCP 报文，这个报文携带了 100 字节数据，则接收方应当回复的确认号是 401，它表示接收方已经收到了字节序号为 [300, 400] 的数据，现在期望你发送字节序号为 401 以及以后的数据</li></ul><h2 id="SYN、ACK-和-FIN"><a href="#SYN、ACK-和-FIN" class="headerlink" title="SYN、ACK 和 FIN"></a>SYN、ACK 和 FIN</h2><ul><li><code>ACK</code>：TCP 协议规定，只有 <code>ACK=1</code> 时有效，也规定连接建立后所有发送的报文的 <code>ACK</code> 必须为 1</li><li><code>SYN</code>：在连接建立时用来同步序号。当 <code>SYN=1</code> 而 <code>ACK=0</code> 时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使 <code>SYN=1</code> 和 <code>ACK=1</code>。因此 <code>SYN</code> 置 1 就表示这是一个连接请求或连接接受报文</li><li><code>FIN</code>：用来释放一个连接。当 <code>FIN=1</code> 表明此发送方的数据已经发送完毕并要求释放连接</li></ul><h2 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h2><p><img src="../../../../image/2021-03-23-tcp-handshake-goodbye/tcp_sequence.jpeg"></p><p>TCP 需要建立一条可靠的连接，那么对于一条可靠的连接来说，最起码的是发出去的请求能收到对方的确认。所以 Client 发送 <code>SYN</code> 并受到 <code>ACK</code> 后，才能确认连接建立，同样 Server 也需要发送 <code>SYN</code> 并受到 <code>ACK</code> 才能确认建立连接，这样最少需要三次请求，也就是 <strong>三次握手</strong></p><p>TCP 是全双工模式，也就是双方可以同时发送和接收消息。Client 发送 <code>FIN</code> 并收到 <code>ACK</code> 只是确认了 Client 没有更多数据需要传输，此时 Client 不能关闭连接，因为 Server 可能还会有数据传输过来。而当 Server 发送 <code>FIN</code> 并收到 <code>ACK</code> 后，双方都确认没有更多的消息需要传递，于是关闭连接。这样最少需要 <strong>四次挥手</strong></p><p>四次挥手之所以比三次握手多一次是因为：</p><ol><li>TCP 需要建立连接后才能传输数据，于是乎在建立连接的过程中肯定没有数据报文，可以把 <code>SYN</code> 和 <code>ACK</code> 合并为一个报文节省流量</li><li>而断开连接时，Server 回复 <code>ACK</code> 响应 Client 的 <code>FIN</code> 后，Server 依然可以继续发送报文，此时 Client 进入等待状态继续接收 Server 报文直到 Server 发送完毕并发送 <code>FIN</code>，<code>FIN</code> 和 <code>ACK</code> 并不能合并为一个报文</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tcp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解析 Tinker 是如何实现热修复的</title>
    <link href="/blog/2021/03/12/how-tinker-work/"/>
    <url>/blog/2021/03/12/how-tinker-work/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Tinker 是微信团队开源的一款 android 热修复框架，它的使用流程大体是：</p><ul><li>client 安装 V1.apk</li><li>提交了一些 hotfix，打包出 V2.apk</li><li>利用 Tinker 提供的差分工具，在 server 计算出补丁包 patch1.apk，并下发给 client</li><li>client 收到补丁包后，在后台给 V1.apk 打上 patch1.apk 得到 V2.apk（V1.apk + patch1.apk = V2.apk）</li><li>app 在下次启动时，将加载 V2.apk</li></ul><p>它的工作目录大概是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">- /data/user/0/tinker.sample.android/tinker<br>    - info.lock<br>    - patch.info<br>    - patch-d1ec6aa9<br>        - patch-d1ec6aa9.apk<br>        - dex<br>            - tinker_classN.apk<br>            - oat<br>                - tinker_classN.apk.cur.prof<br>                - x86<br>                    - tinker_classN.vdex<br>                    - tinker_classN.odex<br>        - res<br>            - resources.apk<br>        - lib<br>            - lib<br>                - armeabi<br>                    - libmmkv.so<br>                - ...<br>        - odex<br></code></pre></div></td></tr></table></figure><p>注入代码和资源的时序图如下</p><p><img src="../../../../image/2021-03-12-how-tinker-work/inject.jpg" alt="inject.jpg"></p><h2 id="代码的热更新"><a href="#代码的热更新" class="headerlink" title="代码的热更新"></a>代码的热更新</h2><h3 id="使用-TinkerClassLoader"><a href="#使用-TinkerClassLoader" class="headerlink" title="使用 TinkerClassLoader"></a>使用 <code>TinkerClassLoader</code></h3><p>Tinker 代码热更新的原理是用 <code>TinkerClassLoader</code> 替代原有的 <code>ClassLoader</code>，这样 V2 版本的类就会被优先加载，从而实现「覆盖」旧代码的功能</p><p><code>TinkerClassLoader</code> 打破了传统的双亲委派模式，其内部相当于有两个 <code>ClassLoader</code></p><ul><li><code>TinkerClassLoader</code>，包含 V2 版本的代码</li><li><code>mOriginAppClassLoader</code>，android app 的类加载器，包含 V1 版本的代码</li></ul><p>加载类的时候，首先从自身加载（也就是优先加载 V2 版本的代码），然后再从 app 的类加载器中加载（V1 版本的代码就会被 V2 所覆盖）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TinkerClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PathClassLoader</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader mOriginAppClassLoader;<br><br>    TinkerClassLoader(String dexPath, File optimizedDir, String libraryPath, ClassLoader originAppClassLoader) &#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-string">&quot;&quot;</span>, libraryPath, ClassLoader.getSystemClassLoader());<br>        mOriginAppClassLoader = originAppClassLoader;<br>        injectDexPath(<span class="hljs-keyword">this</span>, dexPath, optimizedDir);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        Class&lt;?&gt; cl = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            cl = <span class="hljs-keyword">super</span>.findClass(name);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ignored) &#123;<br>            cl = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cl != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> cl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> mOriginAppClassLoader.loadClass(name);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">injectDexPath</span><span class="hljs-params">(ClassLoader cl, String dexPath, File optimizedDir)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> List&lt;File&gt; dexFiles = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">16</span>);<br>            <span class="hljs-keyword">for</span> (String oneDexPath : dexPath.split(<span class="hljs-string">&quot;:&quot;</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (oneDexPath.isEmpty()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dexFiles.add(<span class="hljs-keyword">new</span> File(oneDexPath));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!dexFiles.isEmpty()) &#123;<br>                SystemClassLoaderAdder.injectDexesInternal(cl, dexFiles, optimizedDir);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable thr) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TinkerRuntimeException(<span class="hljs-string">&quot;Fail to create TinkerClassLoader.&quot;</span>, thr);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>创建 <code>TinkerClassLoader</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ClassLoader NewClassLoaderInjector.inject(Application app, ClassLoader oldClassLoader, <br> File dexOptDir, <span class="hljs-keyword">boolean</span> useDLC, List&lt;File&gt; patchedDexes) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">final</span> String[] patchedDexPaths = <span class="hljs-keyword">new</span> String[patchedDexes.size()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; patchedDexPaths.length; ++i) &#123;<br>        patchedDexPaths[i] = patchedDexes.get(i).getAbsolutePath();<br>    &#125;<br>    <span class="hljs-keyword">final</span> ClassLoader newClassLoader = createNewClassLoader(oldClassLoader, dexOptDir, useDLC, patchedDexPaths);<br>    doInject(app, newClassLoader);<br>    <span class="hljs-keyword">return</span> newClassLoader;<br>&#125;<br><br>ClassLoader NewClassLoaderInjector.createNewClassLoader(ClassLoader oldClassLoader, File dexOptDir, <br><span class="hljs-keyword">boolean</span> useDLC, String... patchDexPaths) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">final</span> Field pathListField = findField(Class.forName(<span class="hljs-string">&quot;dalvik.system.BaseDexClassLoader&quot;</span>, <span class="hljs-keyword">false</span>, oldClassLoader), <span class="hljs-string">&quot;pathList&quot;</span>);<br>    <span class="hljs-keyword">final</span> Object oldPathList = pathListField.get(oldClassLoader);<br><br>    <span class="hljs-comment">// V2 版本的 dex 列表（apk 包），组合为字符串</span><br>    <span class="hljs-keyword">final</span> StringBuilder dexPathBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> hasPatchDexPaths = patchDexPaths != <span class="hljs-keyword">null</span> &amp;&amp; patchDexPaths.length &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (hasPatchDexPaths) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; patchDexPaths.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                dexPathBuilder.append(File.pathSeparator);<br>            &#125;<br>            dexPathBuilder.append(patchDexPaths[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">final</span> String combinedDexPath = dexPathBuilder.toString();<br><br>    <span class="hljs-comment">// 把 V1 版本的 so 文件目录组合为字符串</span><br>    <span class="hljs-comment">// so 文件目录其实一直是固定的，比如上面提到的 /data/app/tinker.sample.android-WQAlCXU0G15OGs7jKsCrcw==/lib/x86</span><br>    <span class="hljs-comment">// 这是因为 V2 版本的 so 文件被释放到这个目录，把 V1 版本的文件给覆盖掉了（在合成新版本的章节会介绍）</span><br>    <span class="hljs-keyword">final</span> Field nativeLibraryDirectoriesField = findField(oldPathList.getClass(), <span class="hljs-string">&quot;nativeLibraryDirectories&quot;</span>);<br>    List&lt;File&gt; oldNativeLibraryDirectories = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (nativeLibraryDirectoriesField.getType().isArray()) &#123;<br>        oldNativeLibraryDirectories = Arrays.asList((File[]) nativeLibraryDirectoriesField.get(oldPathList));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        oldNativeLibraryDirectories = (List&lt;File&gt;) nativeLibraryDirectoriesField.get(oldPathList);<br>    &#125;<br>    <span class="hljs-keyword">final</span> StringBuilder libraryPathBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">boolean</span> isFirstItem = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (File libDir : oldNativeLibraryDirectories) &#123;<br>        <span class="hljs-keyword">if</span> (libDir == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isFirstItem) &#123;<br>            isFirstItem = <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            libraryPathBuilder.append(File.pathSeparator);<br>        &#125;<br>        libraryPathBuilder.append(libDir.getAbsolutePath());<br>    &#125;<br>    <span class="hljs-keyword">final</span> String combinedLibraryPath = libraryPathBuilder.toString();<br><br>    <span class="hljs-comment">// 构造 TinkerClassLoader</span><br>    ClassLoader result = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (useDLC &amp;&amp; Build.VERSION.SDK_INT &gt;= <span class="hljs-number">27</span>) &#123;<br>        result = <span class="hljs-keyword">new</span> DelegateLastClassLoader(combinedDexPath, combinedLibraryPath, ClassLoader.getSystemClassLoader());<br>        <span class="hljs-keyword">final</span> Field parentField = ClassLoader.class.getDeclaredField(<span class="hljs-string">&quot;parent&quot;</span>);<br>        parentField.setAccessible(<span class="hljs-keyword">true</span>);<br>        parentField.set(result, oldClassLoader);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        result = <span class="hljs-keyword">new</span> TinkerClassLoader(combinedDexPath, dexOptDir, combinedLibraryPath, oldClassLoader);<br>    &#125;<br>    <span class="hljs-comment">// &#x27;EnsureSameClassLoader&#x27; mechanism which is first introduced in Android O</span><br>    <span class="hljs-comment">// may cause exception if we replace definingContext of old classloader.</span><br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">26</span>) &#123;<br>        findField(oldPathList.getClass(), <span class="hljs-string">&quot;definingContext&quot;</span>).set(oldPathList, result);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="替代-PathClassLoader"><a href="#替代-PathClassLoader" class="headerlink" title="替代 PathClassLoader"></a>替代 <code>PathClassLoader</code></h3><p><code>PathClassLoader</code> 结构如下，因为没有公开方法设置 <code>optimizeDir</code>（odex 文件目录，后续会讲到 Tinker 触发 dex 优化时把文件输出目录设置在 patch dir 内），需要通过反射重新构造 <code>dexElements</code></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">- dalvik.system.PathClassLoader（继承自 BaseDexClassLoader）<br>    - pathList: DexPathList<br>        - nativeLibraryDirectories: File[]<br>            - 0<br>                - /data/app/tinker.sample.android-WQAlCXU0G15OGs7jKsCrcw==/lib/x86<br>        - dexElements: Element[]<br>            - 0<br>                - path: File = /data/app/tinker.sample.android-WQAlCXU0G15OGs7jKsCrcw==/base.apk<br>                - dexFile: DexFile = /data/app/tinker.sample.android-WQAlCXU0G15OGs7jKsCrcw==/base.apk<br>                - initialized: Boolean = false<br>                - urlHandler: ClassPathURLStreamHandler = null<br></code></pre></div></td></tr></table></figure><p>不同 android 版本里 app class loader 的实现和结构可能是不同的，需要分开处理；Tinker 整理出了 V23、V19、V14 和 V4 四个版本</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> SystemClassLoaderAdder.injectDexesInternal(ClassLoader cl, List&lt;File&gt; dexFiles, File optimizeDir) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">23</span>) &#123;<br>        V23.install(cl, dexFiles, optimizeDir);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">19</span>) &#123;<br>        V19.install(cl, dexFiles, optimizeDir);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">14</span>) &#123;<br>        V14.install(cl, dexFiles, optimizeDir);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        V4.install(cl, dexFiles, optimizeDir);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">V23</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">install</span><span class="hljs-params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries, File optimizedDirectory)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span><br><span class="hljs-function">        NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException </span>&#123;<br>        <span class="hljs-comment">/* The patched class loader is expected to be a descendant of</span><br><span class="hljs-comment">         * dalvik.system.BaseDexClassLoader. We modify its</span><br><span class="hljs-comment">         * dalvik.system.DexPathList pathList field to append additional DEX</span><br><span class="hljs-comment">         * file entries.</span><br><span class="hljs-comment">         */</span><br>        Field pathListField = ShareReflectUtil.findField(loader, <span class="hljs-string">&quot;pathList&quot;</span>);<br>        Object dexPathList = pathListField.get(loader);<br>        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="hljs-keyword">new</span> ArrayList&lt;IOException&gt;();<br>        ShareReflectUtil.expandFieldArray(dexPathList, <span class="hljs-string">&quot;dexElements&quot;</span>, makePathElements(dexPathList,<br>            <span class="hljs-keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,<br>            suppressedExceptions));<br>        <span class="hljs-keyword">if</span> (suppressedExceptions.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (IOException e : suppressedExceptions) &#123;<br>                ShareTinkerLog.w(TAG, <span class="hljs-string">&quot;Exception in makePathElement&quot;</span>, e);<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A wrapper around</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> private static final dalvik.system.DexPathList#makePathElements&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object[] makePathElements(<br>        Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory,<br>        ArrayList&lt;IOException&gt; suppressedExceptions)<br>        <span class="hljs-keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;<br>        Method makePathElements;<br>        <span class="hljs-keyword">try</span> &#123;<br>            makePathElements = ShareReflectUtil.findMethod(dexPathList, <span class="hljs-string">&quot;makePathElements&quot;</span>, List.class, File.class, List.class);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            ShareTinkerLog.e(TAG, <span class="hljs-string">&quot;NoSuchMethodException: makePathElements(List,File,List) failure&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                makePathElements = ShareReflectUtil.findMethod(dexPathList, <span class="hljs-string">&quot;makePathElements&quot;</span>, ArrayList.class, File.class, ArrayList.class);<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e1) &#123;<br>                ShareTinkerLog.e(TAG, <span class="hljs-string">&quot;NoSuchMethodException: makeDexElements(ArrayList,File,ArrayList) failure&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    ShareTinkerLog.e(TAG, <span class="hljs-string">&quot;NoSuchMethodException: try use v19 instead&quot;</span>);<br>                    <span class="hljs-keyword">return</span> V19.makeDexElements(dexPathList, files, optimizedDirectory, suppressedExceptions);<br>                &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e2) &#123;<br>                    ShareTinkerLog.e(TAG, <span class="hljs-string">&quot;NoSuchMethodException: makeDexElements(List,File,List) failure&quot;</span>);<br>                    <span class="hljs-keyword">throw</span> e2;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (Object[]) makePathElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="注入-TinkerClassLoader"><a href="#注入-TinkerClassLoader" class="headerlink" title="注入 TinkerClassLoader"></a>注入 <code>TinkerClassLoader</code></h3><p>注入 <code>TinkerClassLoader</code>，有这么几个地方：</p><ul><li><code>Thread.getContextClassLoader()</code></li><li><code>Application.mBase(ContextImpl).mClassLoader</code></li><li><code>Application.mBase(ContextImpl).mPackageInfo(LoadedApk).mClassLoader</code></li><li><code>Resources.mClassLoader</code></li><li><code>Resources.mDrawableInflater(DrawableInflater).mClassLoader</code></li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> NewClassLoaderInjector.doInject(Application app, ClassLoader classLoader) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    Thread.currentThread().setContextClassLoader(classLoader);<br>    <span class="hljs-keyword">final</span> Context baseContext = (Context) findField(app.getClass(), <span class="hljs-string">&quot;mBase&quot;</span>).get(app);<br>    <span class="hljs-keyword">try</span> &#123;<br>        findField(baseContext.getClass(), <span class="hljs-string">&quot;mClassLoader&quot;</span>).set(baseContext, classLoader);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;<br>        <span class="hljs-comment">// There&#x27;s no mClassLoader field in ContextImpl before Android O.</span><br>        <span class="hljs-comment">// However we should try our best to replace this field in case some</span><br>        <span class="hljs-comment">// customized system has one.</span><br>    &#125;<br>    <span class="hljs-keyword">final</span> Object basePackageInfo = findField(baseContext.getClass(), <span class="hljs-string">&quot;mPackageInfo&quot;</span>).get(baseContext);<br>    findField(basePackageInfo.getClass(), <span class="hljs-string">&quot;mClassLoader&quot;</span>).set(basePackageInfo, classLoader);<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">27</span>) &#123;<br>        <span class="hljs-keyword">final</span> Resources res = app.getResources();<br>        <span class="hljs-keyword">try</span> &#123;<br>            findField(res.getClass(), <span class="hljs-string">&quot;mClassLoader&quot;</span>).set(res, classLoader);<br>            <span class="hljs-keyword">final</span> Object drawableInflater = findField(res.getClass(), <span class="hljs-string">&quot;mDrawableInflater&quot;</span>).get(res);<br>            <span class="hljs-keyword">if</span> (drawableInflater != <span class="hljs-keyword">null</span>) &#123;<br>                findField(drawableInflater.getClass(), <span class="hljs-string">&quot;mClassLoader&quot;</span>).set(drawableInflater, classLoader);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;<br>            <span class="hljs-comment">// Ignored.</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面列出的几个 <code>ClassLoader</code>，其中有两个是比较重要的</p><p><code>Application.mBase(ContextImpl).mClassLoader</code> 是在实例化 <code>ApplicationLike</code> 时用到；为了能够加载到 V2 版本的代码，app application 必须设置为 <code>TinkerApplication</code>（它是 Tinker 库的类，只要不更新 Tinker 版本，业务的迭代更新一般不会改动到它，所以它是比较稳定不变的）；在注入 <code>TinkerClassLoader</code> 后，通过反射调用业务方的 <code>ApplicationLike</code>（业务代码较常变动）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> TinkerApplication.attachBaseContext(Context base)<br><br><span class="hljs-keyword">void</span> TinkerApplication.onBaseContextAttached(Context base, <span class="hljs-keyword">long</span> applicationStartElapsedTime, <span class="hljs-keyword">long</span> applicationStartMillisTime) &#123;<br>    loadTinker();  <span class="hljs-comment">// 先注入 TinkerClassLoader</span><br>    mCurrentClassLoader = base.getClassLoader();  <span class="hljs-comment">// Application.mBase(ContextImpl).mClassLoader</span><br>    mInlineFence = createInlineFence(<span class="hljs-keyword">this</span>, tinkerFlags, delegateClassName, tinkerLoadVerifyFlag, <br>        applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);<br>&#125;<br><br>Handler TinkerApplication.createInlineFence(Application app, <span class="hljs-keyword">int</span> tinkerFlags, String delegateClassName, <span class="hljs-keyword">boolean</span> tinkerLoadVerifyFlag, <br>    <span class="hljs-keyword">long</span> applicationStartElapsedTime, <span class="hljs-keyword">long</span> applicationStartMillisTime, Intent resultIntent) &#123;<br>    <span class="hljs-comment">// delegateClassName 比如 tinker.sample.android.app.SampleApplicationLike</span><br>    <span class="hljs-comment">// 此时 mCurrentClassLoader 是 TinkerClassLoader</span><br>    <span class="hljs-keyword">final</span> Class&lt;?&gt; delegateClass = Class.forName(delegateClassName, <span class="hljs-keyword">false</span>, mCurrentClassLoader);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Application.mBase(ContextImpl).mPackageInfo(LoadedApk).mClassLoader</code> 在实例化 <code>Activity</code> 时会用到，在<a href="../../../../2020/11/03/launch-activity-sequence/">这篇文章</a>里可以找到入口点：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ActivityThread.handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent)=<br><br>ActivityThread.performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;<br>    <span class="hljs-comment">// ...</span><br>    ContextImpl appContext = createBaseContextForActivity(r);<br>    Activity activity = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 用这个 cl 加载目标 Activity 类；而这个 cl 是上面 ContextImpl 的</span><br>        java.lang.ClassLoader cl = appContext.getClassLoader();<br>        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);<br>        <span class="hljs-comment">// ...</span><br>&#125;<br><br>Instrumentation.newActivity(ClassLoader cl, String className, Intent intent) <br>    <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;<br>    String pkg = intent != <span class="hljs-keyword">null</span> &amp;&amp; intent.getComponent() != <span class="hljs-keyword">null</span> ? intent.getComponent().getPackageName() : <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> getFactory(pkg).instantiateActivity(cl, className, intent);<br>&#125;<br><br>AppComponentFactory.instantiateActivity(ClassLoader cl, String className, Intent intent)<br>    <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;<br>    <span class="hljs-keyword">return</span> (Activity) cl.loadClass(className).newInstance();<br>&#125;<br><br>ActivityThread.createBaseContextForActivity(ActivityClientRecord r) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> displayId;<br>    <span class="hljs-keyword">try</span> &#123;<br>        displayId = ActivityTaskManager.getService().getDisplayId(r.token);<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>        <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();<br>    &#125;<br>    ContextImpl appContext = ContextImpl.createActivityContext(<span class="hljs-keyword">this</span>, r.packageInfo, r.activityInfo, r.token, displayId, r.overrideConfig);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>ContextImpl.createActivityContext(ActivityThread mainThread, LoadedApk packageInfo, ActivityInfo activityInfo, <br>    IBinder activityToken, <span class="hljs-keyword">int</span> displayId, Configuration overrideConfiguration) &#123;<br>    <span class="hljs-keyword">if</span> (packageInfo == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;packageInfo&quot;</span>);<br>    String[] splitDirs = packageInfo.getSplitResDirs();<br>    ClassLoader classLoader = packageInfo.getClassLoader();  <span class="hljs-comment">// ContextImpl.getClassLoader() 来自于 LoadedApk.mClassLoader</span><br>    <span class="hljs-comment">// ...</span><br>    ContextImpl context = <span class="hljs-keyword">new</span> ContextImpl(<span class="hljs-keyword">null</span>, mainThread, packageInfo, <span class="hljs-keyword">null</span>, activityInfo.splitName, activityToken, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, classLoader, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="资源的热更新"><a href="#资源的热更新" class="headerlink" title="资源的热更新"></a>资源的热更新</h2><h3 id="app-resources"><a href="#app-resources" class="headerlink" title="app resources"></a>app resources</h3><p>对于资源的热更新 Tinker 做了两块</p><p>一块是针对 app context 的，Tinker 用新的资源包（比如上面说到的 <code>/data/user/0/tinker.sample.android/tinker/patch-d1ec6aa9/res/resources.apk</code>）构造出一个新的 <code>AssetManager</code>，替换掉 <code>Resources</code> 里旧的 <code>Resource.mResourcesImpl(ResourcesImpl).mAssets</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">TinkerResourceLoader.loadTinkerResources(TinkerApplication application, String directory, Intent intentResult)<br><br><span class="hljs-comment">// 资源热更新的逻辑在这里</span><br>TinkerResourcePatcher.monkeyPatchExistingResources(Context context, String externalResourceFile) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// ... 创建一个新的 AssetManager，它指向新的资源包</span><br>    <span class="hljs-keyword">if</span> (((Integer) addAssetPathMethod.invoke(newAssetManager, externalResourceFile)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Could not create new AssetManager&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">for</span> (WeakReference&lt;Resources&gt; wr : references) &#123;<br>        <span class="hljs-keyword">final</span> Resources resources = wr.get();<br>        <span class="hljs-keyword">if</span> (resources == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 替换 Resources 里的 AssetManager</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//pre-N</span><br>            assetsFiled.set(resources, newAssetManager);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;<br>            <span class="hljs-comment">// N</span><br>            <span class="hljs-keyword">final</span> Object resourceImpl = resourcesImplFiled.get(resources);<br>            <span class="hljs-comment">// for Huawei HwResourcesImpl</span><br>            <span class="hljs-keyword">final</span> Field implAssets = findField(resourceImpl, <span class="hljs-string">&quot;mAssets&quot;</span>);<br>            implAssets.set(resourceImpl, newAssetManager);<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>app context 里的 <code>Resources</code> 是在构造 app context 的同时通过 <code>ResourcesManager.getResources</code> 创建的，而且 <code>ResourcesManager.mResourceReferences</code> 会持有一个它的弱引用</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ActivityThread.handleBindApplication(AppBindData data) &#123;<br>    <span class="hljs-comment">// ... 实例化 ContextImpl 和 Application</span><br>    app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 构造 app context（ContextImpl）和 Application</span><br>Application LoadedApk.makeApplication(<span class="hljs-keyword">boolean</span> forceDefaultAppClass, Instrumentation instrumentation) &#123;<br>    <span class="hljs-comment">// ...</span><br>    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="hljs-keyword">this</span>);<br>    app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 在构造 ContextImpl 时候会创建 Resources</span><br>ContextImpl LoadedApk.createAppContext(ActivityThread mainThread, LoadedApk packageInfo) &#123;<br>    <span class="hljs-keyword">return</span> createAppContext(mainThread, packageInfo, <span class="hljs-keyword">null</span>);<br>&#125;<br>ContextImpl LoadedApk.createAppContext(ActivityThread mainThread, LoadedApk packageInfo, String opPackageName) &#123;<br>    <span class="hljs-keyword">if</span> (packageInfo == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;packageInfo&quot;</span>);<br>    ContextImpl context = <span class="hljs-keyword">new</span> ContextImpl(<span class="hljs-keyword">null</span>, mainThread, packageInfo, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, opPackageName);<br>    context.setResources(packageInfo.getResources());<br>    context.mIsSystemOrSystemUiContext = isSystemOrSystemUI(context);<br>    <span class="hljs-keyword">return</span> context;<br>&#125;<br><br><span class="hljs-comment">// 通过 ResourcesManager.getResources() 创建 Resources 实例时，ResourcesManager.mResourceReferences 会持有一个它的弱引用</span><br>Resources LoadedApk.getResources() &#123;<br>    <span class="hljs-keyword">if</span> (mResources == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">final</span> String[] splitPaths;<br>        <span class="hljs-keyword">try</span> &#123;<br>            splitPaths = getSplitPaths(<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NameNotFoundException e) &#123;<br>            <span class="hljs-comment">// This should never fail.</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">&quot;null split not found&quot;</span>);<br>        &#125;<br>        mResources = ResourcesManager.getInstance().getResources(<span class="hljs-keyword">null</span>, mResDir,<br>                splitPaths, mOverlayDirs, mApplicationInfo.sharedLibraryFiles,<br>                Display.DEFAULT_DISPLAY, <span class="hljs-keyword">null</span>, getCompatibilityInfo(),<br>                getClassLoader(), <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> mResources;<br>&#125;<br>ResourcesManager.getResources(...) &#123;<br>    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, <span class="hljs-string">&quot;ResourcesManager#getResources&quot;</span>);<br>    <span class="hljs-keyword">final</span> ResourcesKey key = <span class="hljs-keyword">new</span> ResourcesKey(...);<br>    classLoader = classLoader != <span class="hljs-keyword">null</span> ? classLoader : ClassLoader.getSystemClassLoader();<br>    <span class="hljs-keyword">if</span> (activityToken != <span class="hljs-keyword">null</span>) &#123;<br>        rebaseKeyForActivity(activityToken, key);<br>    &#125;<br>    <span class="hljs-comment">// Preload the ApkAssets required by the key to prevent performing heavy I/O while the</span><br>    <span class="hljs-comment">// ResourcesManager lock is held.</span><br>    <span class="hljs-keyword">final</span> ApkAssetsSupplier assetsSupplier = createApkAssetsSupplierNotLocked(key);<br>    <span class="hljs-keyword">return</span> createResources(activityToken, key, classLoader, assetsSupplier);    <br>&#125;<br>ResourcesManager.createResources(...) &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        ResourcesImpl resourcesImpl = findOrCreateResourcesImplForKeyLocked(key, apkSupplier);<br>        <span class="hljs-keyword">if</span> (resourcesImpl == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (activityToken != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> createResourcesForActivityLocked(activityToken, classLoader, resourcesImpl, key.mCompatInfo);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> createResourcesLocked(classLoader, resourcesImpl, key.mCompatInfo);<br>        &#125;<br>    &#125;<br>&#125;<br>ResourcesManager.createResourcesLocked(...) &#123;<br>    cleanupReferences(mResourceReferences, mResourcesReferencesQueue);<br>    Resources resources = compatInfo.needsCompatResources() ? <span class="hljs-keyword">new</span> CompatResources(classLoader) : <span class="hljs-keyword">new</span> Resources(classLoader);<br>    resources.setImpl(impl);<br>    resources.setCallbacks(mUpdateCallbacks);<br>    mResourceReferences.add(<span class="hljs-keyword">new</span> WeakReference&lt;&gt;(resources, mResourcesReferencesQueue));<br>    <span class="hljs-keyword">return</span> resources;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Application</code> 创建后会调用 <code>Application.attach</code>，后续会触发 <code>TinkerResourcePatcher.isResourceCanPatch</code> 和 <code>TinkerResourcePatcher.monkeyPatchExistingResources</code>，从而把 <code>ResourcesManager.mResourceReferences</code> 里的 <code>Resources</code> 都修改掉</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Instrumentation.newApplication(ClassLoader cl, String className, Context context) <br><span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;<br>    Application app = getFactory(context.getPackageName()).instantiateApplication(cl, className);<br>    app.attach(context);<br>    <span class="hljs-keyword">return</span> app;<br>&#125;<br><br>Application.attach(Context context) &#123;<br>    attachBaseContext(context);<br>    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;<br>&#125;<br><br>TinkerLoader.tryLoadPatchFilesInternal(TinkerApplication app, Intent resultIntent)<br><br>TinkerResourceLoader.checkComplete(Context context, String directory, ShareSecurityCheck securityCheck, Intent intentResult)<br><br><span class="hljs-comment">// 通过反射拿到 ResourcesManager.mResourceReferences</span><br>TinkerResourceLoader.isResourceCanPatch(Context context) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// Iterate over all known Resources objects</span><br>    <span class="hljs-keyword">if</span> (SDK_INT &gt;= KITKAT) &#123;<br>        <span class="hljs-comment">//pre-N</span><br>        <span class="hljs-comment">// Find the singleton instance of ResourcesManager</span><br>        <span class="hljs-keyword">final</span> Class&lt;?&gt; resourcesManagerClass = Class.forName(<span class="hljs-string">&quot;android.app.ResourcesManager&quot;</span>);<br>        <span class="hljs-keyword">final</span> Method mGetInstance = findMethod(resourcesManagerClass, <span class="hljs-string">&quot;getInstance&quot;</span>);<br>        <span class="hljs-keyword">final</span> Object resourcesManager = mGetInstance.invoke(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Field fMActiveResources = findField(resourcesManagerClass, <span class="hljs-string">&quot;mActiveResources&quot;</span>);<br>            <span class="hljs-keyword">final</span> ArrayMap&lt;?, WeakReference&lt;Resources&gt;&gt; activeResources19 =<br>                    (ArrayMap&lt;?, WeakReference&lt;Resources&gt;&gt;) fMActiveResources.get(resourcesManager);<br>            references = activeResources19.values();<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException ignore) &#123;<br>            <span class="hljs-comment">// N moved the resources to mResourceReferences</span><br>            <span class="hljs-keyword">final</span> Field mResourceReferences = findField(resourcesManagerClass, <span class="hljs-string">&quot;mResourceReferences&quot;</span>);<br>            references = (Collection&lt;WeakReference&lt;Resources&gt;&gt;) mResourceReferences.get(resourcesManager);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">final</span> Field fMActiveResources = findField(activityThread, <span class="hljs-string">&quot;mActiveResources&quot;</span>);<br>        <span class="hljs-keyword">final</span> HashMap&lt;?, WeakReference&lt;Resources&gt;&gt; activeResources7 =<br>                (HashMap&lt;?, WeakReference&lt;Resources&gt;&gt;) fMActiveResources.get(currentActivityThread);<br>        references = activeResources7.values();<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="local-resources"><a href="#local-resources" class="headerlink" title="local resources"></a>local resources</h3><p>另一块是针对局部 <code>Context</code> 的，比如 <code>Activity</code>，从<a href="../../../../2020/11/03/launch-activity-sequence/">Activity 启动流程时序图</a>可以找到创建 <code>Activity</code> 的入口点</p><p>创建 <code>Activity</code> 的时候会创建并使用它自己的 <code>Context</code>，而且把 <code>Context.getResources</code> 指向从 <code>ActivityThread.mPackages</code> 里找到的资源目录，所以 Tinker 会在 <code>monkeyPatchExistingResources</code> 修改 <code>ActivityThread.mPackages</code> 指向新资源包</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建 Activity</span><br>ActivityThread.handleLaunchActivity ...<br><br>ActivityThread.performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;<br>        ActivityInfo aInfo = r.activityInfo;<br>    <span class="hljs-keyword">if</span> (r.packageInfo == <span class="hljs-keyword">null</span>) &#123;<br>        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    ContextImpl appContext = createBaseContextForActivity(r);<br>    <span class="hljs-comment">// ...</span><br>    activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);<br>    <span class="hljs-comment">// ...</span><br>    activity.attach(appContext, <span class="hljs-keyword">this</span>, getInstrumentation(), r.token,<br>            r.ident, app, r.intent, r.activityInfo, title, r.parent,<br>            r.embeddedID, r.lastNonConfigurationInstances, config,<br>            r.referrer, r.voiceInteractor, window, r.configCallback,<br>            r.assistToken);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 创建 Activity ContextImpl，可以看到它的 Resources 是指向 ActivityClientRecord.packageInfo.getResDir() 的</span><br><span class="hljs-comment">// 而 ActivityClientRecord.packageInfo 在上面被赋值了</span><br>ContextImpl.createBaseContextForActivity(ActivityClientRecord r) <br>ContextImpl.createActivityContext(ActivityThread mainThread,<br>        LoadedApk packageInfo, ActivityInfo activityInfo, IBinder activityToken, <span class="hljs-keyword">int</span> displayId,<br>        Configuration overrideConfiguration) &#123;<br>    <span class="hljs-comment">// ...</span><br>    ContextImpl context = <span class="hljs-keyword">new</span> ContextImpl(<span class="hljs-keyword">null</span>, mainThread, packageInfo, <span class="hljs-keyword">null</span>,<br>            activityInfo.splitName, activityToken, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, classLoader, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// ...</span><br>    context.setResources(resourcesManager.createBaseTokenResources(activityToken,<br>            packageInfo.getResDir(),<br>            splitDirs,<br>            packageInfo.getOverlayDirs(),<br>            packageInfo.getApplicationInfo().sharedLibraryFiles,<br>            displayId,<br>            overrideConfiguration,<br>            compatInfo,<br>            classLoader,<br>            packageInfo.getApplication() == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : packageInfo.getApplication().getResources().getLoaders()));<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// ActivityClientRecord.packageInfo 是从 ActivityThread.mPackages 里取的</span><br>ActivityThread.getPackageInfo(String packageName, CompatibilityInfo compatInfo, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> userId) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> differentUser = (UserHandle.myUserId() != userId);<br>    ApplicationInfo ai = PackageManager.getApplicationInfoAsUserCached(<br>            packageName,<br>            PackageManager.GET_SHARED_LIBRARY_FILES<br>            | PackageManager.MATCH_DEBUG_TRIAGED_MISSING,<br>            (userId &lt; <span class="hljs-number">0</span>) ? UserHandle.myUserId() : userId);<br>    <span class="hljs-keyword">synchronized</span> (mResourcesManager) &#123;<br>        WeakReference&lt;LoadedApk&gt; ref;<br>        <span class="hljs-keyword">if</span> (differentUser) &#123;<br>            <span class="hljs-comment">// Caching not supported across users</span><br>            ref = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((flags &amp; Context.CONTEXT_INCLUDE_CODE) != <span class="hljs-number">0</span>) &#123;<br>            ref = mPackages.get(packageName);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ref = mResourcePackages.get(packageName);<br>        &#125;<br>        LoadedApk packageInfo = ref != <span class="hljs-keyword">null</span> ? ref.get() : <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (ai != <span class="hljs-keyword">null</span> &amp;&amp; packageInfo != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!isLoadedApkResourceDirsUpToDate(packageInfo, ai)) &#123;<br>                List&lt;String&gt; oldPaths = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                LoadedApk.makePaths(<span class="hljs-keyword">this</span>, ai, oldPaths);<br>                packageInfo.updateApplicationInfo(ai, oldPaths);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (packageInfo.isSecurityViolation() &amp;&amp; (flags&amp;Context.CONTEXT_IGNORE_SECURITY) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(<br>                        <span class="hljs-string">&quot;Requesting code from &quot;</span> + packageName<br>                        + <span class="hljs-string">&quot; to be run in process &quot;</span><br>                        + mBoundApplication.processName<br>                        + <span class="hljs-string">&quot;/&quot;</span> + mBoundApplication.appInfo.uid);<br>            &#125;<br>            <span class="hljs-keyword">return</span> packageInfo;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ai != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> getPackageInfo(ai, compatInfo, flags);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-comment">// Tinker 将 ActivityThread.mPackages 里的 LoadedApk.mResDir 改为新的资源包</span><br>TinkerResourcePatcher.isResourceCanPatch(Context context) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    Class&lt;?&gt; activityThread = Class.forName(<span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>);<br>    <span class="hljs-comment">// ...</span><br>    packagesFiled = findField(activityThread, <span class="hljs-string">&quot;mPackages&quot;</span>);<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">27</span>) &#123;<br>        resourcePackagesFiled = findField(activityThread, <span class="hljs-string">&quot;mResourcePackages&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br>TinkerResourcePatcher.monkeyPatchExistingResources(Context context, String externalResourceFile) <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">if</span> (externalResourceFile == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> ApplicationInfo appInfo = context.getApplicationInfo();<br>    <span class="hljs-keyword">final</span> Field[] packagesFields;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">27</span>) &#123;<br>        packagesFields = <span class="hljs-keyword">new</span> Field[]&#123;packagesFiled, resourcePackagesFiled&#125;;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        packagesFields = <span class="hljs-keyword">new</span> Field[]&#123;packagesFiled&#125;;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Field field : packagesFields) &#123;<br>        <span class="hljs-keyword">final</span> Object value = field.get(currentActivityThread);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, WeakReference&lt;?&gt;&gt; entry : ((Map&lt;String, WeakReference&lt;?&gt;&gt;) value).entrySet()) &#123;<br>            <span class="hljs-keyword">final</span> Object loadedApk = entry.getValue().get();<br>            <span class="hljs-keyword">if</span> (loadedApk == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">final</span> String resDirPath = (String) resDir.get(loadedApk);<br>            <span class="hljs-keyword">if</span> (appInfo.sourceDir.equals(resDirPath)) &#123;<br>                resDir.set(loadedApk, externalResourceFile);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Library</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hotfix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Application 是如何被创建和初始化的？</title>
    <link href="/blog/2021/03/02/how-application-being-created-and-init/"/>
    <url>/blog/2021/03/02/how-application-being-created-and-init/</url>
    
    <content type="html"><![CDATA[<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>从 <code>startActivity</code> 开始，比如打开一个 app 的首页，当 app 未启动时就会走创建 <code>Application</code> 这条路</p><p><img src="../../../../image/2021-03-02-how-application-being-created-and-init/from_startActivity_to_zygote.png" alt="from_startActivity_to_zygote.png"></p><h2 id="AMS-承担的工作"><a href="#AMS-承担的工作" class="headerlink" title="AMS 承担的工作"></a>AMS 承担的工作</h2><p>其中的转折点在 <code>resumeTopActivityInnerLocked</code>，发现 app process 不存在，走启动 app process 的流程</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> ActivityStack.resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;<br>    <span class="hljs-comment">// ... Launching this app&#x27;s activity, make sure the app is no longer considered stopped. 下面是启动 Activity 的逻辑</span><br>    <span class="hljs-keyword">if</span> (next.attachedToProcess()) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 此时 app process 还没有起来，走下面一段逻辑</span><br>        <span class="hljs-comment">// Whoops, need to restart this activity!</span><br>        <span class="hljs-keyword">if</span> (!next.hasBeenLaunched) &#123;<br>            next.hasBeenLaunched = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (SHOW_APP_STARTING_PREVIEW) &#123;<br>                next.showStartingWindow(<span class="hljs-keyword">null</span> <span class="hljs-comment">/* prev */</span>, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* newTask */</span>, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* taskSwich */</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="hljs-string">&quot;Restarting: &quot;</span> + next);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="hljs-string">&quot;resumeTopActivityLocked: Restarting &quot;</span> + next);<br>        mStackSupervisor.startSpecificActivity(next, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后走到 <code>attemptZygoteSendArgsAndGetResult</code>，AMS 将 app 的相关参数通过 socket 发送给 zygote 进程，由 zygote 负责 fork 出一个 app process，这一段路程就算完结了</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Process.<span class="hljs-function">ProcessStartResult <span class="hljs-title">attemptZygoteSendArgsAndGetResult</span><span class="hljs-params">(ZygoteState zygoteState, String msgStr)</span> <span class="hljs-keyword">throws</span> ZygoteStartFailedEx </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;<br>        <span class="hljs-keyword">final</span> DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;<br>        zygoteWriter.write(msgStr);<br>        zygoteWriter.flush();<br>        Process.ProcessStartResult result = <span class="hljs-keyword">new</span> Process.ProcessStartResult();<br>        result.pid = zygoteInputStream.readInt();<br>        result.usingWrapper = zygoteInputStream.readBoolean();<br>        <span class="hljs-keyword">if</span> (result.pid &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ZygoteStartFailedEx(<span class="hljs-string">&quot;fork() failed&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        zygoteState.close();<br>        Log.e(LOG_TAG, <span class="hljs-string">&quot;IO Exception while communicating with Zygote - &quot;</span> + ex.toString());<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ZygoteStartFailedEx(ex);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>值得注意的是，AMS 是通过 <code>LocalSocket</code> 与 zygote 交互的，它们建立连接的过程如下：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Process.ProcessStartResult ZygoteProcess.startViaZygote(...) &#123;<br>    ArrayList&lt;String&gt; argsForZygote = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    argsForZygote.add(<span class="hljs-string">&quot;--runtime-args&quot;</span>);<br>    <span class="hljs-comment">// 拼接字符串参数 ...</span><br>    <span class="hljs-keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), zygotePolicyFlags, argsForZygote);<br>&#125;<br><br><span class="hljs-keyword">private</span> ZygoteState ZygoteProcess.openZygoteSocketIfNeeded(String abi) <span class="hljs-keyword">throws</span> ZygoteStartFailedEx &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        attemptConnectionToPrimaryZygote();<br>        <span class="hljs-keyword">if</span> (primaryZygoteState.matches(abi)) &#123;<br>            <span class="hljs-keyword">return</span> primaryZygoteState;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mZygoteSecondarySocketAddress != <span class="hljs-keyword">null</span>) &#123;<br>            attemptConnectionToSecondaryZygote();<br>            <span class="hljs-keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;<br>                <span class="hljs-keyword">return</span> secondaryZygoteState;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ZygoteStartFailedEx(<span class="hljs-string">&quot;Error connecting to zygote&quot;</span>, ioe);<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ZygoteStartFailedEx(<span class="hljs-string">&quot;Unsupported zygote ABI: &quot;</span> + abi);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ZygoteProcess.attemptConnectionToPrimaryZygote() <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">if</span> (primaryZygoteState == <span class="hljs-keyword">null</span> || primaryZygoteState.isClosed()) &#123;<br>        primaryZygoteState = ZygoteState.connect(mZygoteSocketAddress, mUsapPoolSocketAddress);<br>        maybeSetApiDenylistExemptions(primaryZygoteState, <span class="hljs-keyword">false</span>);<br>        maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> ZygoteState ZygoteState.connect(LocalSocketAddress zygoteSocketAddress, LocalSocketAddress usapSocketAddress) <span class="hljs-keyword">throws</span> IOException &#123; <br>    DataInputStream zygoteInputStream;<br>    BufferedWriter zygoteOutputWriter;<br><br>    <span class="hljs-keyword">final</span> LocalSocket zygoteSessionSocket = <span class="hljs-keyword">new</span> LocalSocket()<br>    <span class="hljs-keyword">if</span> (zygoteSocketAddress == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;zygoteSocketAddress can&#x27;t be null&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        zygoteSessionSocket.connect(zygoteSocketAddress);<br>        zygoteInputStream = <span class="hljs-keyword">new</span> DataInputStream(zygoteSessionSocket.getInputStream());<br>        zygoteOutputWriter = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(zygoteSessionSocket.getOutputStream()), Zygote.SOCKET_BUFFER_SIZE);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            zygoteSessionSocket.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ignore) &#123;&#125; <br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ZygoteState(zygoteSocketAddress, usapSocketAddress, zygoteSessionSocket, zygoteInputStream, zygoteOutputWriter, <br>getAbiList(zygoteOutputWriter, zygoteInputStream));<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="走入-zygote"><a href="#走入-zygote" class="headerlink" title="走入 zygote"></a>走入 zygote</h2><h3 id="从-zygote-开始"><a href="#从-zygote-开始" class="headerlink" title="从 zygote 开始"></a>从 zygote 开始</h3><p>下面就轮到 zygote 出场了，zygote 进程是 system server 和 app 进程的父进程，它在 java 的入口点是 <code>ZygoteInit.main</code>；zygote 启动后会加载各个进程共享的资源，然后启动 system server，最后工作在主循环 <code>runSelectLoop</code> 上；在 <code>runSelectLoop</code> 里，zygote 通过 <code>epoll</code> 监听 zygote server socket 并根据请求参数 fork 出 app 进程（上面也说到过 AMS 是通过 <code>LocalSocket</code> 请求让 zygote fork app process）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * zygote 的入口点</span><br><span class="hljs-comment"> * This is the entry point for a Zygote process.  It creates the Zygote server, loads resources,</span><br><span class="hljs-comment"> * and handles other tasks related to preparing the process for forking into applications.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> ZygoteInit.main(String[] argv) &#123;<br>    ZygoteServer zygoteServer = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// ...</span><br>    zygoteServer = <span class="hljs-keyword">new</span> ZygoteServer(isPrimaryZygote);<br>    <span class="hljs-comment">// ...</span><br>    caller = zygoteServer.runSelectLoop(abiList);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>zygote server socket 实际上是个挂载在 <code>/dev/sockets/</code> 目录下的 FD，它是由脚本 <code>init.rc</code> 创建的，这个 FD 可以通过环境变量 <code>ANDROID_SOCKET_&lt;socketName&gt;</code> 获得</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ZygoteServer(<span class="hljs-keyword">boolean</span> isPrimaryZygote) &#123;<br>    mUsapPoolEventFD = Zygote.getUsapPoolEventFD();<br>    <span class="hljs-keyword">if</span> (isPrimaryZygote) &#123;<br>        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME);  <span class="hljs-comment">// PRIMARY_SOCKET_NAME = &quot;zygote&quot;</span><br>        mUsapPoolSocket = Zygote.createManagedSocketFromInitSocket(Zygote.USAP_POOL_PRIMARY_SOCKET_NAME);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.SECONDARY_SOCKET_NAME);<br>        mUsapPoolSocket = Zygote.createManagedSocketFromInitSocket(Zygote.USAP_POOL_SECONDARY_SOCKET_NAME);<br>    &#125;<br>    mUsapPoolSupported = <span class="hljs-keyword">true</span>;<br>    fetchUsapPoolPolicyProps();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a managed LocalServerSocket object using a file descriptor</span><br><span class="hljs-comment"> * created by an init.rc script.  The init scripts that specify the</span><br><span class="hljs-comment"> * sockets name can be found in system/core/rootdir.  The socket is bound</span><br><span class="hljs-comment"> * to the file system in the /dev/sockets/ directory, and the file</span><br><span class="hljs-comment"> * descriptor is shared via the ANDROID_SOCKET_&lt;socketName&gt; environment</span><br><span class="hljs-comment"> * variable.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> LocalServerSocket Zygote.createManagedSocketFromInitSocket(String socketName) &#123;<br>    <span class="hljs-keyword">int</span> fileDesc;<br>    <span class="hljs-keyword">final</span> String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;  <span class="hljs-comment">// ANDROID_SOCKET_PREFIX = &quot;ANDROID_SOCKET_&quot;</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        String env = System.getenv(fullSocketName);<br>        fileDesc = Integer.parseInt(env);<br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Socket unset or invalid: &quot;</span> + fullSocketName, ex);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        FileDescriptor fd = <span class="hljs-keyword">new</span> FileDescriptor();<br>        fd.setInt$(fileDesc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LocalServerSocket(fd);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>            <span class="hljs-string">&quot;Error building socket from file descriptor: &quot;</span> + fileDesc, ex);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>而 zygote 主循环的整个代码就是 epoll 多路复用的模型</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Runs the zygote process&#x27;s select loop. Accepts new connections as</span><br><span class="hljs-comment"> * they happen, and reads commands from connections one spawn-request&#x27;s</span><br><span class="hljs-comment"> * worth at a time.</span><br><span class="hljs-comment"> */</span><br>Runnable ZygoteServer.runSelectLoop(String abiList) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-comment">// epoll 可以同时监听多个 FD：pollFDs，当 epoll 返回时要逐个处理</span><br>        StructPollfd[] pollFDs;<br>        pollFDs = <span class="hljs-keyword">new</span> StructPollfd[socketFDs.size()];<br>        <span class="hljs-keyword">int</span> pollIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (FileDescriptor socketFD : socketFDs) &#123;<br>            pollFDs[pollIndex] = <span class="hljs-keyword">new</span> StructPollfd();<br>            pollFDs[pollIndex].fd = socketFD;<br>            pollFDs[pollIndex].events = (<span class="hljs-keyword">short</span>) POLLIN;<br>            ++pollIndex;<br>        &#125;<br>        <span class="hljs-comment">// ... 阻塞直到 pollFDs 里有消息输入</span><br>        <span class="hljs-keyword">int</span> pollReturnValue;<br>        <span class="hljs-keyword">try</span> &#123;<br>            pollReturnValue = Os.poll(pollFDs, pollTimeoutMs);<br>        &#125; <span class="hljs-keyword">catch</span> (ErrnoException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;poll failed&quot;</span>, ex);<br>        &#125;<br>        <span class="hljs-comment">// ... 第一个 PD 总是 Zygote server socket，它接收 fork 请求并创建一个新的 FD 与对方交互</span><br>        <span class="hljs-keyword">while</span> (--pollIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (pollIndex == <span class="hljs-number">0</span>) &#123;<br>                ZygoteConnection newPeer = acceptCommandPeer(abiList);<br>                peers.add(newPeer);<br>                socketFDs.add(newPeer.getFileDescriptor());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pollIndex &lt; usapPoolEventFDIndex) &#123;<br>                <span class="hljs-comment">// 从 FD 里解析请求参数并处理</span><br>                ZygoteConnection connection = peers.get(pollIndex);<br>                <span class="hljs-keyword">boolean</span> multipleForksOK = !isUsapPoolEnabled() &amp;&amp; ZygoteHooks.indefiniteThreadSuspensionOK();<br>                <span class="hljs-keyword">final</span> Runnable command = connection.processCommand(<span class="hljs-keyword">this</span>, multipleForksOK);  <span class="hljs-comment">// commands alaways null in zygote server</span><br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="fork-app-process"><a href="#fork-app-process" class="headerlink" title="fork app process"></a>fork app process</h3><p>下面看看 zygote 是怎么 fork 出 app process 的</p><p><img src="../../../../image/2021-03-02-how-application-being-created-and-init/fork_by_zygote.png" alt="fork_by_zygote.png"></p><p>在 <code>fork()</code> 系统调用后，返回 0 表示当前处于子进程，&gt; 0 处于父进程（也就是 zygote）</p><p>zygote 进程会继续它的主循环 <code>runSelectLoop</code>，而子进程会跳出主循环，执行 <code>ZygoteConnection.processCommand</code> 返回的 <code>Runnable</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> ZygoteInit.main(String[] argv) &#123;<br>    <span class="hljs-comment">// ...</span><br>    Runnable caller;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        Log.i(TAG, <span class="hljs-string">&quot;Accepting command socket connections&quot;</span>);<br>        <span class="hljs-comment">// The select loop returns early in the child process after a fork and</span><br>        <span class="hljs-comment">// loops forever in the zygote.</span><br>        caller = zygoteServer.runSelectLoop(abiList);<br>    &#125; ...<br>    <span class="hljs-comment">// We&#x27;re in the child process and have exited the select loop. Proceed to execute the</span><br>    <span class="hljs-comment">// command.</span><br>    <span class="hljs-keyword">if</span> (caller != <span class="hljs-keyword">null</span>) &#123;<br>        caller.run();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个 <code>Runnable</code> 实际上是通过反射调用 <code>ActivityThread.main</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// app 进程的 entry point 被设置为 android.app.ActivityThread</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">startProcessLocked</span><span class="hljs-params">(ProcessRecord app, HostingRecord hostingRecord,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> zygotePolicyFlags, <span class="hljs-keyword">boolean</span> disableHiddenApiChecks, <span class="hljs-keyword">boolean</span> disableTestApiChecks,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> mountExtStorageFull, String abiOverride)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// Start the process.  It will either succeed and return a result containing</span><br>    <span class="hljs-comment">// the PID of the new process, or else throw a RuntimeException.</span><br>    <span class="hljs-keyword">final</span> String entryPoint = <span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>;<br>    <span class="hljs-keyword">return</span> startProcessLocked(hostingRecord, entryPoint, app, uid, gids, runtimeFlags, <br>zygotePolicyFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime);<br>&#125;<br><br><span class="hljs-comment">// 寻找方法 main(String[] args)</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title">findStaticMain</span><span class="hljs-params">(String className, String[] argv, ClassLoader classLoader)</span> </span>&#123;<br>    Class&lt;?&gt; cl;<br>    <span class="hljs-keyword">try</span> &#123;<br>        cl = Class.forName(className, <span class="hljs-keyword">true</span>, classLoader);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Missing class when invoking static main &quot;</span> + className, ex);<br>    &#125;<br>    Method m;<br>    <span class="hljs-keyword">try</span> &#123;<br>        m = cl.getMethod(<span class="hljs-string">&quot;main&quot;</span>, <span class="hljs-keyword">new</span> Class[] &#123; String[].class &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Missing static main on &quot;</span> + className, ex);<br>    &#125; <span class="hljs-keyword">catch</span> (SecurityException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Problem getting static main on &quot;</span> + className, ex);<br>    &#125;<br>    <span class="hljs-keyword">int</span> modifiers = m.getModifiers();<br>    <span class="hljs-keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Main method is not public and static on &quot;</span> + className);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MethodAndArgsCaller(m, argv);<br>&#125;<br><br><span class="hljs-comment">// 通过反射调用 main 方法</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAndArgsCaller</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-comment">/** method to call */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method mMethod;<br>    <span class="hljs-comment">/** argument array */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String[] mArgs;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MethodAndArgsCaller</span><span class="hljs-params">(Method method, String[] args)</span> </span>&#123;<br>        mMethod = method;<br>        mArgs = args;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mMethod.invoke(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> Object[] &#123; mArgs &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(ex);<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException ex) &#123;<br>            Throwable cause = ex.getCause();<br>            <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;<br>                <span class="hljs-keyword">throw</span> (RuntimeException) cause;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">instanceof</span> Error) &#123;<br>                <span class="hljs-keyword">throw</span> (Error) cause;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(ex);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Application-实例的创建和初始化"><a href="#Application-实例的创建和初始化" class="headerlink" title="Application 实例的创建和初始化"></a>Application 实例的创建和初始化</h2><p><img src="../../../../image/2021-03-02-how-application-being-created-and-init/create_application.png" alt="create_application.png"></p><p>app process 的起始点是 <code>ActivityThread.main</code>，做完所有准备龚州工作后进入 loop 循环，后续的任务通过 <code>Handler</code> 执行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    Looper.prepareMainLooper();<br>    <span class="hljs-comment">// ...</span><br>    Looper.loop();<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>ActivityThread.handleBindApplication</code> 是 <code>Application</code> 实例创建和初始化的地方</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ActivityThread.handleBindApplication(AppBindData data) &#123;<br>    <span class="hljs-comment">// ...</span><br>    Application app;<br>    <span class="hljs-keyword">final</span> StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();<br>    <span class="hljs-keyword">final</span> StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy();<br>    <span class="hljs-keyword">try</span> &#123;<br>        app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">// ...</span><br>    &#125; ...<br>&#125;<br><br><span class="hljs-keyword">public</span> Application LoadedApk.makeApplication(<span class="hljs-keyword">boolean</span> forceDefaultAppClass, Instrumentation instrumentation) &#123;<br>    <span class="hljs-comment">// ...</span><br>    Application app = <span class="hljs-keyword">null</span>;<br>    String appClass = mApplicationInfo.className;<br>    <span class="hljs-keyword">if</span> (forceDefaultAppClass || (appClass == <span class="hljs-keyword">null</span>)) &#123;<br>        appClass = <span class="hljs-string">&quot;android.app.Application&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> java.lang.ClassLoader cl = getClassLoader();<br>        <span class="hljs-keyword">if</span> (!mPackageName.equals(<span class="hljs-string">&quot;android&quot;</span>)) &#123;<br>            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;initializeJavaContextClassLoader&quot;</span>);<br>            initializeJavaContextClassLoader();<br>            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>        &#125;<br>        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="hljs-keyword">this</span>);<br>        <span class="hljs-comment">// ... 创建 Application 实例</span><br>        app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);<br>        appContext.setOuterContext(app);<br>    &#125; ...<br>    mActivityThread.mAllApplications.add(app);<br>    mApplication = app;<br>    <span class="hljs-keyword">if</span> (instrumentation != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            instrumentation.callApplicationOnCreate(app);  <span class="hljs-comment">// 这里会调用生命周期函数 onCreate</span><br>        &#125; ...<br>    &#125;<br>    <span class="hljs-keyword">return</span> app;<br>&#125;<br><br><span class="hljs-keyword">public</span> Instrumentation.<span class="hljs-function">Application <span class="hljs-title">newApplication</span><span class="hljs-params">(ClassLoader cl, String className, Context context)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;<br>    Application app = getFactory(context.getPackageName()).instantiateApplication(cl, className);<br>    app.attach(context);  <span class="hljs-comment">// 在这里会调用 attachBaseContext</span><br>    <span class="hljs-keyword">return</span> app;<br>&#125;<br><br><span class="hljs-comment">// 最终调用 loadClass 加载 app Application 类</span><br>Application AppComponentFactory.instantiateApplication(ClassLoader cl, String className)<br>        <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;<br>    <span class="hljs-keyword">return</span> (Application) cl.loadClass(className).newInstance();<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Application</tag>
      
      <tag>AMS</tag>
      
      <tag>Zygote</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池 ThreadPool 的实现</title>
    <link href="/blog/2021/02/19/threadpool/"/>
    <url>/blog/2021/02/19/threadpool/</url>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>线程池有几个重要的参数：</p><ul><li><code>maximumPoolSize</code> 最大线程数量，如果新提交的任务因为 <code>workQueue</code> 的容量限制而无法入队，则会尝试新开一个线程执行任务，而如果此时总线程数超过 <code>maximumPoolSize</code> 的限制，那么不再新开一个线程而是提交失败</li><li><code>corePoolSize</code> 核心线程数量，当任务执行完毕，线程也将结束它的生命周期，但最少不会低于 <code>corePoolSize</code></li><li><code>keepAliveTime</code> 空闲线程的存活时间，执行完任务的线程会存活至少 <code>keepAliveTime</code>，再根据当前线程数量和 <code>corePoolSize</code> 决定要不要结束生命</li><li><code>workQueue</code> 任务队列，当提交的任务不能被立刻执行时（线程数 &gt; <code>corePoolSize</code>），会放在 <code>workQueue</code> 排队等待执行</li></ul><p>线程池的内部状态：</p><ul><li><code>RUNNING</code>，可以提交新任务</li><li><code>SHUTDOWN</code>，不能提交新任务，但可以继续把 workQueue 里的任务执行完</li><li><code>STOP</code>，不能提交新任务，不执行 workQueue 里的任务，且中断正在执行的任务</li><li><code>TIDYING</code>，所有任务都已结束，此时线程数为零，准备执行 terminated()</li><li><code>TERMINATED</code>，<code>terminated()</code> 执行完毕</li></ul><h2 id="生产者-消费者模式的-worker"><a href="#生产者-消费者模式的-worker" class="headerlink" title="生产者 - 消费者模式的 worker"></a>生产者 - 消费者模式的 worker</h2><p>线程（worker）作为消费者，不断地从任务队列（workQueue）里获取任务并执行</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        runWorker(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// worker 的执行流程</span><br><span class="hljs-comment">// 用一个 while 循环不断地从 workQueue 里获取任务（blocked &amp; timeouted）</span><br><span class="hljs-comment">// getTask 返回 null 导致当前线程结束生命</span><br><span class="hljs-keyword">void</span> ThreadPoolExecutor.runWorker(Worker w) &#123;<br>    Thread wt = Thread.currentThread();<br>    Runnable task = w.firstTask;<br>    w.firstTask = <span class="hljs-keyword">null</span>;<br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>            w.lock();<br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task);<br>                Throwable thrown = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-keyword">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 从 workQueue 获取任务（blocked &amp; timeouted）</span><br>Runnable ThreadPoolExecutor.getTask() &#123;<br>    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br>        <br>        <span class="hljs-comment">// 1. 线程池已 shutdown（只需把 workQueue 执行完毕），但 workQueue 已清空</span><br>        <span class="hljs-comment">// 2. 线程池已 stop，无需执行 workQueue 剩下的任务</span><br>        <span class="hljs-comment">// 此时返回 null 结束线程 </span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 当线程数 &gt; corePoolSize，如果阻塞 keepAliveTime 时间段都没有新任务进来，则返回 null 结束当前线程</span><br>        <span class="hljs-comment">// 当线程数 &gt; maximumPoolSize 且 workQueue 为空，也要结束当前线程，从而降低线程数</span><br>        <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>        <span class="hljs-keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runnable r = timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="corePoolSize，workQueue-和-maximumPoolSize-之间的关系"><a href="#corePoolSize，workQueue-和-maximumPoolSize-之间的关系" class="headerlink" title="corePoolSize，workQueue 和 maximumPoolSize 之间的关系"></a><code>corePoolSize</code>，<code>workQueue</code> 和 <code>maximumPoolSize</code> 之间的关系</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ThreadPoolExecutor.execute(Runnable command) &#123;<br>    <span class="hljs-comment">// 如果线程数 &lt; corePoolSize，则新开一个线程执行任务</span><br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br><br>    <span class="hljs-comment">// 否则放入 workQueue 等待执行</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-keyword">int</span> recheck = ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果超过 workQueue 容量限制，则尝试新开一个线程执行任务</span><br>    <span class="hljs-comment">// 从下面的 addWorker 可以知道，如果新开线程的时候发现当前线程总数 &gt;= maximumPoolSize，那么任务提交失败</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>        reject(command);<br>&#125;<br><br><span class="hljs-keyword">boolean</span> ThreadPoolExecutor.addWorker(Runnable firstTask, <span class="hljs-keyword">boolean</span> core) &#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-keyword">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>    Worker w = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        w = <span class="hljs-keyword">new</span> Worker(firstTask);<br>        <span class="hljs-keyword">final</span> Thread t = w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());<br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    workers.add(w);<br>                    <span class="hljs-keyword">int</span> s = workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start();<br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="定时任务（ScheduledExecutorService）"><a href="#定时任务（ScheduledExecutorService）" class="headerlink" title="定时任务（ScheduledExecutorService）"></a>定时任务（<code>ScheduledExecutorService</code>）</h2><p>上文里的任务队列用的是 <code>BlockingQueue</code>，它是按照 FIFO 的优先级给任务排队的；要实现定时，就要按照执行时间点的优先级给任务排序，只有到达执行时间点的任务才能出队</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>要排序，每次取最小值（到达执行时间点的任务），而且会插入新元素，典型的数据结构是「小顶堆」；<code>DelayedWorkQueue</code> 就是用小顶堆实现的阻塞队列</p><p>堆有几个特性：</p><ul><li>堆在逻辑上是二叉树，存储为数组；节点从上到下，从左到右按顺序摊平在数组上</li><li>既然节点是按顺序排的，那么可以从索引计算出父/子节点：<ul><li><code>parent(i) = floor((i - 1)/2)</code></li><li><code>left(i) = 2i + 1</code></li><li><code>right(i) = 2i + 2</code></li></ul></li><li>父节点比子节点要小的是小顶堆，根节点最小；父节点比子节点大的是大顶堆，根节点最大；左右节点之间没有大小要求</li><li><code>shiftDown()</code>，出队最小/大值（也即根节点）后，将数组最后一个元素转移到根节点，然后从根节点开始递归地重排：如果一个节点比它的子节点小（最大堆）或者大（最小堆），那么需要将它向下移动，这样是这个节点在数组的位置下降</li><li><code>shiftUp()</code>，入队一个新元素到数组尾部，那么从这个元素开始从下往上重排：如果一个节点比它的父节点大（最大堆）或者小（最小堆），那么需要将它同父节点交换位置，这样是这个节点在数组的位置上升</li></ul><h3 id="DelayedWorkQueue-按执行时间优先级排序的阻塞队列"><a href="#DelayedWorkQueue-按执行时间优先级排序的阻塞队列" class="headerlink" title="DelayedWorkQueue 按执行时间优先级排序的阻塞队列"></a><code>DelayedWorkQueue</code> 按执行时间优先级排序的阻塞队列</h3><p>提交一个新任务到 <code>DelayedWorkQueue</code>，重排 workQueue</p><p>workQueue 是按执行时间点排序的，leader 是在队头任务上挂起的线程，leader 未唤醒时新来的出队请求将在 available 上挂起</p><p>队列为空时线程也在 available 上挂起</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ScheduledFuture&lt;?&gt; ScheduledThreadPoolExecutor.schedule(Runnable command, <span class="hljs-keyword">long</span> delay, TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span> || unit == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command,<br>        <span class="hljs-keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="hljs-keyword">null</span>, triggerTime(delay, unit), sequencer.getAndIncrement()));<br>    delayedExecute(t);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-keyword">void</span> ScheduledThreadPoolExecutor.delayedExecute(RunnableScheduledFuture&lt;?&gt; task) &#123;<br>    <span class="hljs-keyword">if</span> (isShutdown())<br>        reject(task);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">super</span>.getQueue().add(task);<br>        <span class="hljs-keyword">if</span> (isShutdown() &amp;&amp;<br>            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;<br>            remove(task))<br>            task.cancel(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">else</span><br>            ensurePrestart();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">boolean</span> DelayedWorkQueue.add(Runnable e) &#123;<br>    <span class="hljs-keyword">return</span> offer(e);<br>&#125;<br><br><span class="hljs-comment">// 插入小顶堆</span><br><span class="hljs-keyword">boolean</span> DelayedWorkQueue.offer(Runnable x) &#123;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 小顶堆底层是数组，数组容量不足需要扩容（扩容 50%）</span><br>        <span class="hljs-keyword">int</span> i = size;<br>        <span class="hljs-keyword">if</span> (i &gt;= queue.length)<br>            grow();<br>        <span class="hljs-comment">// 小顶堆的插入操作 siftUp</span><br>        size = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            queue[<span class="hljs-number">0</span>] = e;<br>            setIndex(e, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            siftUp(i, e);<br>        &#125;<br>        <span class="hljs-comment">// 新加入的任务排在队头，它的执行时间点最近</span><br>        <span class="hljs-comment">// 此时 leader 是挂起在上一个队头上的，要置空（有更近的执行时间点进来了）并唤醒 available 上的线程来争抢新的队头任务</span><br>        <span class="hljs-keyword">if</span> (queue[<span class="hljs-number">0</span>] == e) &#123;<br>            leader = <span class="hljs-keyword">null</span>;<br>            available.signal();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 堆是一个二叉树，广度优先、从左到右存储为数组</span><br><span class="hljs-comment">// 新元素添加到数组尾部（相当于二叉树中的叶子节点），k 是它的索引，为了继续满足小顶堆的要求，需要重新排序</span><br><span class="hljs-keyword">void</span> DelayedWorkQueue.siftUp(<span class="hljs-keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key) &#123;<br><span class="hljs-comment">// 从下往上比较，如果它比父节点小，交换之</span><br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> parent = (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        RunnableScheduledFuture&lt;?&gt; e = queue[parent];<br>        <span class="hljs-keyword">if</span> (key.compareTo(e) &gt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = e;<br>        setIndex(e, k);<br>        k = parent;<br>    &#125;<br>    <span class="hljs-comment">// 直到满足小于父节点的要求（小顶堆），那么这就是 key 的合适位置</span><br>    queue[k] = key;<br>    setIndex(key, k);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面说过 <code>worker</code> 是一个「生产者-消费者」模型，通过 <code>getTask</code> 不断地从 <code>workQueue</code> 获取任务</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 从 workQueue 获取任务（blocked &amp; timeouted）</span><br>Runnable ThreadPoolExecutor.getTask() &#123;<br>    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Runnable r = timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 任务出队（blocked）</span><br>RunnableScheduledFuture&lt;?&gt; DelayedWorkQueue.take() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br><br>            <span class="hljs-comment">// 任务队列为空，在 available 挂起</span><br>            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>)<br>                available.await();<br>            <span class="hljs-keyword">else</span> &#123;<br><br>                <span class="hljs-comment">// 到达执行时间点的才能出队</span><br>                <span class="hljs-keyword">long</span> delay = first.getDelay(NANOSECONDS);<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> finishPoll(first);<br><br>                <span class="hljs-comment">// leader 是挂起在 first 上的线程，它将在 first 执行时间点上恢复</span><br>                <span class="hljs-comment">// 如果已有线程在 first 上挂起，则当前线程在 available 上挂起</span><br>                first = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (leader != <span class="hljs-keyword">null</span>)<br>                    available.await();<br>                <span class="hljs-keyword">else</span> &#123;<br>                    Thread thisThread = Thread.currentThread();<br>                    leader = thisThread;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        available.awaitNanos(delay);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-keyword">if</span> (leader == thisThread)<br>                            leader = <span class="hljs-keyword">null</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 出队后，唤醒在 available 上挂起的线程</span><br>        <span class="hljs-keyword">if</span> (leader == <span class="hljs-keyword">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span>)<br>            available.signal();<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 将小顶堆的根 queue[0] 出队后，需要重排堆：</span><br><span class="hljs-comment">// 1. 将最后一个数组元素转移到根节点</span><br><span class="hljs-comment">// 2. 从上往下重排：比较父节点和子节点，如果父节点大于子节点则交换之</span><br>RunnableScheduledFuture&lt;?&gt; DelayedWorkQueue.finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;<br>    <span class="hljs-keyword">int</span> s = --size;<br>    RunnableScheduledFuture&lt;?&gt; x = queue[s];<br>    queue[s] = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>        siftDown(<span class="hljs-number">0</span>, x);<br>    setIndex(f, -<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-keyword">void</span> DelayedWorkQueue.siftDown(<span class="hljs-keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key) &#123;<br>    <span class="hljs-keyword">int</span> half = size &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k &lt; half) &#123;<br>        <span class="hljs-keyword">int</span> child = (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        RunnableScheduledFuture&lt;?&gt; c = queue[child];<br>        <span class="hljs-keyword">int</span> right = child + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class="hljs-number">0</span>)<br>            c = queue[child = right];<br>        <span class="hljs-keyword">if</span> (key.compareTo(c) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = c;<br>        setIndex(c, k);<br>        k = child;<br>    &#125;<br>    queue[k] = key;<br>    setIndex(key, k);<br>&#125;<br><br><span class="hljs-comment">// 任务出队（timeouted）</span><br>RunnableScheduledFuture&lt;?&gt; DelayedWorkQueue.poll(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)<br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br><br>            <span class="hljs-comment">// 队列为空，挂起 timeout 后继续</span><br>            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">else</span><br>                    nanos = available.awaitNanos(nanos);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><br>                <span class="hljs-comment">// first 到达执行时间点，立刻返回</span><br>                <span class="hljs-keyword">long</span> delay = first.getDelay(NANOSECONDS);<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> finishPoll(first);<br><br>                <span class="hljs-comment">// 否则挂起</span><br>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                first = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// don&#x27;t retain ref while waiting</span><br>                <span class="hljs-keyword">if</span> (nanos &lt; delay || leader != <span class="hljs-keyword">null</span>)<br>                    nanos = available.awaitNanos(nanos);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    Thread thisThread = Thread.currentThread();<br>                    leader = thisThread;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">long</span> timeLeft = available.awaitNanos(delay);<br>                        nanos -= delay - timeLeft;<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-keyword">if</span> (leader == thisThread)<br>                            leader = <span class="hljs-keyword">null</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (leader == <span class="hljs-keyword">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span>)<br>            available.signal();<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="如果-worker-数量超过-maximumPoolSize，task-会被-reject"><a href="#如果-worker-数量超过-maximumPoolSize，task-会被-reject" class="headerlink" title="如果 worker 数量超过 maximumPoolSize，task 会被 reject"></a>如果 worker 数量超过 maximumPoolSize，task 会被 reject</h2><p><code>ThreadPoolExecutor</code> 提供了 <code>RejectedExecutionHandler</code> 来处理这种情况，平常通过 <code>Executors</code> 创建的线程池使用默认的 <code>AbortPolicy</code>，它会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A handler for rejected tasks that throws a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> RejectedExecutionException&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates an &#123;<span class="hljs-doctag">@code</span> AbortPolicy&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbortPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Always throws RejectedExecutionException.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r the runnable task requested to be executed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e the executor attempting to execute this task</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException always</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                             <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                             e.toString());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其他的还有：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 扔掉 task 不做任何处理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 既然 workQueue 满了那我就扔掉一个，然后把这个 task 入队</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            e.getQueue().poll();<br>            e.execute(r);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 由提交 task 的线程负责执行 task</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            r.run();<br>        &#125;<br>    &#125;<br>&#125;        <br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Art</category>
      
    </categories>
    
    
    <tags>
      
      <tag>threadpool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（五）Condition 的语言实现：Object.wait 和 Object.notify</title>
    <link href="/blog/2021/02/11/wait-notify/"/>
    <url>/blog/2021/02/11/wait-notify/</url>
    
    <content type="html"><![CDATA[<p>在 <a href="../../../../2021/01/24/condition-by-lock/">Lock（三）利用 Lock 实现 Condition</a> 我们介绍了如何用 <code>Lock</code> 来实现 <code>Condition</code>，而 <code>Condition</code> 对标的是 <code>Object.wait</code> 和 <code>Object.notify</code></p><p>我们来看看 ART 是怎么实现 wait/notify 的（最好先了解下 <a href="../../../../2021/02/08/synchronized-implementation/">synchronized 的基础知识</a>）</p><h2 id="ConditionVariable"><a href="#ConditionVariable" class="headerlink" title="ConditionVariable"></a>ConditionVariable</h2><p>对 futex/mutex 的封装，宏 <code>ART_USE_FUTEXES</code> 决定底层是使用 futex 还是 mutex；它不是「条件变量」，<code>Monitor</code> 才是（而且它还包含 Lock 的角色）</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/base/mutex.cc</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ConditionVariable::Wait</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  guard_.<span class="hljs-built_in">CheckSafeToWait</span>(self);<br>  <span class="hljs-built_in">WaitHoldingLocks</span>(self);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ConditionVariable::WaitHoldingLocks</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self == <span class="hljs-literal">nullptr</span> || self == Thread::<span class="hljs-built_in">Current</span>());<br>  guard_.<span class="hljs-built_in">AssertExclusiveHeld</span>(self);<br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> old_recursion_count = guard_.recursion_count_;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>  num_waiters_++;<br>  <span class="hljs-comment">// Ensure the Mutex is contended so that requeued threads are awoken.</span><br>  guard_.<span class="hljs-built_in">increment_contenders</span>();<br>  guard_.recursion_count_ = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int32_t</span> cur_sequence = sequence_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>  guard_.<span class="hljs-built_in">ExclusiveUnlock</span>(self);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">futex</span>(sequence_.<span class="hljs-built_in">Address</span>(), FUTEX_WAIT_PRIVATE, cur_sequence, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// Futex failed, check it is an expected error.</span><br>    <span class="hljs-comment">// EAGAIN == EWOULDBLK, so we let the caller try again.</span><br>    <span class="hljs-comment">// EINTR implies a signal was sent to this thread.</span><br>    <span class="hljs-keyword">if</span> ((errno != EINTR) &amp;&amp; (errno != EAGAIN)) &#123;<br>      <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;futex wait failed for &quot;</span> &lt;&lt; name_;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">SleepIfRuntimeDeleted</span>(self);<br>  guard_.<span class="hljs-built_in">ExclusiveLock</span>(self);<br>  <span class="hljs-built_in">CHECK_GT</span>(num_waiters_, <span class="hljs-number">0</span>);<br>  num_waiters_--;<br>  <span class="hljs-comment">// We awoke and so no longer require awakes from the guard_&#x27;s unlock.</span><br>  <span class="hljs-built_in">CHECK_GT</span>(guard_.<span class="hljs-built_in">get_contenders</span>(), <span class="hljs-number">0</span>);<br>  guard_.<span class="hljs-built_in">decrement_contenders</span>();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  <span class="hljs-keyword">pid_t</span> old_owner = guard_.<span class="hljs-built_in">GetExclusiveOwnerTid</span>();<br>  guard_.exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* pid */</span>, std::memory_order_relaxed);<br>  guard_.recursion_count_ = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_cond_wait, (&amp;cond_, &amp;guard_.mutex_));<br>  guard_.exclusive_owner_.<span class="hljs-built_in">store</span>(old_owner, std::memory_order_relaxed);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  guard_.recursion_count_ = old_recursion_count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ConditionVariable::Signal</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self == <span class="hljs-literal">nullptr</span> || self == Thread::<span class="hljs-built_in">Current</span>());<br>  guard_.<span class="hljs-built_in">AssertExclusiveHeld</span>(self);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>  <span class="hljs-built_in">RequeueWaiters</span>(<span class="hljs-number">1</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>  <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_cond_signal, (&amp;cond_));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ConditionVariable::RequeueWaiters</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> count)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (num_waiters_ &gt; <span class="hljs-number">0</span>) &#123;<br>    sequence_++;  <span class="hljs-comment">// Indicate a signal occurred.</span><br>    <span class="hljs-comment">// Move waiters from the condition variable&#x27;s futex to the guard&#x27;s futex,</span><br>    <span class="hljs-comment">// so that they will be woken up when the mutex is released.</span><br>    <span class="hljs-keyword">bool</span> done = <span class="hljs-built_in">futex</span>(sequence_.<span class="hljs-built_in">Address</span>(),<br>                      FUTEX_REQUEUE_PRIVATE,<br>                      <span class="hljs-comment">/* Threads to wake */</span> <span class="hljs-number">0</span>,<br>                      <span class="hljs-comment">/* Threads to requeue*/</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> timespec*&gt;(count),<br>                      guard_.state_and_contenders_.<span class="hljs-built_in">Address</span>(),<br>                      <span class="hljs-number">0</span>) != <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (!done &amp;&amp; errno != EAGAIN &amp;&amp; errno != EINTR) &#123;<br>      <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;futex requeue failed for &quot;</span> &lt;&lt; name_;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>从逻辑上实现了「条件变量」，对应 Condition；它有两条单向链表的排队队列：</p><ul><li>等待队列，被挂起的线程（wait）在这里排队，<code>Monitor::wait_set_</code> 是队头</li><li>唤醒队列，等待被唤醒的线程（notify）在这里排队，<code>Monitor::wake_set_</code> 是队头</li></ul><p><code>Thread</code> 有个成员变量充当 next 指针：<code>Thread::GetWaitNext()</code> 和 <code>Thread::SetWaitNext(Thread* next)</code></p><p>await 是把线程添加到 wait set 队尾，notify 是把 wait set 队头转移为 wake set 队头，然后在退出临界区（释放锁）时唤醒 wake set 队头</p><p>同时 <code>Thread::wait_monitor_</code> 标识线程在哪个 <code>Monitor</code> 上挂起</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> &#123;</span><br>  <span class="hljs-comment">// Threads currently waiting on this monitor.</span><br>  <span class="hljs-function">Thread* wait_set_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(monitor_lock_)</span></span>;<br>  <span class="hljs-comment">// Threads that were waiting on this monitor, but are now contending on it.</span><br>  <span class="hljs-function">Thread* wake_set_ <span class="hljs-title">GUARDED_BY</span><span class="hljs-params">(monitor_lock_)</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 将新挂起的线程添加到 wait set 队尾</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::AppendToWaitSet</span><span class="hljs-params">(Thread* thread)</span> </span>&#123;<br>  <span class="hljs-comment">// Not checking that the owner is equal to this thread, since we&#x27;ve released</span><br>  <span class="hljs-comment">// the monitor by the time this method is called.</span><br>  <span class="hljs-built_in">DCHECK</span>(thread != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">DCHECK</span>(thread-&gt;<span class="hljs-built_in">GetWaitNext</span>() == <span class="hljs-literal">nullptr</span>) &lt;&lt; thread-&gt;<span class="hljs-built_in">GetWaitNext</span>();<br>  <span class="hljs-keyword">if</span> (wait_set_ == <span class="hljs-literal">nullptr</span>) &#123;<br>    wait_set_ = thread;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// push_back.</span><br>  Thread* t = wait_set_;<br>  <span class="hljs-keyword">while</span> (t-&gt;<span class="hljs-built_in">GetWaitNext</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>    t = t-&gt;<span class="hljs-built_in">GetWaitNext</span>();<br>  &#125;<br>  t-&gt;<span class="hljs-built_in">SetWaitNext</span>(thread);<br>&#125;<br><br><span class="hljs-comment">// notify 并没有唤醒线程，而是把 wait set 的队头转移到 wake set 队头</span><br><span class="hljs-comment">// 实际上是在释放锁时唤醒 wake set 队头</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::Notify</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-comment">// Make sure that we hold the lock.</span><br>  <span class="hljs-keyword">if</span> (owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) != self) &#123;<br>    <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// Move one thread from waiters to wake set</span><br>  Thread* to_move = wait_set_;<br>  <span class="hljs-keyword">if</span> (to_move != <span class="hljs-literal">nullptr</span>) &#123;<br>    wait_set_ = to_move-&gt;<span class="hljs-built_in">GetWaitNext</span>();<br>    to_move-&gt;<span class="hljs-built_in">SetWaitNext</span>(wake_set_);<br>    wake_set_ = to_move;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Object-wait"><a href="#Object-wait" class="headerlink" title="Object.wait"></a>Object.wait</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> Object.wait() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    wait(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">void</span> Object.wait(<span class="hljs-keyword">long</span> timeout) <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    wait(timeout, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> Object.wait(<span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">int</span> nanos) <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/native/java_lang_Object.cc</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Object_waitJI</span><span class="hljs-params">(JNIEnv* env, jobject java_this, jlong ms, jint ns)</span> </span>&#123;<br>  <span class="hljs-function">ScopedFastNativeObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;<br>  soa.Decode&lt;mirror::Object&gt;(java_this)-&gt;<span class="hljs-built_in">Wait</span>(soa.<span class="hljs-built_in">Self</span>(), ms, ns);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Object::Wait</span><span class="hljs-params">(Thread* self, <span class="hljs-keyword">int64_t</span> ms, <span class="hljs-keyword">int32_t</span> ns)</span> </span>&#123;<br>  Monitor::<span class="hljs-built_in">Wait</span>(self, <span class="hljs-keyword">this</span>, ms, ns, <span class="hljs-literal">true</span>, kTimedWaiting);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::Wait</span><span class="hljs-params">(Thread* self,</span></span><br><span class="hljs-function"><span class="hljs-params">                   ObjPtr&lt;mirror::Object&gt; obj,</span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">int64_t</span> ms,</span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">int32_t</span> ns,</span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">bool</span> interruptShouldThrow,</span></span><br><span class="hljs-function"><span class="hljs-params">                   ThreadState why)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">DCHECK</span>(obj != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-function">StackHandleScope&lt;1&gt; <span class="hljs-title">hs</span><span class="hljs-params">(self)</span></span>;<br>  <span class="hljs-function">Handle&lt;mirror::Object&gt; <span class="hljs-title">h_obj</span><span class="hljs-params">(hs.NewHandle(obj))</span></span>;<br><br>  <span class="hljs-comment">// 将锁膨胀为 fat lock</span><br>  LockWord lock_word = h_obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">while</span> (lock_word.<span class="hljs-built_in">GetState</span>() != LockWord::kFatLocked) &#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;<br>      <span class="hljs-keyword">case</span> LockWord::kHashCode:<br><br>      <span class="hljs-comment">// wait/notify 必须先用 synchronized 获取此对象上的锁</span><br>      <span class="hljs-comment">// 否则抛出 java 异常</span><br>      <span class="hljs-keyword">case</span> LockWord::kUnlocked:<br>        <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before wait()&quot;</span>);<br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span><br><br>      <span class="hljs-comment">// 同上，必须获得此对象锁；此时对象锁被别的线程持有，抛出 java 异常</span><br>      <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;<br>        <span class="hljs-keyword">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();<br>        <span class="hljs-keyword">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();<br>        <span class="hljs-keyword">if</span> (owner_thread_id != thread_id) &#123;<br>          <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before wait()&quot;</span>);<br>          <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>          <span class="hljs-comment">// 将 thin lock（偏向锁）膨胀为 fat lock（重量级锁），同时创建一个监视器 Monitor</span><br>          <span class="hljs-comment">// We own the lock, inflate to enqueue ourself on the Monitor. May fail spuriously so</span><br>          <span class="hljs-comment">// re-load.</span><br>          <span class="hljs-built_in">Inflate</span>(self, self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-number">0</span>);<br>          lock_word = h_obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 已经是 fat lock 了</span><br>      <span class="hljs-keyword">case</span> LockWord::kFatLocked:  <span class="hljs-comment">// Unreachable given the loop condition above. Fall-through.</span><br>      <span class="hljs-keyword">default</span>: &#123;<br>        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();<br>        <span class="hljs-built_in">UNREACHABLE</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 必须膨胀为 fat lock，它才有 Monitor</span><br>  Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();<br>  mon-&gt;<span class="hljs-built_in">Wait</span>(self, ms, ns, interruptShouldThrow, why);<br>&#125;<br><br><span class="hljs-comment">// 在监视器上挂起</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::Wait</span><span class="hljs-params">(Thread* self, <span class="hljs-keyword">int64_t</span> ms, <span class="hljs-keyword">int32_t</span> ns,</span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">bool</span> interruptShouldThrow, ThreadState why)</span> </span>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * Release our hold - we need to let it go even if we&#x27;re a few levels</span><br><span class="hljs-comment">   * deep in a recursive lock, and we need to restore that later.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> prev_lock_count = lock_count_;<br>  lock_count_ = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 挂起线程前需要释放锁</span><br>  <span class="hljs-comment">// 将线程添加到 wait set 队尾，释放锁，wake set 不为空则唤醒第一个（队头开始）</span><br>  <span class="hljs-keyword">bool</span> was_interrupted = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">bool</span> timed_out = <span class="hljs-literal">false</span>;<br>  owner_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);<br>  num_waiters_.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);<br>  &#123;<br>    <span class="hljs-function">ScopedThreadSuspension <span class="hljs-title">sts</span><span class="hljs-params">(self, why)</span></span>;<br>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *self-&gt;GetWaitMutex())</span></span>;<br>    <span class="hljs-built_in">AppendToWaitSet</span>(self);<br>    self-&gt;<span class="hljs-built_in">SetWaitMonitor</span>(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">SignalWaiterAndReleaseMonitorLock</span>(self);<br>    <span class="hljs-comment">// Handle the case where the thread was interrupted before we called wait().</span><br>    <span class="hljs-keyword">if</span> (self-&gt;<span class="hljs-built_in">IsInterrupted</span>()) &#123;<br>      was_interrupted = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      <span class="hljs-comment">// 然后将线程在它的成员变量 Thread.wait_cond_ 上挂起</span><br>      <span class="hljs-comment">// Wait for a notification or a timeout to occur.</span><br>      <span class="hljs-keyword">if</span> (why == kWaiting) &#123;<br>        self-&gt;<span class="hljs-built_in">GetWaitConditionVariable</span>()-&gt;<span class="hljs-built_in">Wait</span>(self);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">DCHECK</span>(why == kTimedWaiting || why == kSleeping) &lt;&lt; why;<br>        timed_out = self-&gt;<span class="hljs-built_in">GetWaitConditionVariable</span>()-&gt;<span class="hljs-built_in">TimedWait</span>(self, ms, ns);<br>      &#125;<br>      was_interrupted = self-&gt;<span class="hljs-built_in">IsInterrupted</span>();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 线程被唤醒后，要将线程上的监视器置空，并重新获得锁</span><br>  &#123;<br>    <span class="hljs-comment">// We reset the thread&#x27;s wait_monitor_ field after transitioning back to runnable so</span><br>    <span class="hljs-comment">// that a thread in a waiting/sleeping state has a non-null wait_monitor_ for debugging</span><br>    <span class="hljs-comment">// and diagnostic purposes. (If you reset this earlier, stack dumps will claim that threads</span><br>    <span class="hljs-comment">// are waiting on &quot;null&quot;.)</span><br>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *self-&gt;GetWaitMutex())</span></span>;<br>    <span class="hljs-built_in">DCHECK</span>(self-&gt;<span class="hljs-built_in">GetWaitMonitor</span>() != <span class="hljs-literal">nullptr</span>);<br>    self-&gt;<span class="hljs-built_in">SetWaitMonitor</span>(<span class="hljs-literal">nullptr</span>);<br>  &#125;<br>  Lock&lt;LockReason::kForWait&gt;(self);<br>  lock_count_ = prev_lock_count;<br>  <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));<br>  self-&gt;<span class="hljs-built_in">GetWaitMutex</span>()-&gt;<span class="hljs-built_in">AssertNotHeld</span>(self);<br>  num_waiters_.<span class="hljs-built_in">fetch_sub</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);<br>  <span class="hljs-built_in">RemoveFromWaitSet</span>(self);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Object-notify"><a href="#Object-notify" class="headerlink" title="Object.notify"></a>Object.notify</h2><p>把挂起的线程从 wait set 转移到 wake set</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Object_notify</span><span class="hljs-params">(JNIEnv* env, jobject java_this)</span> </span>&#123;<br>  <span class="hljs-function">ScopedFastNativeObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;<br>  soa.Decode&lt;mirror::Object&gt;(java_this)-&gt;<span class="hljs-built_in">Notify</span>(soa.<span class="hljs-built_in">Self</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Object::Notify</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  Monitor::<span class="hljs-built_in">Notify</span>(self, <span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Notify</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj)</span></span><br><span class="hljs-function">      <span class="hljs-title">REQUIRES_SHARED</span><span class="hljs-params">(Locks::mutator_lock_)</span> </span>&#123;<br>    <span class="hljs-built_in">DoNotify</span>(self, obj, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::DoNotify</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj, <span class="hljs-keyword">bool</span> notify_all)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">DCHECK</span>(obj != <span class="hljs-literal">nullptr</span>);<br>  LockWord lock_word = obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;<br>    <span class="hljs-keyword">case</span> LockWord::kHashCode:<br>      <span class="hljs-comment">// Fall-through.</span><br>    <span class="hljs-keyword">case</span> LockWord::kUnlocked:<br>      <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);<br>      <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span><br>    <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;<br>      <span class="hljs-keyword">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();<br>      <span class="hljs-keyword">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();<br>      <span class="hljs-keyword">if</span> (owner_thread_id != thread_id) &#123;<br>        <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);<br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Failure.</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// We own the lock but there&#x27;s no Monitor and therefore no waiters.</span><br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Success.</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">case</span> LockWord::kFatLocked: &#123;<br>      Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();<br>      <span class="hljs-keyword">if</span> (notify_all) &#123;<br>        mon-&gt;<span class="hljs-built_in">NotifyAll</span>(self);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        mon-&gt;<span class="hljs-built_in">Notify</span>(self);<br>      &#125;<br>      <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Success.</span><br>    &#125;<br>    <span class="hljs-keyword">default</span>: &#123;<br>      <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();<br>      <span class="hljs-built_in">UNREACHABLE</span>();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::Notify</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-comment">// Make sure that we hold the lock.</span><br>  <span class="hljs-keyword">if</span> (owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) != self) &#123;<br>    <span class="hljs-built_in">ThrowIllegalMonitorStateExceptionF</span>(<span class="hljs-string">&quot;object not locked by thread before notify()&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// Move one thread from waiters to wake set</span><br>  Thread* to_move = wait_set_;<br>  <span class="hljs-keyword">if</span> (to_move != <span class="hljs-literal">nullptr</span>) &#123;<br>    wait_set_ = to_move-&gt;<span class="hljs-built_in">GetWaitNext</span>();<br>    to_move-&gt;<span class="hljs-built_in">SetWaitNext</span>(wake_set_);<br>    wake_set_ = to_move;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>调用 notify 前需要先获得它的对象锁，notify 把线程转移到 wake set，释放锁时会唤醒线程（从而让线程能够重新获得锁）</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Monitor::Unlock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);<br>  Thread* owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>  <span class="hljs-keyword">if</span> (owner == self) &#123;<br>    <span class="hljs-comment">// We own the monitor, so nobody else can be in here.</span><br>    <span class="hljs-built_in">CheckLockOwnerRequest</span>(self);<br>    <span class="hljs-built_in">AtraceMonitorUnlock</span>();<br>    <span class="hljs-keyword">if</span> (lock_count_ == <span class="hljs-number">0</span>) &#123;<br>      owner_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);<br>      <span class="hljs-built_in">SignalWaiterAndReleaseMonitorLock</span>(self);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      --lock_count_;<br>      <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));<br>      <span class="hljs-built_in">DCHECK_EQ</span>(owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed), self);<br>      <span class="hljs-comment">// Keep monitor_lock_, but pretend we released it.</span><br>      <span class="hljs-built_in">FakeUnlockMonitorLock</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::SignalWaiterAndReleaseMonitorLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-comment">// We want to release the monitor and signal up to one thread that was waiting</span><br>  <span class="hljs-comment">// but has since been notified.</span><br>  <span class="hljs-built_in">DCHECK_EQ</span>(lock_count_, <span class="hljs-number">0u</span>);<br>  <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));<br>  <span class="hljs-keyword">while</span> (wake_set_ != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-comment">// No risk of waking ourselves here; since monitor_lock_ is not released until we&#x27;re ready to</span><br>    <span class="hljs-comment">// return, notify can&#x27;t move the current thread from wait_set_ to wake_set_ until this</span><br>    <span class="hljs-comment">// method is done checking wake_set_.</span><br>    Thread* thread = wake_set_;<br>    wake_set_ = thread-&gt;<span class="hljs-built_in">GetWaitNext</span>();<br>    thread-&gt;<span class="hljs-built_in">SetWaitNext</span>(<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">DCHECK</span>(owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) == <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-comment">// Check to see if the thread is still waiting.</span><br>    &#123;<br>      <span class="hljs-comment">// In the case of wait(), we&#x27;ll be acquiring another thread&#x27;s GetWaitMutex with</span><br>      <span class="hljs-comment">// self&#x27;s GetWaitMutex held. This does not risk deadlock, because we only acquire this lock</span><br>      <span class="hljs-comment">// for threads in the wake_set_. A thread can only enter wake_set_ from Notify or NotifyAll,</span><br>      <span class="hljs-comment">// and those hold monitor_lock_. Thus, the threads whose wait mutexes we acquire here must</span><br>      <span class="hljs-comment">// have already been released from wait(), since we have not released monitor_lock_ until</span><br>      <span class="hljs-comment">// after we&#x27;ve chosen our thread to wake, so there is no risk of the following lock ordering</span><br>      <span class="hljs-comment">// leading to deadlock:</span><br>      <span class="hljs-comment">// Thread 1 waits</span><br>      <span class="hljs-comment">// Thread 2 waits</span><br>      <span class="hljs-comment">// Thread 3 moves threads 1 and 2 from wait_set_ to wake_set_</span><br>      <span class="hljs-comment">// Thread 1 enters this block, and attempts to acquire Thread 2&#x27;s GetWaitMutex to wake it</span><br>      <span class="hljs-comment">// Thread 2 enters this block, and attempts to acquire Thread 1&#x27;s GetWaitMutex to wake it</span><br>      <span class="hljs-comment">//</span><br>      <span class="hljs-comment">// Since monitor_lock_ is not released until the thread-to-be-woken-up&#x27;s GetWaitMutex is</span><br>      <span class="hljs-comment">// acquired, two threads cannot attempt to acquire each other&#x27;s GetWaitMutex while holding</span><br>      <span class="hljs-comment">// their own and cause deadlock.</span><br>      <span class="hljs-function">MutexLock <span class="hljs-title">wait_mu</span><span class="hljs-params">(self, *thread-&gt;GetWaitMutex())</span></span>;<br>      <span class="hljs-keyword">if</span> (thread-&gt;<span class="hljs-built_in">GetWaitMonitor</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-comment">// Release the lock, so that a potentially awakened thread will not</span><br>        <span class="hljs-comment">// immediately contend on it. The lock ordering here is:</span><br>        <span class="hljs-comment">// monitor_lock_, self-&gt;GetWaitMutex, thread-&gt;GetWaitMutex</span><br>        monitor_lock_.<span class="hljs-built_in">Unlock</span>(self);  <span class="hljs-comment">// Releases contenders.</span><br>        thread-&gt;<span class="hljs-built_in">GetWaitConditionVariable</span>()-&gt;<span class="hljs-built_in">Signal</span>(self);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  monitor_lock_.<span class="hljs-built_in">Unlock</span>(self);<br>  <span class="hljs-built_in">DCHECK</span>(!monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结下"><a href="#总结下" class="headerlink" title="总结下"></a>总结下</h2><ul><li>与 JCU.Condition 不同，对象监视器 Monitor 并没有把「条件变量」这部分功能抽离出来，它既是 Lock 又是 Condition</li><li>Condition 和 Monitor 都用排队队列来组织挂起的线程</li><li>Condition 在 notify 后立刻唤醒线程，而 Monitor 因为 wait/notify 需要获得锁后才能执行，只能在 notify 线程释放锁时才唤醒 wait 线程</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Art</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wait</tag>
      
      <tag>notify</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（四）synchronized 的语言实现</title>
    <link href="/blog/2021/02/08/synchronized-implementation/"/>
    <url>/blog/2021/02/08/synchronized-implementation/</url>
    
    <content type="html"><![CDATA[<h2 id="monitor-指令"><a href="#monitor-指令" class="headerlink" title="monitor 指令"></a>monitor 指令</h2><p>在 <a href="../../../../2021/01/13/aqs-lock-implementation/">Lock（二）AQS 源码分析以及 Lock 的实现</a> 这篇文章里介绍了基于 AQS 的 <code>Lock</code>，它是双向链表的排队队列和系统调用 <code>futex</code> 实现的</p><p>其实 java 语言规范里自带了 Lock 的实现：<code>synchronized</code> 关键字，下面看看 ART 是怎么实现它的</p><p>先写一个使用了 <code>synchronized</code> 的测试方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.myapplication;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(lock) &#123;<br>            System.out.println(msg != <span class="hljs-keyword">null</span> ? msg : <span class="hljs-string">&quot;null&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        Hello instance = <span class="hljs-keyword">new</span> Hello();<br>        instance.say(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译打包出 apk 文件，解压出其中的 classes.dex，并用 <code>baksmali</code> 转换成 smali 指令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">java -jar baksmali-2.4.0.jar disassemble classes.dex<br></code></pre></div></td></tr></table></figure><p><code>Hello.say(String)</code> 对应的 smali 代码是这样的</p><p><code>synchronized</code> 代码块被两条指令包裹：<code>monitor-enter</code> 和 <code>monitor-exit</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">.method public say(Ljava/lang/String;)V<br>    .registers 5<br>    .param p1, <span class="hljs-string">&quot;msg&quot;</span>    <span class="hljs-comment"># Ljava/lang/String;</span><br><br>    .line 8<br><span class="hljs-comment"># 本地变量寄存器 v0 被赋予 Hello.lock</span><br>    iget-object v0, p0, Lcom/example/myapplication/Hello;-&gt;lock:Ljava/lang/Object;<br><br><span class="hljs-comment"># 重点</span><br>    monitor-enter v0<br><br>    .line 9<br>    :try_start_3<br>    sget-object v1, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;<br><br>    if-eqz p1, :cond_9<br><br>    move-object v2, p1<br><br>    goto :goto_b<br><br>    :cond_9<br>    const-string v2, <span class="hljs-string">&quot;null&quot;</span><br><br>    :goto_b<br>    invoke-virtual &#123;v1, v2&#125;, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V<br><br>    .line 10<br><span class="hljs-comment"># 重点</span><br>    monitor-exit v0<br><br>    .line 11<br>    return-void<br><br>    .line 10<br>    :catchall_10<br>    move-exception v1<br><br>    monitor-exit v0<br>    :try_end_12<br>    .catchall &#123;:try_start_3 .. :try_end_12&#125; :catchall_10<br><br>    throw v1<br>.end method<br></code></pre></div></td></tr></table></figure><h2 id="对象锁的概念"><a href="#对象锁的概念" class="headerlink" title="对象锁的概念"></a>对象锁的概念</h2><p>在进一步分析代码之前，先要了解下 java 对象锁的一些背景知识（from <a href="https://blog.csdn.net/fan1865221/article/details/96338419">JAVA锁的膨胀过程</a>）</p><p>java 对象锁会有一个膨胀加码的过程：无锁 → 偏向锁 → 轻量级锁 → 重量级锁</p><ul><li><strong>无锁</strong></li><li><strong>偏向锁，</strong>为了在无多线程竞争的情况下尽量减少不必须要的轻量级锁执行路径。当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。</li><li><strong>轻量级锁，</strong>在多线程竞争不激烈的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。偏向锁是认为环境中不存在竞争情况，而轻量级锁则是认为环境中不存在竞争或者竞争不激烈，所以轻量级锁一般都只会有少数几个线程竞争锁对象，其他线程只需要稍微等待（自旋）下就可以获取锁，但是自旋次数有限制，如果自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</li><li><strong>重量级锁，</strong>当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。重量级锁通过操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源，导致性能低下。</li></ul><h2 id="LockWord"><a href="#LockWord" class="headerlink" title="LockWord"></a>LockWord</h2><p>先了解一个结构<code>LockWord</code> ，它其实是一个 <code>uint32_t</code>，低 16 bits 保存持有锁的 thread id，后续 12 bits 保存锁的个数</p><p>它是 <code>Object</code> 的成员变量 <code>monitor_</code>，所以每个 java 对象都可以作为锁使用</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> LockWord <span class="hljs-title">FromThinLockId</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> thread_id, <span class="hljs-keyword">uint32_t</span> count, <span class="hljs-keyword">uint32_t</span> gc_state)</span> </span>&#123;<br>    <span class="hljs-built_in">CHECK_LE</span>(thread_id, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(kThinLockMaxOwner));<br>    <span class="hljs-built_in">CHECK_LE</span>(count, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(kThinLockMaxCount));<br>    <span class="hljs-comment">// DCHECK_EQ(gc_bits &amp; kGCStateMaskToggled, 0U);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">LockWord</span>((thread_id &lt;&lt; kThinLockOwnerShift) |<br>                    (count &lt;&lt; kThinLockCountShift) |<br>                    (gc_state &lt;&lt; kGCStateShift) |<br>                    (kStateThinOrUnlocked &lt;&lt; kStateShift));<br>&#125;<br><br><span class="hljs-comment">// C++ mirror of java.lang.Object</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MANAGED</span> <span class="hljs-title">LOCKABLE</span> <span class="hljs-title">Object</span> &#123;</span><br><span class="hljs-comment">// Monitor and hash code information.</span><br><span class="hljs-keyword">uint32_t</span> monitor_;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><p>ART 使用 <code>Mutex</code> 作为互斥量的实现（lock &amp; unlock），它根据宏 <code>ART_USE_FUTEXES</code> 决定是使用 <code>futex</code> 还是 <code>mutex</code></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// art/runtime/base/mutex.cc</span><br><br><span class="hljs-comment">// 获取排它锁</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Mutex::ExclusiveLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!recursive_ || !<span class="hljs-built_in">IsExclusiveHeld</span>(self)) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>    <span class="hljs-keyword">bool</span> done = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-comment">// Mutex::state_and_contenders_ 是 AtomicInteger</span><br>      <span class="hljs-comment">// 最低 1 bit 表示互斥量是否被持有（1 - 持有，0 - 未持有），其余高位的 bits 表示在此互斥量上挂起的线程数量</span><br>      <span class="hljs-keyword">int32_t</span> cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>      <span class="hljs-comment">// 锁没有被取走，立刻获得锁（cas）</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>((cur_state &amp; kHeldMask) == <span class="hljs-number">0</span>) <span class="hljs-comment">/* lock not held */</span>) &#123;<br>        done = state_and_contenders_.<span class="hljs-built_in">CompareAndSetWeakAcquire</span>(cur_state, cur_state | kHeldMask);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br><br>        <span class="hljs-comment">// 否则将挂起线程的数量加一，并用 futex 挂起当前线程</span><br>        ScopedContentionRecorder <span class="hljs-built_in">scr</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">SafeGetTid</span>(self), <span class="hljs-built_in">GetExclusiveOwnerTid</span>());<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WaitBrieflyFor</span>(&amp;state_and_contenders_, self, [](<span class="hljs-keyword">int32_t</span> v) &#123; <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (v &amp; kHeldMask) == <span class="hljs-number">0</span>; &#125;)) &#123;<br>          <span class="hljs-comment">// Increment contender count. We can&#x27;t create enough threads for this to overflow.</span><br>          <span class="hljs-built_in">increment_contenders</span>();<br>          <span class="hljs-comment">// Make cur_state again reflect the expected value of state_and_contenders.</span><br>          cur_state += kContenderIncrement;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(should_respond_to_empty_checkpoint_request_)) &#123;<br>            self-&gt;<span class="hljs-built_in">CheckEmptyCheckpointFromMutex</span>();<br>          &#125;<br>          <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">futex</span>(state_and_contenders_.<span class="hljs-built_in">Address</span>(), FUTEX_WAIT_PRIVATE, cur_state, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-keyword">if</span> ((errno != EAGAIN) &amp;&amp; (errno != EINTR)) &#123;<br>                <span class="hljs-built_in">PLOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;futex wait failed for &quot;</span> &lt;&lt; name_;<br>              &#125;<br>            &#125;<br>            <span class="hljs-built_in">SleepIfRuntimeDeleted</span>(self);<br>            <span class="hljs-comment">// Retry until not held. In heavy contention situations we otherwise get redundant</span><br>            <span class="hljs-comment">// futex wakeups as a result of repeatedly decrementing and incrementing contenders.</span><br>            cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>          &#125; <span class="hljs-keyword">while</span> ((cur_state &amp; kHeldMask) != <span class="hljs-number">0</span>);<br>          <span class="hljs-built_in">decrement_contenders</span>();<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!done);<br>    <span class="hljs-comment">// Confirm that lock is now held.</span><br>    <span class="hljs-built_in">DCHECK_NE</span>(state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) &amp; kHeldMask, <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><br>    <span class="hljs-comment">// 使用 pthread_mutex_lock 加锁</span><br>    <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_mutex_lock, (&amp;mutex_));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// exclusive_owner_ 记下获得排他锁的 thread id</span><br>    exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">SafeGetTid</span>(self), std::memory_order_relaxed);<br>    <span class="hljs-built_in">RegisterAsLocked</span>(self);<br>  &#125;<br>  recursion_count_++;<br>&#125;<br><br><span class="hljs-comment">// tryLock 方法</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Mutex::ExclusiveTryLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!recursive_ || !<span class="hljs-built_in">IsExclusiveHeld</span>(self)) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>    <span class="hljs-keyword">bool</span> done = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br><br>      <span class="hljs-comment">// 使用 futex 的情况下，利用一个 AtomicInteger 的最低 1 bit 表示锁有没被借出，一个 cas 操作即可</span><br>      <span class="hljs-keyword">int32_t</span> cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>      <span class="hljs-keyword">if</span> ((cur_state &amp; kHeldMask) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Change state to held and impose load/store ordering appropriate for lock acquisition.</span><br>        done = state_and_contenders_.<span class="hljs-built_in">CompareAndSetWeakAcquire</span>(cur_state, cur_state | kHeldMask);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!done);<br>    <span class="hljs-built_in">DCHECK_NE</span>(state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed) &amp; kHeldMask, <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><br>    <span class="hljs-comment">// mutex</span><br>    <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">pthread_mutex_trylock</span>(&amp;mutex_);<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// exclusive_owner_ 记下获得锁的 thread id</span><br>    <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">GetExclusiveOwnerTid</span>(), <span class="hljs-number">0</span>);<br>    exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">SafeGetTid</span>(self), std::memory_order_relaxed);<br>    <span class="hljs-built_in">RegisterAsLocked</span>(self);<br>  &#125;<br>  recursion_count_++;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 也是 tryLock 方法，特别的是它会自旋一小会</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Mutex::ExclusiveTryLockWithSpinning</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-comment">// Spin a small number of times, since this affects our ability to respond to suspension</span><br>  <span class="hljs-comment">// requests. We spin repeatedly only if the mutex repeatedly becomes available and unavailable</span><br>  <span class="hljs-comment">// in rapid succession, and then we will typically not spin for the maximal period.</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> kMaxSpins = <span class="hljs-number">5</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; kMaxSpins; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ExclusiveTryLock</span>(self)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">WaitBrieflyFor</span>(&amp;state_and_contenders_, self,<br>            [](<span class="hljs-keyword">int32_t</span> v) &#123; <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (v &amp; kHeldMask) == <span class="hljs-number">0</span>; &#125;)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ExclusiveTryLock</span>(self);<br>&#125;<br><br><span class="hljs-comment">// 释放排它锁</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Mutex::ExclusiveUnlock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  recursion_count_--;<br>  <span class="hljs-keyword">if</span> (!recursive_ || recursion_count_ == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">RegisterAsUnlocked</span>(self);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>    <span class="hljs-keyword">bool</span> done = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br><br>      <span class="hljs-comment">// 使用 cas 将 state_and_contenders_ 最低 1 bit 置零（表示锁没被借出）</span><br>      <span class="hljs-keyword">int32_t</span> cur_state = state_and_contenders_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>((cur_state &amp; kHeldMask) != <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">// We&#x27;re no longer the owner.</span><br>        exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* pid */</span>, std::memory_order_relaxed);<br>        <span class="hljs-comment">// Change state to not held and impose load/store ordering appropriate for lock release.</span><br>        <span class="hljs-keyword">uint32_t</span> new_state = cur_state &amp; ~kHeldMask;  <span class="hljs-comment">// Same number of contenders.</span><br>        done = state_and_contenders_.<span class="hljs-built_in">CompareAndSetWeakRelease</span>(cur_state, new_state);<br><br>        <span class="hljs-comment">// state_and_contenders_ 不为零表示仍有线程在锁上挂起，用 futex 让系统唤醒其中一个</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>(done)) &#123;  <span class="hljs-comment">// Spurious fail or waiters changed ?</span><br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UNLIKELY</span>(new_state != <span class="hljs-number">0</span>) <span class="hljs-comment">/* have contenders */</span>) &#123;<br>            <span class="hljs-built_in">futex</span>(state_and_contenders_.<span class="hljs-built_in">Address</span>(), FUTEX_WAKE_PRIVATE, kWakeOne,<br>                  <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<br>          &#125;<br>          <span class="hljs-comment">// We only do a futex wait after incrementing contenders and verifying the lock was</span><br>          <span class="hljs-comment">// still held. If we didn&#x27;t see waiters, then there couldn&#x27;t have been any futexes</span><br>          <span class="hljs-comment">// waiting on this lock when we did the CAS. New arrivals after that cannot wait for us,</span><br>          <span class="hljs-comment">// since the futex wait call would see the lock available and immediately return.</span><br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 异常情况...</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!done);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><br>    <span class="hljs-comment">// mutex</span><br>    exclusive_owner_.<span class="hljs-built_in">store</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* pid */</span>, std::memory_order_relaxed);<br>    <span class="hljs-built_in">CHECK_MUTEX_CALL</span>(pthread_mutex_unlock, (&amp;mutex_));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Unlock 等同于 ExclusiveUnlock</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(Thread* self)</span> <span class="hljs-title">RELEASE</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-built_in">ExclusiveUnlock</span>(self); &#125;<br></code></pre></div></td></tr></table></figure><h2 id="monitor-enter-指令"><a href="#monitor-enter-指令" class="headerlink" title="monitor-enter 指令"></a><code>monitor-enter</code> 指令</h2><h3 id="无锁、偏向锁和轻量级锁"><a href="#无锁、偏向锁和轻量级锁" class="headerlink" title="无锁、偏向锁和轻量级锁"></a>无锁、偏向锁和轻量级锁</h3><p>进入临界区，尝试获得锁</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 在 cs.android.com 找到的相关性很高的方法，可能不是指令 monitor-enter 直接调用的方法，但最终应该会走到这里来</span><br><span class="hljs-comment">// platform/superproject/art/runtime/mirror/object-inl.h</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ObjPtr&lt;mirror::Object&gt; <span class="hljs-title">Object::MonitorEnter</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> Monitor::<span class="hljs-built_in">MonitorEnter</span>(self, <span class="hljs-keyword">this</span>, <span class="hljs-comment">/*trylock=*/</span><span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-function">ObjPtr&lt;mirror::Object&gt; <span class="hljs-title">Monitor::MonitorEnter</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj, <span class="hljs-keyword">bool</span> trylock)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">DCHECK</span>(obj != <span class="hljs-literal">nullptr</span>);<br>  self-&gt;<span class="hljs-built_in">AssertThreadSuspensionIsAllowable</span>();<br>  obj = <span class="hljs-built_in">FakeLock</span>(obj);<br>  <span class="hljs-keyword">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();<br>  <span class="hljs-keyword">size_t</span> contention_count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> kExtraSpinIters = <span class="hljs-number">100</span>;<br>  <span class="hljs-function">StackHandleScope&lt;1&gt; <span class="hljs-title">hs</span><span class="hljs-params">(self)</span></span>;<br>  <span class="hljs-function">Handle&lt;mirror::Object&gt; <span class="hljs-title">h_obj</span><span class="hljs-params">(hs.NewHandle(obj))</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !ART_USE_FUTEXES</span><br>  <span class="hljs-comment">// In this case we cannot inflate an unowned monitor, so we sometimes defer inflation.</span><br>  <span class="hljs-keyword">bool</span> should_inflate = <span class="hljs-literal">false</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    LockWord lock_word = h_obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;<br><br>      <span class="hljs-comment">// 无锁的情况下，升级为偏向锁（thin lock）</span><br>      <span class="hljs-comment">// 偏向锁记录下 thread id 和锁的个数 0，通过 cas 记录在 Object.monitor_</span><br>      <span class="hljs-keyword">case</span> LockWord::kUnlocked: &#123;<br>        <span class="hljs-function">LockWord <span class="hljs-title">thin_locked</span><span class="hljs-params">(LockWord::FromThinLockId(thread_id, <span class="hljs-number">0</span>, lock_word.GCState()))</span></span>;<br>        <span class="hljs-keyword">if</span> (h_obj-&gt;<span class="hljs-built_in">CasLockWord</span>(lock_word, thin_locked, CASMode::kWeak, std::memory_order_acquire)) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !ART_USE_FUTEXES</span><br>          <span class="hljs-keyword">if</span> (should_inflate) &#123;<br>            <span class="hljs-built_in">InflateThinLocked</span>(self, h_obj, lock_word, <span class="hljs-number">0</span>);<br>          &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>          <span class="hljs-built_in">AtraceMonitorLock</span>(self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-comment">/* is_wait= */</span> <span class="hljs-literal">false</span>);<br>          <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span><br>        &#125;<br>        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Go again.</span><br>      &#125;<br><br>      <span class="hljs-comment">// 偏向锁，而且当前线程跟偏向锁里记录的线程是同一个线程</span><br>      <span class="hljs-comment">// 那么只需把偏向锁里的锁个数加一即可，依然使用 cas 保存在 Object.monitor_</span><br>      <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;<br>        <span class="hljs-keyword">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();<br>        <span class="hljs-keyword">if</span> (owner_thread_id == thread_id) &#123;<br>          <span class="hljs-comment">// No ordering required for initial lockword read.</span><br>          <span class="hljs-comment">// We own the lock, increase the recursion count.</span><br>          <span class="hljs-keyword">uint32_t</span> new_count = lock_word.<span class="hljs-built_in">ThinLockCount</span>() + <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LIKELY</span>(new_count &lt;= LockWord::kThinLockMaxCount)) &#123;<br>            <span class="hljs-function">LockWord <span class="hljs-title">thin_locked</span><span class="hljs-params">(LockWord::FromThinLockId(thread_id,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                          new_count,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                          lock_word.GCState()))</span></span>;<br>            <span class="hljs-comment">// 重新设置偏向锁，一个选择用 cas 原子操作符，另一个选择没用，不明这样区分的意义</span><br>            <span class="hljs-comment">// Only this thread pays attention to the count. Thus there is no need for stronger</span><br>            <span class="hljs-comment">// than relaxed memory ordering.</span><br>            <span class="hljs-keyword">if</span> (!kUseReadBarrier) &#123;<br>              h_obj-&gt;<span class="hljs-built_in">SetLockWord</span>(thin_locked, <span class="hljs-comment">/* as_volatile= */</span> <span class="hljs-literal">false</span>);<br>              <span class="hljs-built_in">AtraceMonitorLock</span>(self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-comment">/* is_wait= */</span> <span class="hljs-literal">false</span>);<br>              <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// Use CAS to preserve the read barrier state.</span><br>              <span class="hljs-keyword">if</span> (h_obj-&gt;<span class="hljs-built_in">CasLockWord</span>(lock_word,<br>                                     thin_locked,<br>                                     CASMode::kWeak,<br>                                     std::memory_order_relaxed)) &#123;<br>                <span class="hljs-built_in">AtraceMonitorLock</span>(self, h_obj.<span class="hljs-built_in">Get</span>(), <span class="hljs-comment">/* is_wait= */</span> <span class="hljs-literal">false</span>);<br>                <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span><br>              &#125;<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Go again.</span><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            <span class="hljs-comment">// 当前线程持有偏向锁，但锁的个数超过阈值 kThinLockMaxCount</span><br>            <span class="hljs-comment">// 那么将偏向锁（thin lock）升级为重量级锁（fat lock）</span><br>            <span class="hljs-comment">// We&#x27;d overflow the recursion count, so inflate the monitor.</span><br>            <span class="hljs-built_in">InflateThinLocked</span>(self, h_obj, lock_word, <span class="hljs-number">0</span>);<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>          <span class="hljs-comment">// 持有偏向锁的线程不是当前线程，此时的 thin lock 对应上文的轻量级锁</span><br>          <span class="hljs-comment">// 也就是说轻量级锁是这么一种情况：一个线程持有偏向锁，遇到了另一个线程的争抢</span><br>          <span class="hljs-comment">// 争抢的线程在这里自旋（spin），contention_count 表示自旋的次数</span><br>          <span class="hljs-comment">// 1. 如果自旋次数 &lt;= kExtraSpinIters，那么继续在外一层的 while 循环里自旋</span><br>          <span class="hljs-comment">// 2. 如果自旋次数 &lt; kExtraSpinIters，争抢线程让渡 CPU 给优先级更高的线程，并将自己排到 CPU 调度队列的队尾（sched_yield），相当于优化的自旋</span><br>          <span class="hljs-comment">// 3. 最后将轻量级锁膨胀为重量级锁</span><br>          <span class="hljs-keyword">if</span> (trylock) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>          &#125;<br>          contention_count++;<br>          Runtime* runtime = Runtime::<span class="hljs-built_in">Current</span>();<br>          <span class="hljs-keyword">if</span> (contention_count<br>              &lt;= kExtraSpinIters + runtime-&gt;<span class="hljs-built_in">GetMaxSpinsBeforeThinLockInflation</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (contention_count &gt; kExtraSpinIters) &#123;<br>              <span class="hljs-built_in">sched_yield</span>();<br>            &#125;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>            contention_count = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// No ordering required for initial lockword read. Install rereads it anyway.</span><br>            <span class="hljs-built_in">InflateThinLocked</span>(self, h_obj, lock_word, <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>            <span class="hljs-comment">// Can&#x27;t inflate from non-owning thread. Keep waiting. Bad for power, but this code</span><br>            <span class="hljs-comment">// isn&#x27;t used on-device.</span><br>            should_inflate = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">usleep</span>(<span class="hljs-number">10</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>          &#125;<br>        &#125;<br>        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Start from the beginning.</span><br>      &#125;<br><br>      <span class="hljs-comment">// 重量级锁的情况下会挂起当前线程，在下一节分析</span><br>      <span class="hljs-keyword">case</span> LockWord::kFatLocked: &#123;<br>        std::<span class="hljs-built_in">atomic_thread_fence</span>(std::memory_order_acquire);<br>        Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();<br>        <span class="hljs-keyword">if</span> (trylock) &#123;<br>          <span class="hljs-keyword">return</span> mon-&gt;<span class="hljs-built_in">TryLock</span>(self) ? h_obj.<span class="hljs-built_in">Get</span>() : <span class="hljs-literal">nullptr</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          mon-&gt;<span class="hljs-built_in">Lock</span>(self);<br>          <span class="hljs-keyword">return</span> h_obj.<span class="hljs-built_in">Get</span>();  <span class="hljs-comment">// Success!</span><br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// 不清楚这个条件</span><br>      <span class="hljs-keyword">case</span> LockWord::kHashCode:<br>        <span class="hljs-built_in">Inflate</span>(self, <span class="hljs-literal">nullptr</span>, h_obj.<span class="hljs-built_in">Get</span>(), lock_word.<span class="hljs-built_in">GetHashCode</span>());<br>        <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Start from the beginning.</span><br>      <span class="hljs-keyword">default</span>: &#123;<br>        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();<br>        <span class="hljs-built_in">UNREACHABLE</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="锁膨胀的过程（inflate）"><a href="#锁膨胀的过程（inflate）" class="headerlink" title="锁膨胀的过程（inflate）"></a>锁膨胀的过程（inflate）</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// thin lock 膨胀至重量级锁（fat lock）的过程</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::InflateThinLocked</span><span class="hljs-params">(Thread* self, Handle&lt;mirror::Object&gt; obj, LockWord lock_word, <span class="hljs-keyword">uint32_t</span> hash_code)</span> </span>&#123;<br>  <span class="hljs-comment">// 当前线程持有此偏向锁的情况（由于锁个数超过阈值导致膨胀）</span><br>  <span class="hljs-comment">// 升级到重量级锁（fat lock）</span><br>  <span class="hljs-built_in">DCHECK_EQ</span>(lock_word.<span class="hljs-built_in">GetState</span>(), LockWord::kThinLocked);<br>  <span class="hljs-keyword">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();<br>  <span class="hljs-keyword">if</span> (owner_thread_id == self-&gt;<span class="hljs-built_in">GetThreadId</span>()) &#123;<br>    <span class="hljs-comment">// We own the monitor, we can easily inflate it.</span><br>    <span class="hljs-built_in">Inflate</span>(self, self, obj.<span class="hljs-built_in">Get</span>(), hash_code);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br><br>    <span class="hljs-comment">// 当前线程不持有此偏向锁，出现争抢（此时对应轻量级锁）</span><br>    <span class="hljs-comment">// 挂起持有偏向锁的线程，将轻量级锁膨胀为重量级锁（fat lock），然后恢复线程</span><br>    ThreadList* thread_list = Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetThreadList</span>();<br>    <span class="hljs-comment">// Suspend the owner, inflate. First change to blocked and give up mutator_lock_.</span><br>    self-&gt;<span class="hljs-built_in">SetMonitorEnterObject</span>(obj.<span class="hljs-built_in">Get</span>());<br>    <span class="hljs-keyword">bool</span> timed_out;<br>    Thread* owner;<br>    &#123;<br>      <span class="hljs-function">ScopedThreadSuspension <span class="hljs-title">sts</span><span class="hljs-params">(self, kWaitingForLockInflation)</span></span>;<br>      owner = thread_list-&gt;<span class="hljs-built_in">SuspendThreadByThreadId</span>(owner_thread_id, SuspendReason::kInternal, &amp;timed_out);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (owner != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-comment">// We succeeded in suspending the thread, check the lock&#x27;s status didn&#x27;t change.</span><br>      lock_word = obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);<br>      <span class="hljs-keyword">if</span> (lock_word.<span class="hljs-built_in">GetState</span>() == LockWord::kThinLocked &amp;&amp;<br>          lock_word.<span class="hljs-built_in">ThinLockOwner</span>() == owner_thread_id) &#123;<br>        <span class="hljs-comment">// Go ahead and inflate the lock.</span><br>        <span class="hljs-built_in">Inflate</span>(self, owner, obj.<span class="hljs-built_in">Get</span>(), hash_code);<br>      &#125;<br>      <span class="hljs-keyword">bool</span> resumed = thread_list-&gt;<span class="hljs-built_in">Resume</span>(owner, SuspendReason::kInternal);<br>      <span class="hljs-built_in">DCHECK</span>(resumed);<br>    &#125;<br>    self-&gt;<span class="hljs-built_in">SetMonitorEnterObject</span>(<span class="hljs-literal">nullptr</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体的膨胀过程</span><br><span class="hljs-comment">// 膨胀到 fat lock 后多个一个概念 Monitor</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::Inflate</span><span class="hljs-params">(Thread* self, Thread* owner, ObjPtr&lt;mirror::Object&gt; obj, <span class="hljs-keyword">int32_t</span> hash_code)</span> </span>&#123;<br>  <span class="hljs-comment">// Allocate and acquire a new monitor.</span><br>  Monitor* m = MonitorPool::<span class="hljs-built_in">CreateMonitor</span>(self, owner, obj, hash_code);<br>  <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">Install</span>(self)) &#123;<br>    Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetMonitorList</span>()-&gt;<span class="hljs-built_in">Add</span>(m);<br>    <span class="hljs-built_in">CHECK_EQ</span>(obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>).<span class="hljs-built_in">GetState</span>(), LockWord::kFatLocked);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    MonitorPool::<span class="hljs-built_in">ReleaseMonitor</span>(self, m);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// fat lock 在这里被设置到 Object.monitor</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Monitor::Install</span><span class="hljs-params">(Thread* self)</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;<br>  Thread* owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>  <span class="hljs-built_in">CHECK</span>(owner == <span class="hljs-literal">nullptr</span> || owner == self || (ART_USE_FUTEXES &amp;&amp; owner-&gt;<span class="hljs-built_in">IsSuspended</span>()));<br>  <span class="hljs-function">LockWord <span class="hljs-title">lw</span><span class="hljs-params">(GetObject()-&gt;GetLockWord(<span class="hljs-literal">false</span>))</span></span>;<br>  <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (lw.<span class="hljs-built_in">GetState</span>()) &#123;<br>    <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;<br>      lock_count_ = lw.<span class="hljs-built_in">ThinLockCount</span>();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>      monitor_lock_.<span class="hljs-built_in">ExclusiveLockUncontendedFor</span>(owner);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>      monitor_lock_.<span class="hljs-built_in">ExclusiveLock</span>(owner);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>      <span class="hljs-function">LockWord <span class="hljs-title">fat</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, lw.GCState())</span></span>;<br>      <span class="hljs-comment">// Publish the updated lock word, which may race with other threads.</span><br>      <span class="hljs-keyword">bool</span> success = <span class="hljs-built_in">GetObject</span>()-&gt;<span class="hljs-built_in">CasLockWord</span>(lw, fat, CASMode::kWeak, std::memory_order_release);<br>      <span class="hljs-keyword">if</span> (success) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ATraceEnabled</span>()) &#123;<br>          <span class="hljs-built_in">SetLockingMethod</span>(owner);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ART_USE_FUTEXES</span><br>        monitor_lock_.<span class="hljs-built_in">ExclusiveUnlockUncontended</span>();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt;= lockCount; ++i) &#123;<br>          monitor_lock_.<span class="hljs-built_in">ExclusiveUnlock</span>(owner);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 上面说过，thin lock 的 LockWord 低 16 bits 是 thread id，然后是 12 bits 的锁个数</span><br><span class="hljs-comment">// 对于 fat lock，低 28 bits 是 monitor id</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">LockWord::LockWord</span><span class="hljs-params">(Monitor* mon, <span class="hljs-keyword">uint32_t</span> gc_state)</span></span><br><span class="hljs-function">    : value_(mon-&gt;GetMonitorId() | (gc_state &lt;&lt; kGCStateShift) | (kStateFat &lt;&lt; kStateShift)) &#123;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __LP64__</span><br>  <span class="hljs-built_in">DCHECK_ALIGNED</span>(mon, kMonitorIdAlignment);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  <span class="hljs-built_in">DCHECK_EQ</span>(<span class="hljs-built_in">FatLockMonitor</span>(), mon);<br>  <span class="hljs-built_in">DCHECK_LE</span>(mon-&gt;<span class="hljs-built_in">GetMonitorId</span>(), <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(kMaxMonitorId));<br>  <span class="hljs-built_in">CheckReadBarrierState</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Monitor-Lock-挂起线程"><a href="#Monitor-Lock-挂起线程" class="headerlink" title="Monitor::Lock 挂起线程"></a><code>Monitor::Lock</code> 挂起线程</h3><p>上面介绍的是对象锁，也就是把 <code>Object</code> 作为 <code>Lock</code> 使用，具体来说是 <code>Object.monitor</code> 的四种状态：无锁、偏向锁、轻量级锁和重量级锁</p><p>而 <code>Monitor::Lock</code> 实现的是在重量级锁状态下，「挂起」线程的过程，它包含了自旋、futex/mutex 系统调用</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;LockReason reason&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::Lock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-keyword">bool</span> called_monitors_callback = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 一小会的自旋</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TryLock</span>(self, <span class="hljs-comment">/*spin=*/</span> <span class="hljs-literal">true</span>)) &#123;<br>  <span class="hljs-comment">//... 挂起</span><br>  <span class="hljs-comment">// Acquire monitor_lock_ without mutator_lock_, expecting to block this time.</span><br>  <span class="hljs-comment">// We already tried spinning above. The shutdown procedure currently assumes we stop</span><br>  <span class="hljs-comment">// touching monitors shortly after we suspend, so don&#x27;t spin again here.</span><br>  monitor_lock_.<span class="hljs-built_in">ExclusiveLock</span>(self);<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">// 自己持有锁，锁加一；否则自旋一小会尝试加锁</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Monitor::TryLock</span><span class="hljs-params">(Thread* self, <span class="hljs-keyword">bool</span> spin)</span> </span>&#123;<br>  Thread *owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>  <span class="hljs-keyword">if</span> (owner == self) &#123;<br>    lock_count_++;<br>    <span class="hljs-built_in">CHECK_NE</span>(lock_count_, <span class="hljs-number">0u</span>);  <span class="hljs-comment">// Abort on overflow.</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">bool</span> success = spin ? monitor_lock_.<span class="hljs-built_in">ExclusiveTryLockWithSpinning</span>(self)<br>        : monitor_lock_.<span class="hljs-built_in">ExclusiveTryLock</span>(self);<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="monitor-exit-指令"><a href="#monitor-exit-指令" class="headerlink" title="monitor-exit 指令"></a><code>monitor-exit</code> 指令</h2><h3 id="偏向锁和轻量级锁"><a href="#偏向锁和轻量级锁" class="headerlink" title="偏向锁和轻量级锁"></a>偏向锁和轻量级锁</h3><p>退出临界区，释放锁</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// platform/superproject/art/runtime/mirror/object-inl.h</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Object::MonitorExit</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> Monitor::<span class="hljs-built_in">MonitorExit</span>(self, <span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Monitor::MonitorExit</span><span class="hljs-params">(Thread* self, ObjPtr&lt;mirror::Object&gt; obj)</span> </span>&#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    LockWord lock_word = obj-&gt;<span class="hljs-built_in">GetLockWord</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (lock_word.<span class="hljs-built_in">GetState</span>()) &#123;<br>      <span class="hljs-keyword">case</span> LockWord::kHashCode:<br>        <span class="hljs-comment">// Fall-through.</span><br><br>      <span class="hljs-comment">// 对象的锁并没有借出，抛出 java 异常</span><br>      <span class="hljs-keyword">case</span> LockWord::kUnlocked:<br>        <span class="hljs-built_in">FailedUnlock</span>(h_obj.<span class="hljs-built_in">Get</span>(), self-&gt;<span class="hljs-built_in">GetThreadId</span>(), <span class="hljs-number">0u</span>, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Failure.</span><br><br>      <span class="hljs-comment">// 当前线程并不拥有锁，抛出 java 异常</span><br>      <span class="hljs-keyword">case</span> LockWord::kThinLocked: &#123;<br>        <span class="hljs-keyword">uint32_t</span> thread_id = self-&gt;<span class="hljs-built_in">GetThreadId</span>();<br>        <span class="hljs-keyword">uint32_t</span> owner_thread_id = lock_word.<span class="hljs-built_in">ThinLockOwner</span>();<br>        <span class="hljs-keyword">if</span> (owner_thread_id != thread_id) &#123;<br>          <span class="hljs-built_in">FailedUnlock</span>(h_obj.<span class="hljs-built_in">Get</span>(), thread_id, owner_thread_id, <span class="hljs-literal">nullptr</span>);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Failure.</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>          <span class="hljs-comment">// 偏向锁，锁减一，如果锁为零则释放锁，最后写回 Object.monitor</span><br>          <span class="hljs-comment">// We own the lock, decrease the recursion count.</span><br>          LockWord new_lw = LockWord::<span class="hljs-built_in">Default</span>();<br>          <span class="hljs-keyword">if</span> (lock_word.<span class="hljs-built_in">ThinLockCount</span>() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">uint32_t</span> new_count = lock_word.<span class="hljs-built_in">ThinLockCount</span>() - <span class="hljs-number">1</span>;<br>            new_lw = LockWord::<span class="hljs-built_in">FromThinLockId</span>(thread_id, new_count, lock_word.<span class="hljs-built_in">GCState</span>());<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            new_lw = LockWord::<span class="hljs-built_in">FromDefault</span>(lock_word.<span class="hljs-built_in">GCState</span>());<br>          &#125;<br>          <span class="hljs-keyword">if</span> (!kUseReadBarrier) &#123;<br>            <span class="hljs-built_in">DCHECK_EQ</span>(new_lw.<span class="hljs-built_in">ReadBarrierState</span>(), <span class="hljs-number">0U</span>);<br>            h_obj-&gt;<span class="hljs-built_in">SetLockWord</span>(new_lw, <span class="hljs-literal">true</span>);<br>            <span class="hljs-built_in">AtraceMonitorUnlock</span>();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (h_obj-&gt;<span class="hljs-built_in">CasLockWord</span>(lock_word, new_lw, CASMode::kWeak, std::memory_order_release)) &#123;<br>              <span class="hljs-built_in">AtraceMonitorUnlock</span>();<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>          &#125;<br>          <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Go again.</span><br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// 释放重量级锁</span><br>      <span class="hljs-keyword">case</span> LockWord::kFatLocked: &#123;<br>        Monitor* mon = lock_word.<span class="hljs-built_in">FatLockMonitor</span>();<br>        <span class="hljs-keyword">return</span> mon-&gt;<span class="hljs-built_in">Unlock</span>(self);<br>      &#125;<br><br>      <span class="hljs-keyword">default</span>: &#123;<br>        <span class="hljs-built_in">LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Invalid monitor state &quot;</span> &lt;&lt; lock_word.<span class="hljs-built_in">GetState</span>();<br>        <span class="hljs-built_in">UNREACHABLE</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 当前线程持有此重量级锁，且锁为零，退出临界区导致释放锁并唤醒等待线程</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Monitor::Unlock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-built_in">DCHECK</span>(self != <span class="hljs-literal">nullptr</span>);<br>  Thread* owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>  <span class="hljs-keyword">if</span> (owner == self) &#123;<br>    <span class="hljs-comment">// We own the monitor, so nobody else can be in here.</span><br>    <span class="hljs-built_in">CheckLockOwnerRequest</span>(self);<br>    <span class="hljs-built_in">AtraceMonitorUnlock</span>();<br>    <span class="hljs-keyword">if</span> (lock_count_ == <span class="hljs-number">0</span>) &#123;<br>      owner_.<span class="hljs-built_in">store</span>(<span class="hljs-literal">nullptr</span>, std::memory_order_relaxed);<br>      <span class="hljs-built_in">SignalWaiterAndReleaseMonitorLock</span>(self);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      <span class="hljs-comment">// 当前线程持有此重量级锁，且锁不为零（重入）</span><br>      <span class="hljs-comment">// 退出临界区导致锁减一，但不释放锁</span><br>      --lock_count_;<br>      <span class="hljs-built_in">DCHECK</span>(monitor_lock_.<span class="hljs-built_in">IsExclusiveHeld</span>(self));<br>      <span class="hljs-built_in">DCHECK_EQ</span>(owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed), self);<br>      <span class="hljs-comment">// Keep monitor_lock_, but pretend we released it.</span><br>      <span class="hljs-built_in">FakeUnlockMonitorLock</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 当前线程不持有此重量级锁，抛出 java 异常</span><br>  <span class="hljs-comment">// We don&#x27;t own this, so we&#x27;re not allowed to unlock it.</span><br>  <span class="hljs-comment">// The JNI spec says that we should throw IllegalMonitorStateException in this case.</span><br>  <span class="hljs-keyword">uint32_t</span> owner_thread_id = <span class="hljs-number">0u</span>;<br>  &#123;<br>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *Locks::thread_list_lock_)</span></span>;<br>    owner = owner_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>    <span class="hljs-keyword">if</span> (owner != <span class="hljs-literal">nullptr</span>) &#123;<br>      owner_thread_id = owner-&gt;<span class="hljs-built_in">GetThreadId</span>();<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">FailedUnlock</span>(<span class="hljs-built_in">GetObject</span>(), self-&gt;<span class="hljs-built_in">GetThreadId</span>(), owner_thread_id, <span class="hljs-keyword">this</span>);<br>  <span class="hljs-comment">// Pretend to release monitor_lock_, which we should not.</span><br>  <span class="hljs-built_in">FakeUnlockMonitorLock</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 释放重量级锁</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Monitor::SignalWaiterAndReleaseMonitorLock</span><span class="hljs-params">(Thread* self)</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  monitor_lock_.<span class="hljs-built_in">Unlock</span>(self);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据上面的代码总结下 <code>synchronized</code> 加锁的流程：</p><ul><li>初始为无锁</li><li>线程 A 进入临界区获得锁，升级为偏向锁（thin lock），偏向锁记下线程 A 的 thread id 和初始锁个数 0</li><li>如果线程 A 重入临界区，锁个数加一；当锁个数超过阈值时，膨胀为重量级锁</li><li>如果在线程 A 持有偏向锁的情况下，线程 B 尝试进入临界区；那么线程 B 首先自旋一小会等待线程 A 释放锁，失败后将偏向锁膨胀为重量级锁，并在锁上挂起；这一过程称为轻量级锁</li><li>线程 A 持有重量级锁的情况下，其他线程尝试进入临界区，会在锁上挂起（futex/mutex）</li></ul><p>总结下 <code>synchronized</code> 和 <code>Lock</code> 的区别：</p><ul><li><code>synchronized</code> 使用 <code>Object</code> 作为锁，也即所有的 <code>Object</code> 都可以当做锁使用；但具体的 lock/unlock 逻辑是在 <code>Monitor</code> 实现的，严谨地说是 <code>Object</code> + <code>Monitor</code> = Lock</li><li>偏向锁和轻量级锁并没有使用 <code>Monitor</code>，而是用 cas，<code>Object::monitor</code> 和自旋实现排他性；直到重量级锁时才构造 <code>Monitor</code>；<code>Monitor</code> 除了扮演 Lock 的角色外，<a href="../../../../2021/02/11/wait-notify/">还扮演了 Condition 的角色</a>，所以一旦调用 Object.wait/Object.notify，就会立刻升级为重量级锁</li><li>Lock 用排队队列来组织挂起的线程，而且以 FIFO 的优先级排队；<code>synchronized</code> 没有组织挂起的线程，完全由 CPU 决定谁能获得锁，可能会发生「饥饿」问题</li><li>Lock 全靠 futex/mutex 阻塞线程，而 <code>synchronized</code> 先让线程自旋一会在陷入阻塞</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Art</category>
      
    </categories>
    
    
    <tags>
      
      <tag>synchronized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（三）利用 Lock 实现 Condition</title>
    <link href="/blog/2021/01/24/condition-by-lock/"/>
    <url>/blog/2021/01/24/condition-by-lock/</url>
    
    <content type="html"><![CDATA[<h2 id="Condition-简介"><a href="#Condition-简介" class="headerlink" title="Condition 简介"></a><code>Condition</code> 简介</h2><p><code>Condition</code> 主要有两类方法：</p><ul><li>await，释放锁并阻塞线程直到 signal 被调用，恢复后会重新获得锁</li><li>signal，唤醒阻塞在这个 <code>Condition</code> 上的一个或全部线程</li></ul><p>利用条件变量前需要先获得锁</p><p>所以 <code>Condition</code> 的所有方法都需要加锁</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">lock.lock();<br><span class="hljs-comment">// ...</span><br>condition.await();<br><span class="hljs-comment">// ...</span><br>lock.unlock();<br></code></pre></div></td></tr></table></figure><p><code>Condition</code> 的 await/signal 对标 <code>Object</code> 的 wait/notify，wait/notify 使用对象监视器实现的，而 await/signal 使用 <code>Lock</code> 实现的（<code>Lock</code> 对标 <code>synchronized</code> 关键字）</p><p><code>ConditionObject</code> 自己持有一个双向链表的排队队列 condition queue，所有阻塞在此条件变量上的线程都在此排队</p><p>被唤醒的线程会被转移到 AQS 队列尾部（又叫 sync queue）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter; <span class="hljs-comment">/** First node of condition queue. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;  <span class="hljs-comment">/** Last node of condition queue. */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>整个 await 大体就是以是否在 sync queue 为标识的循环，当节点转移到 sync queue 时表示线程被唤醒，跳出阻塞循环</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> ConditionObject.await() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// ... 在 condition queue 队尾添加一个 Node.CONDITION 类型的新节点（所有阻塞在此条件变量上的线程都在此排队）</span><br>    Node node = addConditionWaiter();<br>    <span class="hljs-comment">// 进入阻塞状态前需要释放锁，同时唤醒下一个等待锁的线程</span><br>    <span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br>    <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 进入阻塞</span><br>    <span class="hljs-comment">// 被唤醒的线程会从 condition queue 转移到 AQS 排队队列（又叫同步队列，sync queue）</span><br>    <span class="hljs-comment">// isOnSyncQueue 返回 true 表示此节点已被转移到 sync queue，跳出阻塞循环</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-comment">// await() 是可被中断的，awaitUninterruptibly() 不会被中断</span><br>        <span class="hljs-comment">// 线程恢复后，如果发生了中断，要跳出阻塞状态</span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 线程恢复后需要重新获得锁</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br><br><span class="hljs-keyword">private</span> Node ConditionObject.addConditionWaiter() &#123;<br>    Node t = lastWaiter;<br>    <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    &#125;<br>    Node node = <span class="hljs-keyword">new</span> Node(Node.CONDITION)<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>)<br>        firstWaiter = node;<br>    <span class="hljs-keyword">else</span><br>        t.nextWaiter = node;<br>    lastWaiter = node;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-keyword">int</span> AbstractQueuedSynchronizer.fullyRelease(Node node) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">int</span> savedState = getState();<br>        <span class="hljs-keyword">if</span> (release(savedState))<br>            <span class="hljs-keyword">return</span> savedState;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        node.waitStatus = Node.CANCELLED;<br>        <span class="hljs-keyword">throw</span> t;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">boolean</span> AbstractQueuedSynchronizer.release(<span class="hljs-keyword">int</span> arg) &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        Node h = head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">boolean</span> ReentrantLock.Sync.tryRelease(<span class="hljs-keyword">int</span> releases) &#123;<br>    <span class="hljs-keyword">int</span> c = getState() - releases;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-keyword">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="唤醒一个阻塞的线程（从队头节点开始）"><a href="#唤醒一个阻塞的线程（从队头节点开始）" class="headerlink" title="唤醒一个阻塞的线程（从队头节点开始）"></a>唤醒一个阻塞的线程（从队头节点开始）</h2><p>将在 condition queue 上节点转移到 sync queue 上</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 把 condition queue 第一个节点（等待最久的线程）从队列里移除，添加到 sync queue 并唤醒其线程</span><br><span class="hljs-keyword">void</span> ConditionObject.signal() &#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    Node first = firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)<br>        doSignal(first);<br>&#125;<br><br><span class="hljs-comment">// 从 condition queue 里移除</span><br><span class="hljs-keyword">void</span> ConditionObject.doSignal(Node first) &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>)<br>            lastWaiter = <span class="hljs-keyword">null</span>;<br>        first.nextWaiter = <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>             (first = firstWaiter) != <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-comment">// 插入至 sync queue 队尾并唤醒其线程</span><br><span class="hljs-keyword">boolean</span> ConditionObject.transferForSignal(Node node) &#123;<br>    <span class="hljs-keyword">if</span> (!node.compareAndSetWaitStatus(Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    Node p = enq(node);<br>    <span class="hljs-keyword">int</span> ws = p.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))<br>        LockSupport.unpark(node.thread);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>Node AbstractQueuedSynchronizer.enq(Node node) &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node oldTail = tail;<br>        <span class="hljs-keyword">if</span> (oldTail != <span class="hljs-keyword">null</span>) &#123;<br>            U.putObject(node, Node.PREV, oldTail);<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;<br>                oldTail.next = node;<br>                <span class="hljs-keyword">return</span> oldTail;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            initializeSyncQueue();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="唤醒全部线程"><a href="#唤醒全部线程" class="headerlink" title="唤醒全部线程"></a>唤醒全部线程</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 跟唤醒第一个线程时一样的：</span><br><span class="hljs-comment">// 将所有在 Condition 上排队的线程逐个从 Condition 排队队列里移除，添加到 AQS 队尾，并唤醒其线程</span><br><span class="hljs-keyword">void</span> ConditionObject.signalAll() &#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    Node first = firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)<br>        doSignalAll(first);<br>&#125;<br><br><span class="hljs-keyword">void</span> ConditionObject.doSignalAll(Node first) &#123;<br>    lastWaiter = firstWaiter = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        Node next = first.nextWaiter;<br>        first.nextWaiter = <span class="hljs-keyword">null</span>;<br>        transferForSignal(first);<br>        first = next;<br>    &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Art</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lock</tag>
      
      <tag>Condition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见面试题备忘</title>
    <link href="/blog/2021/01/19/reviews/"/>
    <url>/blog/2021/01/19/reviews/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li>观察者（Observer），<code>LiveData</code></li><li>单例（Singleton），double check</li><li>适配器（Adapter），<code>RecyclerView.Adapter</code></li><li>装饰器（Decorator），<code>ContextWrapper</code></li><li>代理模式（Proxy），例如 VPN、Retrofit</li><li>责任链（Chain of Responsibility），<code>OkHttp</code> 大体上就是个责任链模式</li><li>建造者（Builder）</li><li>工厂（Factory）</li></ul><p>代理模式强调不能直接访问一个对象，只能通过代理间接访问，不能直接访问的原因比如：权限校验、操作日志、RPC</p><p>装饰器模式强调增强对象的功能：把一个对象的功能拆分为几部分，在运行时按需组装</p><h2 id="实现-LRU"><a href="#实现-LRU" class="headerlink" title="实现 LRU"></a>实现 LRU</h2><p><code>map</code> + 双端链表，链尾是最近使用过的，链头是最久未使用的</p><ul><li><code>get(key)</code>，通过 <code>map</code> 可以在 O(1) 时间内找到 <code>value</code>，然后把 <code>value</code> 从双端链表中断开并移到链尾，双端链表的特性使得「断开」操作很容易实现</li><li><code>put(key, value)</code>，把 <code>value</code> 添加到链尾，当超过容量限制时，从链头逐个移除 <code>value</code> 直到满足容量限制</li></ul><h2 id="几个重要的排序算法"><a href="#几个重要的排序算法" class="headerlink" title="几个重要的排序算法"></a>几个重要的排序算法</h2><ul><li><p>归并排序 O(nlogn)<br><code>step</code> 从 1 逐步递增，合并两个长度为 <code>step</code> 的已排序区间，当 <code>step</code> &gt; length/2 时，已排序区间就等于整个数组<br>合并两个有序区间很简单，用「双指针法」即可</p></li><li><p>快速排序 O(nlogn)<br>双指针，一个在头一个在尾，取第一个元素为「基准」（挖出一个坑），从尾部找一个比「基准」小的填入坑，然后又从头部找一个比「基准」大的填入尾部的坑，循环往复直到双指针碰头，那么这个位置就是「基准」的位置<br>每一轮都可以找出一个元素的排序后的位置，从整体看，这个元素和它左右两块是已排序的<br>然后递归操作左右两块区间直到区间长度为 1</p></li><li><p>堆排序 O(nlogn)<br>利用「堆」这个特殊的数据结构来排序（大顶堆、小顶堆）<br>恰好堆也是用数组实现的，初始已排序区间的长度为 1，逐步扩大长度相当于逐个添加一个新元素到堆<br>添加一个新元素到堆，相当于添加到数组尾部，逻辑上看就是添加到二叉树叶子那层最左边，为了让堆继续满足性质，需要把新元素逐层地跟它的父节点比较：新节点大于父节点则交换（大顶堆，小顶堆则相反）<br>当已排序区间 == 数组时，整个数组就排好序了</p></li></ul><h2 id="五层网络"><a href="#五层网络" class="headerlink" title="五层网络"></a>五层网络</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>应用层</td><td>HTTP</td></tr><tr><td>传输层</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>IP 地址（替代 MAC 地址，形成网络），ARP（通过 IP 地址查询得到 MAC 地址）</td></tr><tr><td>链接层</td><td>以太网协议（Ethernet），帧（Frame），MAC 地址，广播（同一网络的所有计算机都会受到消息，它们比较帧的 MAC 地址和自己的 MAC 地址是否相同来决定是否接收）</td></tr><tr><td>物理层（实体层）</td><td></td></tr></tbody></table><h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><p>抽象类是对实体的抽象，而接口是对特征的抽象；所以 Java 类最多只能继承自一个抽象类，但却可是实现多个特征</p><h2 id="多线程同步的方法"><a href="#多线程同步的方法" class="headerlink" title="多线程同步的方法"></a>多线程同步的方法</h2><ul><li><code>synchronized</code></li><li><code>volatile</code></li><li><code>Lock</code> &amp; <code>Condition</code> &amp; <code>Atoimc</code></li></ul><h2 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a><code>HashMap</code> 和 <code>HashTable</code> 的区别</h2><ul><li>都是数组 + 链表的实现（链表是为了解决 hash 冲突）</li><li><code>HashTable</code> 是线程安全的（大多数方法都加了 <code>synchronized</code>），而 <code>HashMap</code> 不是</li><li><code>HashMap</code> 允许为 <code>null</code> 的 key 和 value，而 <code>HashTable</code> 则不允许</li><li><code>HashMap</code> 重算了 hash code：<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，而 <code>HashTable</code> 直接使用 <code>hashCode()</code></li></ul><h2 id="怎么解决-ANR-问题"><a href="#怎么解决-ANR-问题" class="headerlink" title="怎么解决 ANR 问题"></a>怎么解决 ANR 问题</h2><p>先把 <code>/data/anr/trace.txt</code> 拉下来，搜索包名定位到 app 进程那一段，找到 <code>main</code> 线程，看看主线程是不是出于异常状态（比如 <code>Blocked</code>、<code>Sleeping</code>）<br>如果主线程状态异常，那么查看主线程的调用堆栈，看看是哪段代码导致主线程进入异常状态<br>像 <code>Blocked</code> 有可能是锁导致的，能看到主线程被哪个锁阻塞，那个锁被哪个线程持有<br>有时候主线程没发现异常，看调用堆栈发现主线程正在执行 binder 相关操作，此时有可能是阻塞在这里（等待 binder 对面那端的响应）</p><p>还找不到问题，就在 logcat 里搜索 anr 找到 anr 相关日志，它会有一个 CPU 负载统计，如果 io 占比很大说明卡在 io 上了，继续往上找找看当时正在做什么文件操作，或者在 trace 文件里找找</p><h2 id="Double-Check-会有什么问题？"><a href="#Double-Check-会有什么问题？" class="headerlink" title="Double Check 会有什么问题？"></a>Double Check 会有什么问题？</h2><p><code>mSingleton = new Object();</code> 这行语句实际上会分解为多条 CPU 指令：</p><ol><li>为 <code>Object</code> 分配一块内存</li><li>初始化 <code>Object</code> 实例</li><li>把 <code>mSingleton</code> 指向这块内存</li></ol><p>但是「指令重排」可能导致第三部与第二部交换位置，也就是说把 <code>mSingleton</code> 指向了一块尚未初始化的内存区域；此时线程 B 在执行 <code>if (mSingleton == null)</code> 时就会发现 <code>mSingleton</code> 的确不为 null 并返回 <code>mSingleton</code>，从而导致程序异常（因为 <code>mSingleton</code> 指向的内存还没有初始化）</p><p>使用 <code>volatile</code> 修饰 <code>mSingleton</code> 即可，<code>volatile</code> 可以防止相关指令的重排</p><h2 id="IdleHandler-是怎么实现的？"><a href="#IdleHandler-是怎么实现的？" class="headerlink" title="IdleHandler 是怎么实现的？"></a><code>IdleHandler</code> 是怎么实现的？</h2><p>在 <code>MessageQueue.next</code> 里，当队列为空，或者还不到第一个消息的执行时间时（<code>Message</code> 是按照执行时间排序的），在 <code>MessageQueue.mIdleHandlers</code> 里的 <code>IdleHandler</code> 会被执行</p><h2 id="Retrofit-是怎么接口的？"><a href="#Retrofit-是怎么接口的？" class="headerlink" title="Retrofit 是怎么接口的？"></a>Retrofit 是怎么接口的？</h2><p>使用动态代理 <code>Proxy.newProxyInstance</code>，其核心是方法拦截</p><p>在运行时创建一个实现了所选接口的类，这个类的构造函数需要一个 <code>InvocationHandler</code>，接口所有的方法调用都会代理至 <code>InvocationHandler</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T Retrofit.create(<span class="hljs-keyword">final</span> Class&lt;T&gt; service) &#123;<br>  Utils.validateServiceInterface(service);<br>  <span class="hljs-keyword">if</span> (validateEagerly) &#123;<br>    eagerlyValidateMethods(service);<br>  &#125;<br>  <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,<br>      <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Platform platform = Platform.get();<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] emptyArgs = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>];<br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, <span class="hljs-meta">@Nullable</span> Object[] args)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>          <span class="hljs-comment">// If the method is a method from Object then defer to normal invocation.</span><br>          <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;<br>            <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-keyword">this</span>, args);<br>          &#125;<br>          <span class="hljs-keyword">if</span> (platform.isDefaultMethod(method)) &#123;<br>            <span class="hljs-keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);<br>          &#125;<br>          <span class="hljs-keyword">return</span> loadServiceMethod(method).invoke(args != <span class="hljs-keyword">null</span> ? args : emptyArgs);<br>        &#125;<br>      &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Activity-重建的过程"><a href="#Activity-重建的过程" class="headerlink" title="Activity 重建的过程"></a><code>Activity</code> 重建的过程</h2><p>旧的 <code>Activity</code> 走向死亡（<code>onPause</code> -&gt; <code>onStop</code> -&gt; <code>onDestroy</code>），新的 <code>Activity</code> 进入（<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ActivityThread.handleRelaunchActivity(...)<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRelaunchActivityInner</span><span class="hljs-params">(ActivityClientRecord r, <span class="hljs-keyword">int</span> configChanges,</span></span><br><span class="hljs-function"><span class="hljs-params">        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingIntents,</span></span><br><span class="hljs-function"><span class="hljs-params">        PendingTransactionActions pendingActions, <span class="hljs-keyword">boolean</span> startsNotResumed,</span></span><br><span class="hljs-function"><span class="hljs-params">        Configuration overrideConfig, String reason)</span> </span>&#123;<br>    <span class="hljs-comment">// Preserve last used intent, it may be set from Activity#setIntent().</span><br>    <span class="hljs-keyword">final</span> Intent customIntent = r.activity.mIntent;<br><br>    <span class="hljs-comment">// 旧的 Activity 走向死亡（销毁）</span><br>    <span class="hljs-comment">// Need to ensure state is saved.</span><br>    <span class="hljs-keyword">if</span> (!r.paused) &#123;<br>        performPauseActivity(r, <span class="hljs-keyword">false</span>, reason, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* pendingActions */</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!r.stopped) &#123;<br>        callActivityOnStop(r, <span class="hljs-keyword">true</span> <span class="hljs-comment">/* saveState */</span>, reason);<br>    <br>    handleDestroyActivity(r.token, <span class="hljs-keyword">false</span>, configChanges, <span class="hljs-keyword">true</span>, reason)<br>    r.activity = <span class="hljs-keyword">null</span>;<br>    r.window = <span class="hljs-keyword">null</span>;<br>    r.hideForNow = <span class="hljs-keyword">false</span>;<br>    r.nextIdle = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// Merge any pending results and pending intents; don&#x27;t just replace them</span><br>    <span class="hljs-keyword">if</span> (pendingResults != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (r.pendingResults == <span class="hljs-keyword">null</span>) &#123;<br>            r.pendingResults = pendingResults;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r.pendingResults.addAll(pendingResults);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pendingIntents != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (r.pendingIntents == <span class="hljs-keyword">null</span>) &#123;<br>            r.pendingIntents = pendingIntents;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r.pendingIntents.addAll(pendingIntents);<br>        &#125;<br>    &#125;<br>    r.startsNotResumed = startsNotResumed;<br>    r.overrideConfig = overrideConfig<br>    <span class="hljs-comment">// 走创建新 Activity 的流程</span><br>    handleLaunchActivity(r, pendingActions, customIntent);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="ViewModel-和-Fragment-会随之重建吗"><a href="#ViewModel-和-Fragment-会随之重建吗" class="headerlink" title="ViewModel 和 Fragment 会随之重建吗?"></a><code>ViewModel</code> 和 <code>Fragment</code> 会随之重建吗?</h3><p>不会，在 <code>Activity.onStop</code> 之后 <code>Activity.onDestory</code> 之前，<code>FragmentActivity</code> 将 <code>Fragment</code> 和 <code>ViewModelStore</code> 借由方法 <code>onRetainNonConfigurationInstance</code> 传递给 <code>ActivityClientRecord</code> 保存<br>并在 <code>Activity.attach</code> 被重新赋值给新的 <code>Activity</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object FragmentActivity.onRetainNonConfigurationInstance() &#123;<br>    Object custom = onRetainCustomNonConfigurationInstance()<br>    FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig()<br>    <span class="hljs-keyword">if</span> (fragments == <span class="hljs-keyword">null</span> &amp;&amp; mViewModelStore == <span class="hljs-keyword">null</span> &amp;&amp; custom == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-comment">// 在旧的 Activity 销毁前，保存 ViewModel 和 Fragment</span><br>    NonConfigurationInstances nci = <span class="hljs-keyword">new</span> NonConfigurationInstances();<br>    nci.custom = custom;<br>    nci.viewModelStore = mViewModelStore;<br>    nci.fragments = fragments;<br>    <span class="hljs-keyword">return</span> nci;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;<br>    mFragments.attachHost(<span class="hljs-keyword">null</span> <span class="hljs-comment">/*parent*/</span>);<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    NonConfigurationInstances nc =<br>            (NonConfigurationInstances) getLastNonConfigurationInstance();<br>    <span class="hljs-comment">// 恢复 ViewModel</span><br>    <span class="hljs-keyword">if</span> (nc != <span class="hljs-keyword">null</span> &amp;&amp; nc.viewModelStore != <span class="hljs-keyword">null</span> &amp;&amp; mViewModelStore == <span class="hljs-keyword">null</span>) &#123;<br>        mViewModelStore = nc.viewModelStore;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (savedInstanceState != <span class="hljs-keyword">null</span>) &#123;<br>        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);<br>        <span class="hljs-comment">// 恢复 Fragment</span><br>        mFragments.restoreAllState(p, nc != <span class="hljs-keyword">null</span> ? nc.fragments : <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 旧的 Activity 实例会被销毁，但其对应的 ActivityClientRecord 不会被销毁</span><br><span class="hljs-comment">// 那么 NonConfigurationInstances 就由 ActivityClientRecord 暂时保管</span><br><span class="hljs-function">ActivityClientRecord <span class="hljs-title">performDestroyActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finishing,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> configChanges, <span class="hljs-keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;<br>    ActivityClientRecord r = mActivities.get(token);<br>    Class&lt;? extends Activity&gt; activityClass = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">&quot;Performing finish of &quot;</span> + r);<br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>        activityClass = r.activity.getClass();<br>        r.activity.mConfigChangeFlags |= configChanges;<br>        <span class="hljs-keyword">if</span> (finishing) &#123;<br>            r.activity.mFinished = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        performPauseActivityIfNeeded(r, <span class="hljs-string">&quot;destroy&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!r.stopped) &#123;<br>            callActivityOnStop(r, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* saveState */</span>, <span class="hljs-string">&quot;destroy&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (getNonConfigInstance) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                r.lastNonConfigurationInstances<br>                        = r.activity.retainNonConfigurationInstances();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                            <span class="hljs-string">&quot;Unable to retain activity &quot;</span><br>                            + r.intent.getComponent().toShortString()<br>                            + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// call destory</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 然后在 launch activity 时重新把 NonConfigurationInstances 赋给新建的 Activity 实例</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Activity <span class="hljs-title">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    activity.attach(appContext, <span class="hljs-keyword">this</span>, getInstrumentation(), r.token,<br>            r.ident, app, r.intent, r.activityInfo, title, r.parent,<br>            r.embeddedID, r.lastNonConfigurationInstances, config,<br>            r.referrer, r.voiceInteractor, window, r.configCallback,<br>            r.assistToken);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(...)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    mLastNonConfigurationInstances = lastNonConfigurationInstances;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="CountDownLatch-和-CyclicBarrier-的区别"><a href="#CountDownLatch-和-CyclicBarrier-的区别" class="headerlink" title="CountDownLatch 和 CyclicBarrier 的区别"></a><code>CountDownLatch</code> 和 <code>CyclicBarrier</code> 的区别</h2><p>开始多个线程通过 <code>CountDownLatch.await()</code> 被它阻塞，然后其他线程执行完一个任务就通过 <code>countDown()</code> 把里面的计算器 <code>count</code> 减一，直到计数器归零阻塞的线程才被唤醒；它是 oneshot 不能重复使用，内部通过 <code>AQS</code> 实现</p><p>N 个并行线程执行任务，执行完就阻塞在 <code>CyclicBarrier.await()</code> 上面，直到 N 个线程都执行完任务，最后一个调用 <code>await()</code> 的线程执行完 <code>barrierCommand</code> 后，其他线程被唤醒，而 <code>CyclicBarrier</code> 被重置为初始状态；不同于 <code>CountDownLatch</code> 的一次性，<code>CyclicBarrier</code> 可以重复使用</p><h2 id="如何让-N-个线程串行执行？"><a href="#如何让-N-个线程串行执行？" class="headerlink" title="如何让 N 个线程串行执行？"></a>如何让 N 个线程串行执行？</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Runnable task;<br>    <span class="hljs-keyword">private</span> Thread prev;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JoinThread</span><span class="hljs-params">(Runnable task, Thread prev)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.task = task;<br>        <span class="hljs-keyword">this</span>.prev = prev;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用 Thread.join()，调用后当前线程被阻塞直到 prev 执行完毕才恢复</span><br><span class="hljs-comment">     * join 可以使并行的线程串行执行</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        prev.join();<br>        task.run();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="5-个线程，前-4-个执行完后才执行第-5-个"><a href="#5-个线程，前-4-个执行完后才执行第-5-个" class="headerlink" title="5 个线程，前 4 个执行完后才执行第 5 个"></a>5 个线程，前 4 个执行完后才执行第 5 个</h2><p>用 <code>CountDownLatch</code>，计算器设为 4，第 5 个线程通过 <code>await()</code> 阻塞在计数器上面，前 4 个执行到最后一步时使计数器减一，当计数器为零时第 5 个线程被唤醒</p><h2 id="两个线程交替输出-1-100"><a href="#两个线程交替输出-1-100" class="headerlink" title="两个线程交替输出 1 - 100"></a>两个线程交替输出 1 - 100</h2><h3 id="自旋-volatile"><a href="#自旋-volatile" class="headerlink" title="自旋 + volatile"></a>自旋 + <code>volatile</code></h3><p>既然是交替输出，那必然一个输出奇数一个输出偶数，输出日志这一操作是很快的，所以可以考虑乐观锁：自旋</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> count;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> OddThread().start();<br>        <span class="hljs-keyword">new</span> EvenThread().start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.printf(<span class="hljs-string">&quot;%s - %d%n&quot;</span>, Thread.currentThread().getName(), i);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OddThread</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">super</span>(<span class="hljs-string">&quot;Odd&quot;</span>); &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">int</span> c = count;<br>                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-number">100</span>) <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">if</span> (++c % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    print(c);<br>                    count = c;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EvenThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EvenThread</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">super</span>(<span class="hljs-string">&quot;Even&quot;</span>); &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">int</span> c = count;<br>                <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-number">100</span>) <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">if</span> (++c % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                    print(c);<br>                    count = c;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="基于条件变量-Condition"><a href="#基于条件变量-Condition" class="headerlink" title="基于条件变量 Condition"></a>基于条件变量 <code>Condition</code></h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Condition cond = lock.newCondition();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Runnable run = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    lock.lock();<br>                    cond.signalAll();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (count &gt;= <span class="hljs-number">100</span>) <span class="hljs-keyword">break</span>;<br>                        count++;<br>                        print(count);<br>                        cond.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        lock.unlock();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">new</span> Thread(run, <span class="hljs-string">&quot;A&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(run, <span class="hljs-string">&quot;B&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.printf(<span class="hljs-string">&quot;%s - %d%n&quot;</span>, Thread.currentThread().getName(), i);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="思考：N-个线程按顺序输出-1-100-？"><a href="#思考：N-个线程按顺序输出-1-100-？" class="headerlink" title="思考：N 个线程按顺序输出 1 - 100 ？"></a>思考：N 个线程按顺序输出 1 - 100 ？</h3><p>不使用锁的情况下，把判断奇偶的逻辑改一下，通过 <code>(count % N) == i</code> 判断该数字是否应该由当前线程打印</p><p>用条件变量的情况下，每个线程都在自己的条件变量上阻塞，前面的线程持有下一个线程的条件变量（形成一个环），打印完后唤醒下一个线程；开始时主线程主动唤醒第一个线程</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（二）AQS 源码分析以及 Lock 的实现</title>
    <link href="/blog/2021/01/13/aqs-lock-implementation/"/>
    <url>/blog/2021/01/13/aqs-lock-implementation/</url>
    
    <content type="html"><![CDATA[<p>AQS 是 <code>Semaphore</code>、<code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 的基础，它们紧密地结合在一块，分析 AQS 除了要明晰排队队列的操作，还要结合 <code>Semaphore</code>、<code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 看看是怎么利用排队队列实现锁和信号量的</p><h2 id="AQS-是基于-CLH-锁修改而来的，它的排队队列也是双向链表"><a href="#AQS-是基于-CLH-锁修改而来的，它的排队队列也是双向链表" class="headerlink" title="AQS 是基于 CLH 锁修改而来的，它的排队队列也是双向链表"></a>AQS 是基于 CLH 锁修改而来的，它的排队队列也是双向链表</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head; <span class="hljs-comment">// 队头节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail; <span class="hljs-comment">// 队尾节点</span><br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> Node prev;     <span class="hljs-comment">// 前驱节点</span><br>    <span class="hljs-keyword">volatile</span> Node next;     <span class="hljs-comment">// 后驱节点</span><br>    <span class="hljs-keyword">volatile</span> Thread thread; <span class="hljs-comment">// 节点对应的线程</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// tryAcquire 返回 true 表示获得锁，返回 false 表示未获得锁</span><br><span class="hljs-comment">// 由子类实现，比如公平锁、非公平锁等，这里先不讨论</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="hljs-comment">// 如果不能获得锁，在队列里排队并阻塞</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="hljs-comment">// 因为 futex 可能会因为中断而返回，acquireQueued 返回 true 表示发生了中断，这里主动调用中断</span><br>        selfInterrupt();<br>&#125;<br><br><span class="hljs-comment">// 在队尾添加一个新节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>    Node node = <span class="hljs-keyword">new</span> Node(mode);<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node oldTail = tail;<br>        <span class="hljs-keyword">if</span> (oldTail != <span class="hljs-keyword">null</span>) &#123;<br>            U.putObject(node, Node.PREV, oldTail);<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;<br>                oldTail.next = node;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            initializeSyncQueue();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 刚开始 head 和 tail 都为 null，这里将 head 和 tail 都初始化为同一个空的 Node</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeSyncQueue</span><span class="hljs-params">()</span> </span>&#123;<br>    Node h;<br>    <span class="hljs-keyword">if</span> (U.compareAndSwapObject(<span class="hljs-keyword">this</span>, HEAD, <span class="hljs-keyword">null</span>, (h = <span class="hljs-keyword">new</span> Node())))<br>        tail = h;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selfInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread.currentThread().interrupt();<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="阻塞线程（不是自旋）"><a href="#阻塞线程（不是自旋）" class="headerlink" title="阻塞线程（不是自旋）"></a>阻塞线程（不是自旋）</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-comment">// 当线程没有阻塞且前驱是 head 时，既是轮到当前线程去尝试获得锁</span><br>            <span class="hljs-comment">// 未获得锁，会进入下面的阻塞代码</span><br>            <span class="hljs-comment">// 获得锁时，将 node 设为新的表头</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 节点入队后，如果不能获得锁，则阻塞线程；中断会打断阻塞</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        cancelAcquire(node);<br>        <span class="hljs-keyword">throw</span> t;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 一般情况下，waitStatus == 0，然后被置为 SIGNAL 并返回 false</span><br><span class="hljs-comment">// 然后在下一次的循环里，这个方法返回 true</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ws = pred.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 阻塞当前线程直到 LockSupport.unpark 被调用</span><br>    LockSupport.park(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// 中断会导致 park 返回，这里返回是不是由中断引起的返回</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br><br><span class="hljs-comment">// 表头 head 其实是个空节点</span><br><span class="hljs-comment">// head.next 有机会去获得锁，后续的节点都是阻塞的</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHead</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    head = node;<br>    node.thread = <span class="hljs-keyword">null</span>;<br>    node.prev = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="LockSupport-park-LockSupport-unpark"><a href="#LockSupport-park-LockSupport-unpark" class="headerlink" title="LockSupport.park / LockSupport.unpark"></a><code>LockSupport.park</code> / <code>LockSupport.unpark</code></h2><p>它们是专为 <code>Lock</code> 设计的线程同步 API，<code>park</code> 可以阻塞线程，<code>unpark</code> 恢复线程，但它们又与 <code>wait</code>/<code>notify</code> 有所不同</p><ul><li><code>park</code>，如果 <code>permit</code> 为真则把它置为假，否则阻塞（<code>unpark</code> 和中断会导致函数返回）</li><li><code>unpark</code>，如果线程阻塞中则恢复线程，否则将 <code>permit</code> 置为真；也就是说 <code>park</code> 之前的 <code>unpark</code> 会导致下一次的 <code>park</code> 无效，而且多次 <code>unpark</code> 不叠加效果</li></ul><p>可以看到线程的阻塞和唤醒是通过 <code>futex</code> 系统调用实现的，<code>futex</code> 的原型是 <code>int futex (int *uaddr, int op, int val, const struct timespec *timeout,int *uaddr2, int val3)</code></p><ul><li>op == <code>FUTEX_WAIT</code>，原子性的检查 <code>uaddr</code> 中计数器的值是否为 <code>val，</code>如果是则让进程休眠，直到 <code>FUTEX_WAKE</code> 或者超时，也就是把进程挂到 <code>uaddr</code> 相对应的等待队列上去</li><li>op == <code>FUTEX_WAKE</code>，最多唤醒 <code>val</code> 个等待在 <code>uaddr</code> 上进程</li></ul><p>而 <code>permit</code> 则是通过 <code>tls32_.park_state_</code> 实现，它是一个 <code>AtomicInteger</code>，取值范围为 <code>kPermitAvailable</code> = 0，<code>kNoPermit</code> = 1，<code>kNoPermitWaiterWaiting</code> = 2</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockSupport</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">park</span><span class="hljs-params">(Object blocker)</span> </span>&#123;<br>        Thread t = Thread.currentThread();<br>        setBlocker(t, blocker);<br>        U.park(<span class="hljs-keyword">false</span>, <span class="hljs-number">0L</span>); <span class="hljs-comment">// U 是 sun.misc.Unsafe</span><br>        setBlocker(t, <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unpark</span><span class="hljs-params">(Thread thread)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (thread != <span class="hljs-keyword">null</span>)<br>            U.unpark(thread);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Unsafe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">park</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> var1, <span class="hljs-keyword">long</span> var2)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unpark</span><span class="hljs-params">(Object var1)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Unsafe.park 在 art/runtime/native/sun_misc_Unsafe.cc 里注册为 Unsafe_park</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Unsafe_park</span><span class="hljs-params">(JNIEnv* env, jobject, jboolean isAbsolute, jlong time)</span> </span>&#123;<br>    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;<br>    Thread::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">Park</span>(isAbsolute, time);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    kPermitAvailable = <span class="hljs-number">0</span>,  <span class="hljs-comment">// Incrementing consumes the permit</span><br>    kNoPermit = <span class="hljs-number">1</span>,         <span class="hljs-comment">// Incrementing marks as waiter waiting</span><br>    kNoPermitWaiterWaiting = <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-comment">// 初始值为 kNoPermit，自增为 kNoPermitWaiterWaiting 并阻塞；恢复后复原为 kNoPermit</span><br><span class="hljs-comment">// 如果执行过 unpark，那么为 kPermitAvailable，自增为 kNoPermit 但不会阻塞</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Thread::Park</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> is_absolute, <span class="hljs-keyword">int64_t</span> time)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">int</span> old_state = tls32_.park_state_.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);<br>    <span class="hljs-keyword">if</span> (old_state == kNoPermit) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">futex</span>(tls32_.park_state_.<span class="hljs-built_in">Address</span>(), FUTEX_WAIT_PRIVATE,<br>            <span class="hljs-comment">/* sleep if val = */</span> kNoPermitWaiterWaiting,<br>            <span class="hljs-comment">/* timeout */</span> <span class="hljs-literal">nullptr</span>,<br>            <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// Mark as no longer waiting, and consume permit if there is one.</span><br>    tls32_.park_state_.<span class="hljs-built_in">store</span>(kNoPermit, std::memory_order_relaxed);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 置为 kPermitAvailable，如果原值为 kNoPermitWaiterWaiting 表示线程被阻塞，需要执行系统调用 futex 唤醒</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Thread::Unpark</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Set permit available; will be consumed either by fetch_add (when the thread</span><br>    <span class="hljs-comment">// tries to park) or store (when the parked thread is woken up)</span><br>    <span class="hljs-keyword">if</span> (tls32_.park_state_.<span class="hljs-built_in">exchange</span>(kPermitAvailable, std::memory_order_relaxed) == kNoPermitWaiterWaiting) &#123;<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">futex</span>(tls32_.park_state_.<span class="hljs-built_in">Address</span>(), FUTEX_WAKE_PRIVATE,<br>                           <span class="hljs-comment">/* number of waiters = */</span> <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="可重入的公平锁（ReentrantLock-FairSync）"><a href="#可重入的公平锁（ReentrantLock-FairSync）" class="headerlink" title="可重入的公平锁（ReentrantLock.FairSync）"></a>可重入的公平锁（<code>ReentrantLock.FairSync</code>）</h2><p>公平锁按照 FIFO 的优先级顺序，从排队队列的头部开始依次传递锁的所有权</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 锁没有被取走，把排队队列想象成在 ATM 钱排队取钱的人们，只有当前面没有人的时候才轮到自己取钱</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current); <span class="hljs-comment">// 标识锁在谁手上</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">// 可重入，如果锁在自己手上，递增 state</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-keyword">int</span> nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br><span class="hljs-comment">// 返回 true 表示在前面有人在排队取钱，还没轮到自己；返回 false 表示前面没人了，轮到自己取钱了</span><br><span class="hljs-comment">// h == t 和 h.next == null 是刚初始化 head 和 tail 为空 node 且没有线程入队的情况</span><br><span class="hljs-comment">// h.next 是第一个等待取钱的人，如果它不是当前线程，说明还没轮到自己</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// The correctness of this depends on head being initialized</span><br>        <span class="hljs-comment">// before tail and on head.next being accurate if the current</span><br>        <span class="hljs-comment">// thread is first in queue.</span><br>        Node t = tail; <span class="hljs-comment">// Read fields in reverse initialization order</span><br>        Node h = head;<br>        Node s;<br>        <span class="hljs-keyword">return</span> h != t &amp;&amp;<br>            ((s = h.next) == <span class="hljs-keyword">null</span> || s.thread != Thread.currentThread());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="可重入的非公平锁（ReentrantLock-NonfairSync）"><a href="#可重入的非公平锁（ReentrantLock-NonfairSync）" class="headerlink" title="可重入的非公平锁（ReentrantLock.NonfairSync）"></a>可重入的非公平锁（<code>ReentrantLock.NonfairSync</code>）</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 只要锁没有被取走，自己就可以获得锁</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>            setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">else</span><br>            acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 锁没有被取走，那么自己可以直接获得锁</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 可重入，锁已经在自己手上，递增 state</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-keyword">int</span> nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>排队取锁的线程都被阻塞了，释放锁的同时需要唤醒下一个排队的线程</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-comment">// tryRelease 由子类实现，返回 true 表示当前线程持有锁并成功释放锁（可重入的情况下，未必能够释放锁）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123; <span class="hljs-comment">// head 是持有锁的线程</span><br>            Node h = head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>                unparkSuccessor(h);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;   <br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment">         * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment">         * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">int</span> ws = node.waitStatus;<br>        <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>            node.compareAndSetWaitStatus(ws, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Thread to unpark is held in successor, which is normally</span><br><span class="hljs-comment">         * just the next node.  But if cancelled or apparently null,</span><br><span class="hljs-comment">         * traverse backwards from tail to find the actual</span><br><span class="hljs-comment">         * non-cancelled successor.</span><br><span class="hljs-comment">         * head.next 一般是排队等待锁里的第一个，但它可能被取消了或者其他原因从队伍里删除了，那么我们从队尾开始遍历找可以唤醒的线程</span><br><span class="hljs-comment">         */</span><br>        Node s = node.next;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>            s = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">for</span> (Node p = tail; p != node &amp;&amp; p != <span class="hljs-keyword">null</span>; p = p.prev)<br>                <span class="hljs-keyword">if</span> (p.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                    s = p;<br>        &#125;<br>        <span class="hljs-comment">// 唤醒下一个线程，让他去尝试获取锁</span><br>        <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br>            LockSupport.unpark(s.thread);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="可重入锁的释放过程（ReentrantLock-Sync）"><a href="#可重入锁的释放过程（ReentrantLock-Sync）" class="headerlink" title="可重入锁的释放过程（ReentrantLock.Sync）"></a>可重入锁的释放过程（<code>ReentrantLock.Sync</code>）</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>        <span class="hljs-comment">// releases 恒为一，而 state 为重入得次数，也即重入次数减一</span><br>        <span class="hljs-keyword">int</span> c = getState() - releases;<br>        <span class="hljs-comment">// 当前线程不持有锁，抛出异常</span><br>        <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>        <span class="hljs-comment">// 如果重入次数为零，那么可以释放锁</span><br>        <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            free = <span class="hljs-keyword">true</span>;<br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>        &#125;<br>        setState(c);<br>        <span class="hljs-keyword">return</span> free;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="可重入的读写锁（ReentrantReadWriteLock）"><a href="#可重入的读写锁（ReentrantReadWriteLock）" class="headerlink" title="可重入的读写锁（ReentrantReadWriteLock）"></a>可重入的读写锁（<code>ReentrantReadWriteLock</code>）</h2><p>一个资源能够被多个读线程访问（读锁有多把），或者被一个写线程访问（写锁只有一把），但是不能同时存在读写线程（读锁和写锁是互斥的）</p><h2 id="获取读锁"><a href="#获取读锁" class="headerlink" title="获取读锁"></a>获取读锁</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquireShared(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>            doAcquireShared(arg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 能不能获得读锁</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        Thread current = Thread.currentThread();<br>        <span class="hljs-comment">// 对于上面的可重入排它锁，state == 0 表示锁未被其他线程获得，</span><br>        <span class="hljs-comment">// state == 1 表示锁已被某个线程获得，state &gt; 1 表示重入得次数</span><br>        <span class="hljs-comment">// 对于读写锁，state 高 16 位表示读锁的个数，state 低 16 位表示写锁重入得个数</span><br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-comment">// 写锁被其他线程获得了，读写锁是互斥的，不能借出读锁</span><br>        <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;<br>            getExclusiveOwnerThread() != current)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 获得读锁，state 读锁次数加一</span><br>        <span class="hljs-comment">// 获得读锁的线程用 threadlocal count 记录获得的读锁的数量，这里也要加一（用来观察当前线程拿了几个读锁）</span><br>        <span class="hljs-comment">// readerShouldBlock 的解释见下文</span><br>        <span class="hljs-keyword">int</span> r = sharedCount(c);<br>        <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;<br>            r &lt; MAX_COUNT &amp;&amp;<br>            compareAndSetState(c, c + SHARED_UNIT)) &#123;<br>            <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>                firstReader = current;<br>                firstReaderHoldCount = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>                firstReaderHoldCount++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                HoldCounter rh = cachedHoldCounter;<br>                <span class="hljs-keyword">if</span> (rh == <span class="hljs-keyword">null</span> || rh.tid != getThreadId(current))<br>                    cachedHoldCounter = rh = readHolds.get();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                    readHolds.set(rh);<br>                rh.count++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// fullTryAcquireShared 其实是 tryAcquireShared 的自旋版本</span><br>        <span class="hljs-comment">// 针对 compareAndSetState(c, c + SHARED_UNIT) 失败而自旋，也就是被别的线程抢先获得了一个读锁</span><br>        <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 不能获得锁，排队并阻塞</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="hljs-comment">// 添加 shared 节点至队尾</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 循环取锁</span><br>                <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head) &#123;<br>                    <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                        setHeadAndPropagate(node, r);<br>                        p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                        <span class="hljs-keyword">if</span> (interrupted)<br>                            selfInterrupt();<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            cancelAcquire(node);<br>            <span class="hljs-keyword">throw</span> t;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// tryAcquireShared 有可能是在排队等待的过程中线程被唤醒而执行</span><br><span class="hljs-comment">// 此时对于公平锁，只有当前面没有排队的前驱时才能去拿锁</span><br><span class="hljs-comment">// 对于非公平锁，见下面的注释，为了防止「写饥饿」，也就是认为写操作要比读操作更重要一点，不能完全地让所有取锁的线程去争抢</span><br><span class="hljs-comment">// 而是得让在对头等待的写线程优先获得锁</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">readerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">/* As a heuristic to avoid indefinite writer starvation,</span><br><span class="hljs-comment">         * block if the thread that momentarily appears to be head</span><br><span class="hljs-comment">         * of queue, if one exists, is a waiting writer.  This is</span><br><span class="hljs-comment">         * only a probabilistic effect since a new reader will not</span><br><span class="hljs-comment">         * block if there is a waiting writer behind other enabled</span><br><span class="hljs-comment">         * readers that have not yet drained from the queue.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> apparentlyFirstQueuedIsExclusive();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">readerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hasQueuedPredecessors();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">apparentlyFirstQueuedIsExclusive</span><span class="hljs-params">()</span> </span>&#123;<br>        Node h, s;<br>        <span class="hljs-keyword">return</span> (h = head) != <span class="hljs-keyword">null</span> &amp;&amp;<br>            (s = h.next)  != <span class="hljs-keyword">null</span> &amp;&amp;<br>            !s.isShared()         &amp;&amp;<br>            s.thread != <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="获取写锁"><a href="#获取写锁" class="headerlink" title="获取写锁"></a>获取写锁</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 能不能获得写锁；失败的话跟排它锁一样排队阻塞</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">int</span> w = exclusiveCount(c);<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span><br>            <span class="hljs-comment">// 读锁不为零，读写锁互斥，不能获得写锁</span><br>            <span class="hljs-comment">// 写锁不为零，但是被别的线程获得，当前线程也不能获得写锁</span><br>            <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 不能超过 16 位的长度（因为写锁的数量存储在 state 的低 16 位）</span><br>            <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            <span class="hljs-comment">// 当前线程已持有写锁，重入导致写锁数量加一</span><br>            setState(c + acquires);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 读锁和写锁都为零，当然可以获得写锁；state 里的写锁数量加一，记下谁拿了写锁</span><br>        <span class="hljs-comment">// 因为 tryAcquire 有可能是在排队过程中被唤醒而触发的，所以在非公平锁的情况下，能获得锁直接拿就好了</span><br>        <span class="hljs-comment">// 而在公平锁的情况下，需要等前面排队的先拿锁</span><br>        <span class="hljs-keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        setExclusiveOwnerThread(current);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">writerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// writers can always barge</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">writerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 上面介绍过，判断自己前面还有没有前驱</span><br>        <span class="hljs-comment">// 公平锁的情况下，只有轮到自己（没有前驱，或者说前面没有排队的）的情况下，才去获取锁</span><br>        <span class="hljs-keyword">return</span> hasQueuedPredecessors();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="释放读锁"><a href="#释放读锁" class="headerlink" title="释放读锁"></a>释放读锁</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>            doReleaseShared();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        <span class="hljs-comment">// threadlocal count（线程的读锁计数器）减一</span><br>        Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>            <span class="hljs-keyword">if</span> (firstReaderHoldCount == <span class="hljs-number">1</span>)<br>                firstReader = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">else</span><br>                firstReaderHoldCount--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            HoldCounter rh = cachedHoldCounter;<br>            <span class="hljs-keyword">if</span> (rh == <span class="hljs-keyword">null</span> || rh.tid != getThreadId(current))<br>                rh = readHolds.get();<br>            <span class="hljs-keyword">int</span> count = rh.count;<br>            <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">1</span>) &#123;<br>                readHolds.remove();<br>                <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">throw</span> unmatchedUnlockException();<br>            &#125;<br>            --rh.count;<br>        &#125;<br>        <span class="hljs-comment">// 总的读锁计数器减一</span><br>        <span class="hljs-comment">// 读锁是共享的，释放一个读锁不影响其他的读锁；但如果读锁为零，需要唤醒阻塞在写锁上的线程</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> c = getState();<br>            <span class="hljs-keyword">int</span> nextc = c - SHARED_UNIT;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>                <span class="hljs-comment">// Releasing the read lock has no effect on readers,</span><br>                <span class="hljs-comment">// but it may allow waiting writers to proceed if</span><br>                <span class="hljs-comment">// both read and write locks are now free.</span><br>                <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="释放写锁"><a href="#释放写锁" class="headerlink" title="释放写锁"></a>释放写锁</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-comment">// 写锁个数减一，当写锁个数为零时，返回 true 导致 AQS 移除当前节点并唤醒下一个排队的线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>        <span class="hljs-keyword">int</span> nextc = getState() - releases;<br>        <span class="hljs-keyword">boolean</span> free = exclusiveCount(nextc) == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (free)<br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> free;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量相当于一个保存着多个锁的保险箱，它可以向外借出锁（<code>acquire</code>）和回收借出的锁（<code>release</code>），当锁用完的时候 <code>acquire</code> 会阻塞</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获得锁</span><br><span class="hljs-keyword">void</span> Semaphore.acquire() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">void</span> AbstractQueuedSynchronizer.acquireSharedInterruptibly(<span class="hljs-keyword">int</span> arg) <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireSharedInterruptibly(arg);<br>&#125;<br><span class="hljs-comment">// 看下排队队列，跟上面的 Lock 操作是一样的</span><br><span class="hljs-comment">// 添加节点到队尾，循环判断是否轮到自己获得锁，否则陷入阻塞直到被唤醒</span><br><span class="hljs-keyword">void</span> AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(<span class="hljs-keyword">int</span> arg) <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        cancelAcquire(node);<br>        <span class="hljs-keyword">throw</span> t;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 非公平锁</span><br><span class="hljs-comment">// state 表示保险箱内锁的数量</span><br><span class="hljs-comment">// 如果已经没有锁可以借出，则返回负数导致线程进入排队队列，排队并阻塞</span><br><span class="hljs-comment">// 如果可以借出锁，则更新 state 并返回</span><br><span class="hljs-comment">// 因为是非公平锁，所以无需考虑前面是否有排队的线程</span><br><span class="hljs-keyword">int</span> NonfairSync.tryAcquireShared(<span class="hljs-keyword">int</span> acquires) &#123;<br>    <span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br>&#125;<br><span class="hljs-keyword">int</span> Sync.nonfairTryAcquireShared(<span class="hljs-keyword">int</span> acquires) &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> available = getState();<br>        <span class="hljs-keyword">int</span> remaining = available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> || compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 公平锁，跟非公平锁一样的，只不过当前面有排队线程时，要让它先获得锁</span><br><span class="hljs-keyword">int</span> FairSync.tryAcquireShared(<span class="hljs-keyword">int</span> acquires) &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (hasQueuedPredecessors())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> available = getState();<br>        <span class="hljs-keyword">int</span> remaining = available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 释放锁</span><br><span class="hljs-comment">// state 加一，唤醒排队线程</span><br><span class="hljs-keyword">void</span> Semaphore.release() &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">boolean</span> AbstractQueuedSynchronizer.releaseShared(<span class="hljs-keyword">int</span> arg) &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> current = getState();<br>        <span class="hljs-keyword">int</span> next = current + releases;<br>        <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/lengxiao1993/article/details/108449850">AQS与CLH相关论文学习系列（四）- AQS的设计思路</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Art</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lock</tag>
      
      <tag>AQS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock（一）AQS 基础</title>
    <link href="/blog/2021/01/10/aqs-basic/"/>
    <url>/blog/2021/01/10/aqs-basic/</url>
    
    <content type="html"><![CDATA[<h2 id="自旋锁（Spin-Lock）"><a href="#自旋锁（Spin-Lock）" class="headerlink" title="自旋锁（Spin Lock）"></a>自旋锁（Spin Lock）</h2><p>获得锁的时候，不阻塞线程，而是跟平常一样继续获得 CPU 时间，继续执行代码/逻辑，那就是自旋锁；比如下面的 <code>lock()</code></p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// 一个简单的自旋锁的实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> cas = AtomicReference&lt;Thread&gt;()<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">while</span> (!cas.compareAndSet(<span class="hljs-literal">null</span>, Thread.currentThread())) &#123;&#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span> &#123;<br>        cas.compareAndSet(Thread.currentThread(), <span class="hljs-literal">null</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="MCS-锁"><a href="#MCS-锁" class="headerlink" title="MCS 锁"></a>MCS 锁</h2><p>上面的自旋锁容易出现「饥饿」问题，因为所有线程同时争抢一个锁，如果一直有线程加入到争抢的过程中来，那么可能会出现某一个或多个线程总是抢不到锁的情况</p><p>而 MCS 在自旋的基础上，引入了「排队」的概念（基于链表）</p><ul><li><code>acquire_lock</code>，<code>L</code> 是链尾节点，<code>I</code> 是当前线程所使用的节点，<code>fetch_and_store</code> 相当于原子性地把 I 添加到链尾，并对 <code>I→locked</code> 进行自旋</li><li><code>release_lock</code>，将 <code>I→next→locked</code> 置为 <code>false</code>，从而使下一个线程获得锁（跳出自旋）</li></ul><p>那么所有未获得锁的线程都会按顺序排成一队（通过 <code>I→next</code> 形成的单向链表），并对 <code>I→locked</code> 自旋，这就是排队自旋锁</p><p>获得锁的线程负责将锁传递给下一个未获得锁的线程（<code>I→next→locked := false</code>）</p><p><img src="../../../../image/2021-01-10-aqs-basic/2020090217384261.png" alt="2020090217384261.png"></p><h2 id="CLH-锁"><a href="#CLH-锁" class="headerlink" title="CLH 锁"></a>CLH 锁</h2><p>它减少释放锁时的自旋开销：</p><ul><li>MCS 锁的持有进程在让渡锁的所有权时，由于需要关心自己的后继结点是否存在以及是否会被突然添加，所以多了一些负担</li><li>MCS 锁在持有进程在让渡锁的所有权时，由于已经知道后继结点肯定只能监控自己在入队时就设置好的结点，所以无需关心是否存在后继结点，只需要修改自己预留给后继结点监控的队列结点状态即可。</li></ul><p>MCS 实现了基于 FIFO 的优先级，而 CLH 可以实现自定义的优先级</p><p>CLH 锁的排队队列是个双向链表，<code>Lock.head</code> 和 <code>Lock.tail</code> 分别是表头和表尾</p><p><code>Process.watch</code> 是当前线程用来自旋的，<code>Process.myreq</code> 留给下一个线程进行自旋；比如线程 P2 在 <code>P2.watch</code> 上自旋，同时 <code>P2.watch</code> 又是 <code>P1.myreq</code>；而 <code>P2.myreq</code> 则是 <code>P3.watch</code>，P3 在 <code>P3.watch</code> 上自旋</p><p><code>Request.watcher</code> 表示那个线程在对它自旋，<code>Request.myproc</code> 表示自旋线程的上一个线程</p><p>从表头开始遍历线程：<code>Lock.head.watcher</code> → <code>Process.myreq.watcher</code> → <code>Process.myreq.watcher</code>→ …</p><p>从表尾开始遍历线程：<code>Lock.tail.myproc</code> → <code>Process.watch.myproc</code> → <code>Process.watch.myproc</code> → …</p><p><code>request_lock</code>（获得锁），将 <code>P.myreq</code> 添加到队尾，并在 <code>P.watch</code>（既是上一个队尾，也是上一个线程的 <code>Process.myreq</code>） 上自旋</p><p><code>grant_lock</code>（释放锁），从头开始遍历排队的线程，找到优先级最高的线程（<code>Process.pri</code>，不仅仅是 FIFO），将它的 <code>Process.watch.state := GRANTED</code> 从而使它跳出自旋（将锁的所有权转移给它）</p><p><img src="../../../../image/2021-01-10-aqs-basic/2020090322512651.png" alt="2020090322512651.png"></p><p><img src="../../../../image/2021-01-10-aqs-basic/20200903154644711.png" alt="20200903154644711.png"></p><p><img src="../../../../image/2021-01-10-aqs-basic/20200903162049551.png" alt="20200903162049551.png"></p><p><img src="../../../../image/2021-01-10-aqs-basic/20200903222817656.png" alt="20200903222817656.png"></p><p><img src="../../../../image/2021-01-10-aqs-basic/20200903223128890.png" alt="20200903223128890.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/lengxiao1993/article/details/108227584">AQS与CLH相关论文学习系列（一）- 排队式自旋锁思想启蒙</a></li><li><a href="https://blog.csdn.net/lengxiao1993/article/details/108448199">AQS与CLH相关论文学习系列（二）- MCS 锁</a></li><li><a href="https://blog.csdn.net/lengxiao1993/article/details/108449111">AQS与CLH相关论文学习系列（三）- CLH 锁</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Art</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lock</tag>
      
      <tag>AQS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 图形栈（三）render thread</title>
    <link href="/blog/2020/12/27/render-thread/"/>
    <url>/blog/2020/12/27/render-thread/</url>
    
    <content type="html"><![CDATA[<p>接着<a href="../../../../2020/12/13/ui-thread-in-vsync/">上一篇文章</a>，在上篇文章里我们知道了 ui thread 在 view drawing 阶段产生了 <code>DisplayList</code>，而 render thread 会根据 <code>DisplayList</code> 执行真正的渲染工作，主要是 <code>DrawFrameTask.syncFrameState</code> 和 <code>CanvasContext.draw</code> 这两个方法</p><h2 id="syncFrameState"><a href="#syncFrameState" class="headerlink" title="syncFrameState"></a>syncFrameState</h2><p>重要的方法有三个：<code>makeCurrent</code>，<code>unpinImages</code> 和 <code>prepareTree</code></p><p><code>TreeInfo</code> 用来在后续的一系列操作中收集信息，你会看到它在各个方法中作为参数传递</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DrawFrameTask::syncFrameState</span><span class="hljs-params">(TreeInfo&amp; info)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">bool</span> canDraw = mContext-&gt;<span class="hljs-built_in">makeCurrent</span>();<br>    mContext-&gt;<span class="hljs-built_in">unpinImages</span>();<br>    <span class="hljs-comment">// ...</span><br>    mContext-&gt;<span class="hljs-built_in">setContentDrawBounds</span>(mContentDrawBounds);<br>    mContext-&gt;<span class="hljs-built_in">prepareTree</span>(info, mFrameInfo, mSyncQueued, mTargetNode);<br>    <span class="hljs-comment">// ... If prepareTextures is false, we ran out of texture cache space</span><br>    <span class="hljs-keyword">return</span> info.prepareTextures;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="makeCurrent"><a href="#makeCurrent" class="headerlink" title="makeCurrent"></a>makeCurrent</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CanvasContext::makeCurrent</span><span class="hljs-params">()</span></span><br><span class="hljs-function">MakeCurrentResult <span class="hljs-title">SkiaOpenGLPipeline::makeCurrent</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (!mEglManager.<span class="hljs-built_in">makeCurrent</span>(mEglSurface, &amp;error)) &#123;<br>        <span class="hljs-keyword">return</span> MakeCurrentResult::AlreadyCurrent;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">EglManager::makeCurrent</span><span class="hljs-params">(EGLSurface surface, EGLint* errOut, <span class="hljs-keyword">bool</span> force)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">eglMakeCurrent</span>(mEglDisplay, surface, surface, mEglContext)) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>最终是调用了 opengl 的 <code>[eglMakeCurrent](https://www.khronos.org/registry/EGL/sdk/docs/man/html/eglMakeCurrent.xhtml)</code> 方法准备 opengl 环境；现在是 ui thread，并不会在这里进行渲染，而是为了待会将 mutable images 上传到 gpu</p><p>opengl api 都是像 <code>glDrawArrays</code>、<code>glDrawElements</code>、<code>glBindTexture</code> 这样只有方法名和参数的，它的上下文是绑定在 thread 上的，在调用 opengl api 前 <code>eglMakeCurrent</code> 就是确保当前线程有 opengl 上下文；mEglDisplay 可以理解为设备的屏幕；opengl 有双缓冲，一个被主线程读取，一个被渲染线程写入，就是第二和第三个参数，渲染完交换一下，读变写，写变读，当前都是用得同一个 surface；第四个就是 opengl 的上下文，保存了 opengl 状态机</p><h2 id="unpinImages"><a href="#unpinImages" class="headerlink" title="unpinImages"></a>unpinImages</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/** \class SkImage</span><br><span class="hljs-comment">    SkImage describes a two dimensional array of pixels to draw. The pixels may be</span><br><span class="hljs-comment">    decoded in a raster bitmap, encoded in a SkPicture or compressed data stream,</span><br><span class="hljs-comment">    or located in GPU memory as a GPU texture.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    SkImage cannot be modified after it is created. SkImage may allocate additional</span><br><span class="hljs-comment">    storage as needed; for instance, an encoded SkImage may decode when drawn.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    SkImage width and height are greater than zero. Creating an SkImage with zero width</span><br><span class="hljs-comment">    or height returns SkImage equal to nullptr.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    SkImage may be created from SkBitmap, SkPixmap, SkSurface, SkPicture, encoded streams,</span><br><span class="hljs-comment">    GPU texture, YUV_ColorSpace data, or hardware buffer. Encoded streams supported</span><br><span class="hljs-comment">    include BMP, GIF, HEIF, ICO, JPEG, PNG, WBMP, WebP. Supported encoding details</span><br><span class="hljs-comment">    vary with platform.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SK_API</span> <span class="hljs-title">SkImage</span></span><br><span class="hljs-class"></span><br><span class="hljs-class">    /**</span><br><span class="hljs-class">     * <span class="hljs-title">Pin</span> <span class="hljs-title">any</span> <span class="hljs-title">mutable</span> <span class="hljs-title">images</span> <span class="hljs-title">to</span> <span class="hljs-title">the</span> <span class="hljs-title">GPU</span> <span class="hljs-title">cache</span>. <span class="hljs-title">A</span> <span class="hljs-title">pinned</span> <span class="hljs-title">images</span> <span class="hljs-title">is</span> <span class="hljs-title">guaranteed</span> <span class="hljs-title">to</span></span><br><span class="hljs-class">     * <span class="hljs-title">remain</span> <span class="hljs-title">in</span> <span class="hljs-title">the</span> <span class="hljs-title">cache</span> <span class="hljs-title">until</span> <span class="hljs-title">it</span> <span class="hljs-title">has</span> <span class="hljs-title">been</span> <span class="hljs-title">unpinned</span>. <span class="hljs-title">We</span> <span class="hljs-title">leverage</span> <span class="hljs-title">this</span> <span class="hljs-title">feature</span></span><br><span class="hljs-class">     * <span class="hljs-title">to</span> <span class="hljs-title">avoid</span> <span class="hljs-title">making</span> <span class="hljs-title">a</span> <span class="hljs-title">CPU</span> <span class="hljs-title">copy</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">pixels</span>.</span><br><span class="hljs-class">     *</span><br><span class="hljs-class">     * @<span class="hljs-title">return</span> <span class="hljs-title">true</span> <span class="hljs-title">if</span> <span class="hljs-title">all</span> <span class="hljs-title">images</span> <span class="hljs-title">have</span> <span class="hljs-title">been</span> <span class="hljs-title">successfully</span> <span class="hljs-title">pinned</span> <span class="hljs-title">to</span> <span class="hljs-title">the</span> <span class="hljs-title">GPU</span> <span class="hljs-title">cache</span></span><br><span class="hljs-class">     *         <span class="hljs-title">and</span> <span class="hljs-title">false</span> <span class="hljs-title">otherwise</span> (<span class="hljs-title">e</span>.<span class="hljs-title">g</span>. <span class="hljs-title">cache</span> <span class="hljs-title">limits</span> <span class="hljs-title">have</span> <span class="hljs-title">been</span> <span class="hljs-title">exceeded</span>).</span><br><span class="hljs-class">     */</span><br><span class="hljs-class">    <span class="hljs-title">bool</span> <span class="hljs-title">pinImages</span>(<span class="hljs-title">std</span>:</span>:vector&lt;SkImage*&gt;&amp; mutableImages) &#123;<br>        <span class="hljs-keyword">return</span> mRenderPipeline-&gt;<span class="hljs-built_in">pinImages</span>(mutableImages);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Unpin any image that had be previously pinned to the GPU cache</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unpinImages</span><span class="hljs-params">()</span> </span>&#123; mRenderPipeline-&gt;<span class="hljs-built_in">unpinImages</span>(); &#125;<br></code></pre></div></td></tr></table></figure><p><code>SkImage</code> 对一切图像的抽象，包括 jpg、webp 等压缩格式、Bitmap 位图、流、甚至 gpu 上的纹理</p><p><code>pinImages</code> 把在内存的 SkImage 作为纹理上传到 gpu 内存，然后可以通过纹理 id 引用，从而避免在内存里操作（复制）像素</p><p><code>unpinImages</code> 从 gpu 内存里移除纹理</p><h2 id="DamageAccumulator"><a href="#DamageAccumulator" class="headerlink" title="DamageAccumulator"></a>DamageAccumulator</h2><p><code>DamageAccumulator</code> 是 <code>DirtyStack</code> stack（FIFO，用双向链表实现），用来累计脏区，它的一般用法是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">info.damageAccumulator-&gt;<span class="hljs-built_in">pushTransform</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-built_in">damageSelf</span>(info);<br>info.damageAccumulator-&gt;<span class="hljs-built_in">popTransform</span>();<br><br><span class="hljs-comment">// 将 node 压入栈顶</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DamageAccumulator::pushTransform</span><span class="hljs-params">(<span class="hljs-keyword">const</span> RenderNode* transform)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// 更新栈顶元素的脏区 = 已有脏区 + node 大小，也就是并集</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::damageSelf</span><span class="hljs-params">(TreeInfo&amp; info)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isRenderable</span>()) &#123;<br>        mDamageGenerationId = info.damageGenerationId;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">properties</span>().<span class="hljs-built_in">getClipDamageToBounds</span>()) &#123;<br>            info.damageAccumulator-&gt;<span class="hljs-built_in">dirty</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">properties</span>().<span class="hljs-built_in">getWidth</span>(), <span class="hljs-built_in">properties</span>().<span class="hljs-built_in">getHeight</span>());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Hope this is big enough?</span><br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Get this from the display list ops or something</span><br>            info.damageAccumulator-&gt;<span class="hljs-built_in">dirty</span>(DIRTY_MIN, DIRTY_MIN, DIRTY_MAX, DIRTY_MAX);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DamageAccumulator::dirty</span><span class="hljs-params">(<span class="hljs-keyword">float</span> left, <span class="hljs-keyword">float</span> top, <span class="hljs-keyword">float</span> right, <span class="hljs-keyword">float</span> bottom)</span> </span>&#123;<br>    mHead-&gt;pendingDirty.<span class="hljs-built_in">join</span>(&#123;left, top, right, bottom&#125;);<br>&#125;<br><br><span class="hljs-comment">// 弹出栈顶元素 head，并将栈顶元素的脏区合并到当前栈顶元素 prev 的脏区</span><br><span class="hljs-comment">// 可见脏区是累加的</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DamageAccumulator::popTransform</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">LOG_ALWAYS_FATAL_IF</span>(mHead-&gt;prev == mHead, <span class="hljs-string">&quot;Cannot pop the root frame!&quot;</span>);<br>    DirtyStack* dirtyFrame = mHead;<br>    mHead = mHead-&gt;prev;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (dirtyFrame-&gt;type) &#123;<br>        <span class="hljs-keyword">case</span> TransformRenderNode:<br>            <span class="hljs-built_in">applyRenderNodeTransform</span>(dirtyFrame);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> TransformMatrix4:<br>            <span class="hljs-built_in">applyMatrix4Transform</span>(dirtyFrame);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> TransformNone:<br>            mHead-&gt;pendingDirty.<span class="hljs-built_in">join</span>(dirtyFrame-&gt;pendingDirty);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">LOG_ALWAYS_FATAL</span>(<span class="hljs-string">&quot;Tried to pop an invalid type: %d&quot;</span>, dirtyFrame-&gt;type);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="prepareTree"><a href="#prepareTree" class="headerlink" title="prepareTree"></a>prepareTree</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CanvasContext::prepareTree</span><span class="hljs-params">(TreeInfo&amp; info, <span class="hljs-keyword">int64_t</span>* uiFrameInfo, <span class="hljs-keyword">int64_t</span> syncQueued, RenderNode* target)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> sp&lt;RenderNode&gt;&amp; node : mRenderNodes) &#123;<br>        <span class="hljs-comment">// Only the primary target node will be drawn full - all other nodes would get drawn in</span><br>        <span class="hljs-comment">// real time mode. In case of a window, the primary node is the window content and the other</span><br>        <span class="hljs-comment">// node(s) are non client / filler nodes.</span><br>        info.mode = (node.<span class="hljs-built_in">get</span>() == target ? TreeInfo::MODE_FULL : TreeInfo::MODE_RT_ONLY);<br>        node-&gt;<span class="hljs-built_in">prepareTree</span>(info);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>target 是 <code>HardwareRenderer.mRootNode</code> 对应的 native <code>RootRenderNode</code>，<code>mRenderNodes</code> 正常情况下应该只有一个元素 target，所以这里应该总是 <code>TreeInfo::MODE_FULL</code></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::prepareTree</span><span class="hljs-params">(TreeInfo&amp; info)</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::prepareTreeImpl</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo&amp; info, <span class="hljs-keyword">bool</span> functorsNeedLayer)</span> </span>&#123;    <br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (info.mode == TreeInfo::MODE_FULL) &#123;<br>        <span class="hljs-built_in">pushStagingDisplayListChanges</span>(observer, info);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (mDisplayList) &#123;<br>        info.out.hasFunctors |= mDisplayList-&gt;<span class="hljs-built_in">hasFunctor</span>();<br>        <span class="hljs-keyword">bool</span> isDirty = mDisplayList-&gt;<span class="hljs-built_in">prepareListAndChildren</span>(observer, info, childFunctorsNeedLayer,<br>            [](RenderNode* child, TreeObserver&amp; observer, TreeInfo&amp; info, <span class="hljs-keyword">bool</span> functorsNeedLayer) &#123;<br>                child-&gt;<span class="hljs-built_in">prepareTreeImpl</span>(observer, info, functorsNeedLayer);<br>            &#125;);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-built_in">pushLayerUpdate</span>(info);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::pushStagingDisplayListChanges</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo&amp; info)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mNeedsDisplayListSync) &#123;<br>        mNeedsDisplayListSync = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">damageSelf</span>(info);<br>        <span class="hljs-built_in">syncDisplayList</span>(observer, &amp;info);<br>        <span class="hljs-built_in">damageSelf</span>(info);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::syncDisplayList</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo* info)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mStagingDisplayList) &#123;<br>        mStagingDisplayList-&gt;<span class="hljs-built_in">updateChildren</span>([](RenderNode* child) &#123; child-&gt;<span class="hljs-built_in">incParentRefCount</span>(); &#125;);<br>    &#125;<br>    <span class="hljs-built_in">deleteDisplayList</span>(observer, info);<br>    mDisplayList = mStagingDisplayList;<br>    mStagingDisplayList = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (mDisplayList) &#123;<br>        WebViewSyncData syncData &#123;<br>            .applyForceDark = info &amp;&amp; !info-&gt;disableForceDark<br>        &#125;;<br>        mDisplayList-&gt;<span class="hljs-built_in">syncContents</span>(syncData);<br>        <span class="hljs-built_in">handleForceDark</span>(info);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>还记得在<a href="../../../../2020/12/13/ui-thread-in-vsync/">上篇文章</a>里提到， DisplayList 在 endRecording 阶段被放在 <code>RenderNode.mStagingDisplayList</code>，这时候转移到 <code>mDisplayList</code></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SkiaDisplayList::prepareListAndChildren</span><span class="hljs-params">(TreeObserver&amp; observer, TreeInfo&amp; info, <span class="hljs-keyword">bool</span> functorsNeedLayer,</span></span><br><span class="hljs-function"><span class="hljs-params">        std::function&lt;<span class="hljs-keyword">void</span>(RenderNode*, TreeObserver&amp;, TreeInfo&amp;, <span class="hljs-keyword">bool</span>)&gt; childFn)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (info.prepareTextures &amp;&amp; !info.canvasContext.<span class="hljs-built_in">pinImages</span>(mMutableImages)) &#123;<br>        info.prepareTextures = <span class="hljs-literal">false</span>;<br>        info.canvasContext.<span class="hljs-built_in">unpinImages</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">bool</span> hasBackwardProjectedNodesHere = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">bool</span> hasBackwardProjectedNodesSubtree = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; child : mChildNodes) &#123;<br>        RenderNode* childNode = child.<span class="hljs-built_in">getRenderNode</span>();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">childFn</span>(childNode, observer, info, functorsNeedLayer);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>SkiaRecordingCanvas.drawBitmap</code> 等方法会将 mutable image 放入 <code>mMutableImages</code>，然后在 prepare 阶段上传到 gpu；为什么这么做呢，我猜想是在渲染之前需要确保所有内容都计算完毕并确保不变，mutable image 可以被修改，所以放到 gpu 里确保不被改动，immutable image 因为本身就不可修改所以无需这样处理</p><p><code>TreeInfo.prepareTextures</code> 标识 mutable images 有没上传成功；如果上传成功，ui thread 在 <code>DrawFrameTask::syncFrameState</code> 之后就会被唤醒，否则会一直阻塞直到 <code>CanvasContext.draw</code> 完成；这对 ui thread 有着很大的影响</p><p><code>SkiaDisplayList.mChildNodes</code> 应该只有一个 <code>DecorView.mRenderNode</code>，在这里它的 <code>prepareTreeImpl</code> 被调用</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::pushLayerUpdate</span><span class="hljs-params">(TreeInfo&amp; info)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (info.canvasContext.<span class="hljs-built_in">createOrUpdateLayer</span>(<span class="hljs-keyword">this</span>, *info.damageAccumulator, info.errorHandler)) &#123;<br>        <span class="hljs-built_in">damageSelf</span>(info);<br>    &#125;<br>    <span class="hljs-comment">// ... 将有 layer 的 RenderNode 和它的脏区加入 TreeInfo.layerUpdateQueue</span><br>    SkRect dirty;<br>    info.damageAccumulator-&gt;<span class="hljs-built_in">peekAtDirty</span>(&amp;dirty);<br>    info.layerUpdateQueue-&gt;<span class="hljs-built_in">enqueueLayerWithDamage</span>(<span class="hljs-keyword">this</span>, dirty);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 如果 node 没有 layer，或者 node 的大小发送了改变，则新建 layer</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SkiaPipeline::createOrUpdateLayer</span><span class="hljs-params">(RenderNode* node, <span class="hljs-keyword">const</span> DamageAccumulator&amp; damageAccumulator,</span></span><br><span class="hljs-function"><span class="hljs-params">                                       ErrorHandler* errorHandler)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    SkSurface* layer = node-&gt;<span class="hljs-built_in">getLayerSurface</span>();<br>    <span class="hljs-keyword">if</span> (!layer || layer-&gt;<span class="hljs-built_in">width</span>() != surfaceWidth || layer-&gt;<span class="hljs-built_in">height</span>() != surfaceHeight) &#123;<br>        SkImageInfo info;<br>        info = SkImageInfo::<span class="hljs-built_in">Make</span>(surfaceWidth, surfaceHeight, <span class="hljs-built_in">getSurfaceColorType</span>(),<br>                                 kPremul_SkAlphaType, <span class="hljs-built_in">getSurfaceColorSpace</span>());<br>        <span class="hljs-function">SkSurfaceProps <span class="hljs-title">props</span><span class="hljs-params">(<span class="hljs-number">0</span>, kUnknown_SkPixelGeometry)</span></span>;<br>        node-&gt;<span class="hljs-built_in">setLayerSurface</span>(SkSurface::<span class="hljs-built_in">MakeRenderTarget</span>(mRenderThread.<span class="hljs-built_in">getGrContext</span>(),<br>                                                          SkBudgeted::kYes, info, <span class="hljs-number">0</span>,<br>                                                          <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getSurfaceOrigin</span>(), &amp;props));<br>    <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们知道 <code>View</code> 是 framework ui api，<code>RenderNode</code> 相当于绘制这块 <code>View</code> 所需的配置文件；这里新增了一个新的概念 layer，它是这块 <code>View</code> 对应的 surface，它所呈现的内容将绘制在这个 surface 上，同 opengl 里 surface 的概念</p><p><code>RenderNode</code> 和它的脏区被添加到 <code>TreeInfo.layerUpdateQueue</code>；queue 里应该有两个元素，一个是 <code>HardwareRenderer.mRootNode</code> 对应的 native <code>RootRenderNode</code>，一个是 <code>DecorView.mRenderNode</code></p><h2 id="CanvasContext-draw"><a href="#CanvasContext-draw" class="headerlink" title="CanvasContext.draw"></a>CanvasContext.draw</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CanvasContext::draw</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 还记得上面说的吗，脏区是累加的，这里是总的脏区</span><br>    SkRect dirty;<br>    mDamageAccumulator.<span class="hljs-built_in">finish</span>(&amp;dirty);<br>    <span class="hljs-comment">// ...</span><br>    Frame frame = mRenderPipeline-&gt;<span class="hljs-built_in">getFrame</span>();<br>    <span class="hljs-built_in">setPresentTime</span>();<br>    <span class="hljs-comment">// 再次计算脏区</span><br>    SkRect windowDirty = <span class="hljs-built_in">computeDirtyRect</span>(frame, &amp;dirty);<br>    <span class="hljs-keyword">bool</span> drew = mRenderPipeline-&gt;<span class="hljs-built_in">draw</span>(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,<br>                                      mContentDrawBounds, mOpaque, mLightInfo, mRenderNodes,<br>                                      &amp;(<span class="hljs-built_in">profiler</span>()));<br>    <span class="hljs-keyword">int64_t</span> frameCompleteNr = <span class="hljs-built_in">getFrameNumber</span>();<br>    <span class="hljs-built_in">waitOnFences</span>();<br>    <span class="hljs-keyword">bool</span> requireSwap = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> error = OK;<br>    <span class="hljs-keyword">bool</span> didSwap = mRenderPipeline-&gt;<span class="hljs-built_in">swapBuffers</span>(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="getFrame"><a href="#getFrame" class="headerlink" title="getFrame"></a>getFrame</h2><p>看下 <code>Frame</code>，它包含 <code>EGLSurface</code> 和 surface 宽高</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Frame <span class="hljs-title">SkiaOpenGLPipeline::getFrame</span><span class="hljs-params">()</span></span><br><span class="hljs-function">Frame <span class="hljs-title">EglManager::beginFrame</span><span class="hljs-params">(EGLSurface surface)</span> </span>&#123;<br>    <span class="hljs-comment">// ... </span><br>    <span class="hljs-built_in">makeCurrent</span>(surface);<br>    Frame frame;<br>    frame.mSurface = surface;<br>    <span class="hljs-built_in">eglQuerySurface</span>(mEglDisplay, surface, EGL_WIDTH, &amp;frame.mWidth);<br>    <span class="hljs-built_in">eglQuerySurface</span>(mEglDisplay, surface, EGL_HEIGHT, &amp;frame.mHeight);<br>    frame.mBufferAge = <span class="hljs-built_in">queryBufferAge</span>(surface);<br>    <span class="hljs-built_in">eglBeginFrame</span>(mEglDisplay, surface);<br>    <span class="hljs-keyword">return</span> frame;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="IRenderPipeline-draw"><a href="#IRenderPipeline-draw" class="headerlink" title="IRenderPipeline::draw"></a>IRenderPipeline::draw</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SkiaOpenGLPipeline::draw</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkiaPipeline::renderFrame</span><span class="hljs-params">(...)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    SkCanvas* canvas = <span class="hljs-built_in">tryCapture</span>(surface.<span class="hljs-built_in">get</span>(), nodes[<span class="hljs-number">0</span>].<span class="hljs-built_in">get</span>(), layers);<br>    <span class="hljs-comment">// draw all layers up front</span><br>    <span class="hljs-built_in">renderLayersImpl</span>(layers, opaque);<br>    <span class="hljs-built_in">renderFrameImpl</span>(clip, nodes, opaque, contentDrawBounds, canvas, preTransform);<br>    <span class="hljs-built_in">endCapture</span>(surface.<span class="hljs-built_in">get</span>());<br>    <span class="hljs-comment">// 绘制「布局边界」、「渲染分析」等 debug 信息，这里略过</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_UNLIKELY</span>(Properties::debugOverdraw)) &#123;<br>        <span class="hljs-built_in">renderOverdraw</span>(clip, nodes, contentDrawBounds, surface, preTransform);<br>    &#125;<br>    surface-&gt;<span class="hljs-built_in">getCanvas</span>()-&gt;<span class="hljs-built_in">flush</span>();<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>SkiaPipeline::renderLayersImpl</code></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 看上面，layers 是在 RenderNode::prepareTree 阶段加入的，包括 </span><br><span class="hljs-comment">// HardwareRenderer.mRootNode 对应的 native RootRenderNode 和 DecorView.mRenderNode</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkiaPipeline::renderLayersImpl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> LayerUpdateQueue&amp; layers, <span class="hljs-keyword">bool</span> opaque)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; layers.<span class="hljs-built_in">entries</span>().<span class="hljs-built_in">size</span>(); i++) &#123;<br>        RenderNode* layerNode = layers.<span class="hljs-built_in">entries</span>()[i].renderNode.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-comment">// ...</span><br>        SkCanvas* layerCanvas = layerNode-&gt;<span class="hljs-built_in">getLayerSurface</span>()-&gt;<span class="hljs-built_in">getCanvas</span>();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-function">RenderNodeDrawable <span class="hljs-title">root</span><span class="hljs-params">(layerNode, layerCanvas, <span class="hljs-literal">false</span>)</span></span>;<br>        root.forceDraw(layerCanvas);<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// cache the current context so that we can defer flushing it until</span><br>        <span class="hljs-comment">// either all the layers have been rendered or the context changes</span><br>        GrContext* currentContext = layerNode-&gt;<span class="hljs-built_in">getLayerSurface</span>()-&gt;<span class="hljs-built_in">getCanvas</span>()-&gt;<span class="hljs-built_in">getGrContext</span>();<br>        <span class="hljs-keyword">if</span> (cachedContext.<span class="hljs-built_in">get</span>() != currentContext) &#123;<br>            <span class="hljs-keyword">if</span> (cachedContext.<span class="hljs-built_in">get</span>()) &#123;<br>                <span class="hljs-built_in">ATRACE_NAME</span>(<span class="hljs-string">&quot;flush layers (context changed)&quot;</span>);<br>                cachedContext-&gt;<span class="hljs-built_in">flush</span>();<br>            &#125;<br>            cachedContext.<span class="hljs-built_in">reset</span>(<span class="hljs-built_in">SkSafeRef</span>(currentContext));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    cachedContext-&gt;<span class="hljs-built_in">flush</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNodeDrawable::forceDraw</span><span class="hljs-params">(SkCanvas* canvas)</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNodeDrawable::drawContent</span><span class="hljs-params">(SkCanvas* canvas)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-comment">// displayList 是 layerNode 的，canvas 是 layerNode 对应的 layer surface 的</span><br>    <span class="hljs-comment">// 下面看看这个由 layer surface 作为 backend 的 canvas 做了什么</span><br>    displayList-&gt;<span class="hljs-built_in">draw</span>(canvas);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>RenderNode → mSkiaLayer → layerSurface，这里我们接触到 <code>RenderNode</code> 的一个属性/概念 layer</p><p>它是 <code>SkiaLayer</code> 结构体，主要包含一个 <code>layerSurface</code>，它是一个 offscreen render target，backend 可以是纹理、pixels buffer 等</p><p>它在 <code>SkiaPipeline::createOrUpdateLayer</code> 里通过 <code>RenderNode::setLayerSurface</code> 被赋予 <code>SkSurface_Gpu</code>；那么上面的 canvas 则是以 <code>SkGpuDevice</code> 为 backend 的 <code>SkCanvas</code>，所有的 draw 操作（onDrawXXX）都被重定向到 <code>SkGpuDevice</code>（drawXXX）；而在 <code>SkGpuDevice</code> 里，draw 操作又被重定向到 <code>GrRenderTargetContext</code>；在 <code>GrRenderTargetContext</code> 里，draw 操作被封装为 <code>GrDrawOp</code>，通过 <code>GrOpsTask::addDrawOp</code> 加入到 <code>GrRenderTargetContext::fOpsTask</code>；而 <code>GrRenderTargetContext::fOpsTask</code> 会被 <code>GrDrawingManager::fDAG</code> 持有</p><p>drawing op 在这里被再次包装，由 <code>DisplayList</code> 包装为 <code>GrDrawOp</code></p><p><code>RenderNode</code> 的 <code>DisplayList</code> 会被渲染到 layer 上</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Call to ensure all drawing to the context has been issued to the underlying 3D API.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GrContext::flush</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">GrSemaphoresSubmitted <span class="hljs-title">GrContext::flush</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GrFlushInfo&amp; info, <span class="hljs-keyword">const</span> GrPrepareForExternalIORequests&amp; externalRequests)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">GrSemaphoresSubmitted <span class="hljs-title">GrDrawingManager::flush</span><span class="hljs-params">(...)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">auto</span> direct = fContext-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">asDirectContext</span>();<br>    GrGpu* gpu = direct-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">getGpu</span>();<br>    fFlushing = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">auto</span> resourceProvider = direct-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">resourceProvider</span>();<br>    <span class="hljs-keyword">auto</span> resourceCache = direct-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">getResourceCache</span>();<br>    <span class="hljs-function">GrOpFlushState <span class="hljs-title">flushState</span><span class="hljs-params">(gpu, resourceProvider, &amp;fTokenTracker, fCpuBufferCache)</span></span>;<br>    <span class="hljs-function">GrOnFlushResourceProvider <span class="hljs-title">onFlushProvider</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">int</span> startIndex, stopIndex;<br>    <span class="hljs-keyword">bool</span> flushed = <span class="hljs-literal">false</span>;<br>    &#123;<br>        <span class="hljs-keyword">while</span> (alloc.<span class="hljs-built_in">assign</span>(&amp;startIndex, &amp;stopIndex, &amp;error)) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">executeRenderTasks</span>(startIndex, stopIndex, &amp;flushState, &amp;numRenderTasksExecuted)) &#123;<br>                flushed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    fDAG.<span class="hljs-built_in">reset</span>();<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">clearDDLTargets</span>();<br>    GrSemaphoresSubmitted result = gpu-&gt;<span class="hljs-built_in">finishFlush</span>(proxies, numProxies, access, info, externalRequests);<br>    <span class="hljs-comment">// Give the cache a chance to purge resources that become purgeable due to flushing.</span><br>    <span class="hljs-keyword">if</span> (flushed) &#123;<br>        resourceCache-&gt;<span class="hljs-built_in">purgeAsNeeded</span>();<br>        flushed = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (GrOnFlushCallbackObject* onFlushCBObject : fOnFlushCBObjects) &#123;<br>        onFlushCBObject-&gt;<span class="hljs-built_in">postFlush</span>(fTokenTracker.<span class="hljs-built_in">nextTokenToFlush</span>(), fFlushingRenderTaskIDs.<span class="hljs-built_in">begin</span>(),<br>                                   fFlushingRenderTaskIDs.<span class="hljs-built_in">count</span>());<br>        flushed = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flushed) &#123;<br>        resourceCache-&gt;<span class="hljs-built_in">purgeAsNeeded</span>();<br>    &#125;<br>    fFlushingRenderTaskIDs.<span class="hljs-built_in">reset</span>();<br>    fFlushing = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">GrDrawingManager::executeRenderTasks</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startIndex, <span class="hljs-keyword">int</span> stopIndex, GrOpFlushState* flushState,</span></span><br><span class="hljs-function"><span class="hljs-params">                                          <span class="hljs-keyword">int</span>* numRenderTasksExecuted)</span> </span>&#123;<br>    <span class="hljs-built_in">SkASSERT</span>(startIndex &lt;= stopIndex &amp;&amp; stopIndex &lt;= fDAG.<span class="hljs-built_in">numRenderTasks</span>());<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> GR_FLUSH_TIME_OP_SPEW</span><br>    <span class="hljs-built_in">SkDebugf</span>(<span class="hljs-string">&quot;Flushing opsTask: %d to %d out of [%d, %d]\n&quot;</span>, startIndex, stopIndex, <span class="hljs-number">0</span>, fDAG.<span class="hljs-built_in">numRenderTasks</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt; stopIndex; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (fDAG.<span class="hljs-built_in">renderTask</span>(i)) &#123;<br>            fDAG.<span class="hljs-built_in">renderTask</span>(i)-&gt;<span class="hljs-built_in">dump</span>(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-keyword">bool</span> anyRenderTasksExecuted = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt; stopIndex; ++i) &#123;<br>        GrRenderTask* renderTask = fDAG.<span class="hljs-built_in">renderTask</span>(i);<br>        <span class="hljs-keyword">if</span> (!renderTask || !renderTask-&gt;<span class="hljs-built_in">isInstantiated</span>()) &#123;<br>             <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-built_in">SkASSERT</span>(renderTask-&gt;<span class="hljs-built_in">deferredProxiesAreInstantiated</span>());<br>        renderTask-&gt;<span class="hljs-built_in">prepare</span>(flushState);<br>    &#125;<br><br>    <span class="hljs-comment">// Upload all data to the GPU</span><br>    flushState-&gt;<span class="hljs-built_in">preExecuteDraws</span>();<br><br>    <span class="hljs-comment">// For Vulkan, if we have too many oplists to be flushed we end up allocating a lot of resources</span><br>    <span class="hljs-comment">// for each command buffer associated with the oplists. If this gets too large we can cause the</span><br>    <span class="hljs-comment">// devices to go OOM. In practice we usually only hit this case in our tests, but to be safe we</span><br>    <span class="hljs-comment">// put a cap on the number of oplists we will execute before flushing to the GPU to relieve some</span><br>    <span class="hljs-comment">// memory pressure.</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> kMaxRenderTasksBeforeFlush = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-comment">// Execute the onFlush renderTasks first, if any.</span><br>    <span class="hljs-keyword">for</span> (sk_sp&lt;GrRenderTask&gt;&amp; onFlushRenderTask : fOnFlushRenderTasks) &#123;<br>        <span class="hljs-keyword">if</span> (!onFlushRenderTask-&gt;<span class="hljs-built_in">execute</span>(flushState)) &#123;<br>            <span class="hljs-built_in">SkDebugf</span>(<span class="hljs-string">&quot;WARNING: onFlushRenderTask failed to execute.\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">SkASSERT</span>(onFlushRenderTask-&gt;<span class="hljs-built_in">unique</span>());<br>        onFlushRenderTask = <span class="hljs-literal">nullptr</span>;<br>        (*numRenderTasksExecuted)++;<br>        <span class="hljs-keyword">if</span> (*numRenderTasksExecuted &gt;= kMaxRenderTasksBeforeFlush) &#123;<br>            flushState-&gt;<span class="hljs-built_in">gpu</span>()-&gt;<span class="hljs-built_in">finishFlush</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, SkSurface::BackendSurfaceAccess::kNoAccess,<br>                                           <span class="hljs-built_in">GrFlushInfo</span>(), <span class="hljs-built_in">GrPrepareForExternalIORequests</span>());<br>            *numRenderTasksExecuted = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    fOnFlushRenderTasks.<span class="hljs-built_in">reset</span>();<br><br>    <span class="hljs-comment">// Execute the normal op lists.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startIndex; i &lt; stopIndex; ++i) &#123;<br>        GrRenderTask* renderTask = fDAG.<span class="hljs-built_in">renderTask</span>(i);<br>        <span class="hljs-keyword">if</span> (!renderTask || !renderTask-&gt;<span class="hljs-built_in">isInstantiated</span>()) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (renderTask-&gt;<span class="hljs-built_in">execute</span>(flushState)) &#123;<br>            anyRenderTasksExecuted = <span class="hljs-literal">true</span>;<br>        &#125;<br>        (*numRenderTasksExecuted)++;<br>        <span class="hljs-keyword">if</span> (*numRenderTasksExecuted &gt;= kMaxRenderTasksBeforeFlush) &#123;<br>            flushState-&gt;<span class="hljs-built_in">gpu</span>()-&gt;<span class="hljs-built_in">finishFlush</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, SkSurface::BackendSurfaceAccess::kNoAccess,<br>                                           <span class="hljs-built_in">GrFlushInfo</span>(), <span class="hljs-built_in">GrPrepareForExternalIORequests</span>());<br>            *numRenderTasksExecuted = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">SkASSERT</span>(!flushState-&gt;<span class="hljs-built_in">opsRenderPass</span>());<br>    <span class="hljs-built_in">SkASSERT</span>(fTokenTracker.<span class="hljs-built_in">nextDrawToken</span>() == fTokenTracker.<span class="hljs-built_in">nextTokenToFlush</span>());<br><br>    <span class="hljs-comment">// We reset the flush state before the RenderTasks so that the last resources to be freed are</span><br>    <span class="hljs-comment">// those that are written to in the RenderTasks. This helps to make sure the most recently used</span><br>    <span class="hljs-comment">// resources are the last to be purged by the resource cache.</span><br>    flushState-&gt;<span class="hljs-built_in">reset</span>();<br>    fDAG.<span class="hljs-built_in">removeRenderTasks</span>(startIndex, stopIndex);<br>    <span class="hljs-keyword">return</span> anyRenderTasksExecuted;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最终 <code>flush</code> 将 <code>GrDrawOp</code> 转换为 opengl 命令并提交给 gpu 执行，下面看看绘制一个矩形 <code>GrFillRectOp</code> 是怎么转换为 opengl 命令的</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkCanvas::drawRect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> SkRect&amp; r, <span class="hljs-keyword">const</span> SkPaint&amp; paint)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkCanvas::onDrawRect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> SkRect&amp; r, <span class="hljs-keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">needs_autodrawlooper</span>(<span class="hljs-keyword">this</span>, paint)) &#123;<br>        <span class="hljs-built_in">LOOPER_BEGIN_CHECK_COMPLETE_OVERWRITE</span>(paint, &amp;r, <span class="hljs-literal">false</span>)<br>        <span class="hljs-keyword">while</span> (iter.<span class="hljs-built_in">next</span>()) &#123;<br>            iter.fDevice-&gt;<span class="hljs-built_in">drawRect</span>(r, looper.<span class="hljs-built_in">paint</span>());<br>        &#125;<br>        LOOPER_END<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkGpuDevice::drawRect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> SkRect&amp; rect, <span class="hljs-keyword">const</span> SkPaint&amp; paint)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GrRenderTargetContext::drawRect</span><span class="hljs-params">(...)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">const</span> SkStrokeRec&amp; stroke = style-&gt;<span class="hljs-built_in">strokeRec</span>();<br>    <span class="hljs-keyword">if</span> (stroke.<span class="hljs-built_in">getStyle</span>() == SkStrokeRec::kFill_Style) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">drawFilledRect</span>(clip, std::<span class="hljs-built_in">move</span>(paint), aa, viewMatrix, rect);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GrRenderTargetContext::drawFilledRect</span><span class="hljs-params">(...)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    GrAAType aaType = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">chooseAAType</span>(aa, GrAllowMixedSamples::kNo);<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">addDrawOp</span>(clip, GrFillRectOp::<span class="hljs-built_in">Make</span>(fContext, std::<span class="hljs-built_in">move</span>(paint), aaType, viewMatrix,<br>                                             croppedRect, ss));<br>&#125;<br></code></pre></div></td></tr></table></figure><p>看看 <code>GrFillRectOp</code> 的定义</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">std::unique_ptr&lt;GrDrawOp&gt; <span class="hljs-title">GrFillRectOp::Make</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> std::unique_ptr&lt;GrDrawOp&gt; <span class="hljs-title">Make</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function"></span><br>template &lt;typename Op, typename... OpArgs&gt;<br><span class="hljs-function"><span class="hljs-keyword">static</span> std::unique_ptr&lt;GrDrawOp&gt; <span class="hljs-title">FactoryHelper</span><span class="hljs-params">(GrRecordingContext* context, GrPaint&amp;&amp; paint, OpArgs... opArgs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> GrSimpleMeshDrawOpHelper::FactoryHelper&lt;Op, OpArgs...&gt;(context, std::<span class="hljs-built_in">move</span>(paint), std::forward&lt;OpArgs&gt;(opArgs)...);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Op, <span class="hljs-keyword">typename</span>... OpArgs&gt;<br><span class="hljs-function">std::unique_ptr&lt;GrDrawOp&gt; <span class="hljs-title">GrSimpleMeshDrawOpHelper::FactoryHelper</span><span class="hljs-params">(GrRecordingContext* context,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                                  GrPaint&amp;&amp; paint,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                                  OpArgs... opArgs)</span> </span>&#123;<br>    GrOpMemoryPool* pool = context-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">opMemoryPool</span>();<br>    MakeArgs makeArgs;<br>    <span class="hljs-keyword">if</span> (paint.<span class="hljs-built_in">isTrivial</span>()) &#123;<br>        makeArgs.fProcessorSet = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> pool-&gt;allocate&lt;Op&gt;(makeArgs, paint.<span class="hljs-built_in">getColor4f</span>(), std::forward&lt;OpArgs&gt;(opArgs)...);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-built_in">FillRectOp</span>(Helper::MakeArgs args, SkPMColor4f paintColor, GrAAType aaType,<br>               DrawQuad* quad, <span class="hljs-keyword">const</span> GrUserStencilSettings* stencil, Helper::InputFlags inputFlags)<br>            : <span class="hljs-built_in">INHERITED</span>(<span class="hljs-built_in">ClassID</span>())<br>            , <span class="hljs-built_in">fHelper</span>(args, aaType, stencil, inputFlags)<br>            , <span class="hljs-built_in">fQuads</span>(<span class="hljs-number">1</span>, !fHelper.<span class="hljs-built_in">isTrivial</span>()) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GrRenderTargetContext::addDrawOp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GrClip&amp; clip, std::unique_ptr&lt;GrDrawOp&gt; op,</span></span><br><span class="hljs-function"><span class="hljs-params">                                      <span class="hljs-keyword">const</span> std::function&lt;WillAddOpFn&gt;&amp; willAddFn)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> opList = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getRTOpList</span>();<br>    <span class="hljs-comment">// ...</span><br>    opList-&gt;<span class="hljs-built_in">addDrawOp</span>(std::<span class="hljs-built_in">move</span>(op), analysis, std::<span class="hljs-built_in">move</span>(appliedClip), dstProxy, *<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">caps</span>());<br>&#125;<br><br><span class="hljs-function">GrRenderTargetOpList* <span class="hljs-title">GrRenderTargetContext::getRTOpList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (!fOpList || fOpList-&gt;<span class="hljs-built_in">isClosed</span>()) &#123;<br>        fOpList = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">drawingManager</span>()-&gt;<span class="hljs-built_in">newRTOpList</span>(fRenderTargetProxy.<span class="hljs-built_in">get</span>(), fManagedOpList);<br>    &#125;<br>    <span class="hljs-keyword">return</span> fOpList.<span class="hljs-built_in">get</span>();<br>&#125;<br><br><span class="hljs-function">sk_sp&lt;GrRenderTargetOpList&gt; <span class="hljs-title">GrDrawingManager::newRTOpList</span><span class="hljs-params">(GrRenderTargetProxy* rtp, <span class="hljs-keyword">bool</span> managedOpList)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">auto</span> resourceProvider = fContext-&gt;<span class="hljs-built_in">contextPriv</span>().<span class="hljs-built_in">resourceProvider</span>();<br>    <span class="hljs-function">sk_sp&lt;GrRenderTargetOpList&gt; <span class="hljs-title">opList</span><span class="hljs-params">(<span class="hljs-keyword">new</span> GrRenderTargetOpList(resourceProvider, fContext-&gt;contextPriv().refOpMemoryPool(), rtp, fContext-&gt;contextPriv().getAuditTrail()))</span></span>;<br>    <span class="hljs-keyword">if</span> (managedOpList) &#123;<br>        fDAG.<span class="hljs-built_in">add</span>(opList);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> opList;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GrRenderTargetOpList::addDrawOp</span><span class="hljs-params">(...)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> addDependency = [ &amp;caps, <span class="hljs-keyword">this</span> ] (GrSurfaceProxy* p) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">addDependency</span>(p, caps);<br>    &#125;;<br>    op-&gt;<span class="hljs-built_in">visitProxies</span>(addDependency);<br>    clip.<span class="hljs-built_in">visitProxies</span>(addDependency);<br>    <span class="hljs-keyword">if</span> (dstProxy.<span class="hljs-built_in">proxy</span>()) &#123;<br>        <span class="hljs-built_in">addDependency</span>(dstProxy.<span class="hljs-built_in">proxy</span>());<br>    &#125;<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">recordOp</span>(std::<span class="hljs-built_in">move</span>(op), processorAnalysis, clip.<span class="hljs-built_in">doesClip</span>() ? &amp;clip : <span class="hljs-literal">nullptr</span>, &amp;dstProxy, caps);<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FillRectOp</span> <span class="hljs-keyword">final</span> :</span> <span class="hljs-keyword">public</span> GrMeshDrawOp &#123;<br>    <span class="hljs-function">VertexSpec <span class="hljs-title">vertexSpec</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> indexBufferOption = GrQuadPerEdgeAA::<span class="hljs-built_in">CalcIndexBufferOption</span>(fHelper.<span class="hljs-built_in">aaType</span>(), fQuads.<span class="hljs-built_in">count</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">VertexSpec</span>(fQuads.<span class="hljs-built_in">deviceQuadType</span>(), fColorType, fQuads.<span class="hljs-built_in">localQuadType</span>(),<br>            fHelper.<span class="hljs-built_in">usesLocalCoords</span>(), GrQuadPerEdgeAA::Domain::kNo,<br>            fHelper.<span class="hljs-built_in">aaType</span>(),<br>            fHelper.<span class="hljs-built_in">compatibleWithCoverageAsAlpha</span>(), indexBufferOption);<br>    &#125;   <br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tessellate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> VertexSpec&amp; vertexSpec, <span class="hljs-keyword">char</span>* dst)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> SkRect kEmptyDomain = SkRect::<span class="hljs-built_in">MakeEmpty</span>();<br>        <span class="hljs-function">GrQuadPerEdgeAA::Tessellator <span class="hljs-title">tessellator</span><span class="hljs-params">(vertexSpec, dst)</span></span>;<br>        <span class="hljs-keyword">auto</span> iter = fQuads.<span class="hljs-built_in">iterator</span>();<br>        <span class="hljs-keyword">while</span> (iter.<span class="hljs-built_in">next</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> info = iter.<span class="hljs-built_in">metadata</span>();<br>            tessellator.<span class="hljs-built_in">append</span>(iter.<span class="hljs-built_in">deviceQuad</span>(), iter.<span class="hljs-built_in">localQuad</span>(), info.fColor, kEmptyDomain, info.fAAFlags);<br>        &#125;<br>    &#125;   <br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onPrePrepareDraws</span><span class="hljs-params">(...)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        SkArenaAlloc* arena = context-&gt;<span class="hljs-built_in">priv</span>().<span class="hljs-built_in">recordTimeAllocator</span>();<br>        <span class="hljs-keyword">const</span> VertexSpec vertexSpec = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">vertexSpec</span>();<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> totalNumVertices = fQuads.<span class="hljs-built_in">count</span>() * vertexSpec.<span class="hljs-built_in">verticesPerQuad</span>();<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> totalVertexSizeInBytes = vertexSpec.<span class="hljs-built_in">vertexSize</span>() * totalNumVertices;<br>        fPrePreparedVertices = arena-&gt;makeArrayDefault&lt;<span class="hljs-keyword">char</span>&gt;(totalVertexSizeInBytes);<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">tessellate</span>(vertexSpec, fPrePreparedVertices);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vsync</tag>
      
      <tag>render thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 图形栈（二）ui thread</title>
    <link href="/blog/2020/12/13/ui-thread-in-vsync/"/>
    <url>/blog/2020/12/13/ui-thread-in-vsync/</url>
    
    <content type="html"><![CDATA[<h2 id="从一段-systrace-开始"><a href="#从一段-systrace-开始" class="headerlink" title="从一段 systrace 开始"></a>从一段 systrace 开始</h2><p><img src="../../../../image/2020-12-13-ui-thread-in-vsync/114050.png" alt="114050.png"></p><p>这是一段 systrace 记录，看得出来页面是比较流畅的，ui thread 全都在一个 VSYNC_app 内完成绘制，surfaceflinger 也在一个 VSYNC_sf 内完成各个层的合成；但有没发现在 ui thread 完成 <code>doFrame</code> 后，总是会有一个 <code>ReaderThread</code> 跟在后面，看名字像是跟渲染相关的线程，它跟 ui 绘制有关系吗？平时我们常说的，只要 ui thread 在一个刷新周期 16ms 内完成 view 的绘制，即可保证页面流畅，真的是这样吗？</p><h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 从 ViewRootImpl 开始</span><br>ViewRootImpl.doTraversal()<br>ViewRootImpl.performTraversals()<br>ViewRootImpl.performDraw()<br>ViewRootImpl.draw(<span class="hljs-keyword">boolean</span> fullRedrawNeeded)<br><br><span class="hljs-comment">// 进入 ThreadedRenderer</span><br>ThreadedRenderer.draw(View view, AttachInfo attachInfo, DrawCallbacks callbacks) &#123;<br>    <span class="hljs-comment">// ...</span><br>    updateRootDisplayList(view, callbacks);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">int</span> syncResult = syncAndDrawFrame(choreographer.mFrameInfo);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里出现了两个很重要的函数：<code>updateRootDisplayList</code> 和 <code>syncAndDrawFrame</code>，我们一个个看</p><h2 id="updateRootDisplayList"><a href="#updateRootDisplayList" class="headerlink" title="updateRootDisplayList"></a>updateRootDisplayList</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ThreadedRenderer.updateRootDisplayList(View view, DrawCallbacks callbacks) &#123;<br>    <span class="hljs-comment">// ...</span><br>    updateViewTreeDisplayList(view);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.hasDisplayList()) &#123;<br>        RecordingCanvas canvas = mRootNode.beginRecording(mSurfaceWidth, mSurfaceHeight);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// ...</span><br>            canvas.drawRenderNode(view.updateDisplayListIfDirty());<br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mRootNode.endRecording();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>两段逻辑：</p><ol><li><code>updateViewTreeDisplayList(view)</code>，其中 view 是 root view 也就是 <code>DecorView</code></li><li><code>Canvas.drawRenderNode</code>，<code>RenderNode</code> 是 View 返回的</li></ol><h2 id="updateViewTreeDisplayList"><a href="#updateViewTreeDisplayList" class="headerlink" title="updateViewTreeDisplayList"></a>updateViewTreeDisplayList</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ThreadedRenderer.updateViewTreeDisplayList(View view)<br>RenderNode View.updateDisplayListIfDirty() &#123;<br>    <span class="hljs-keyword">final</span> RenderNode renderNode = mRenderNode;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">final</span> RecordingCanvas canvas = renderNode.beginRecording(width, height);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        draw(canvas);<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        renderNode.endRecording();<br>        setDisplayListProperties(renderNode);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> renderNode;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最终在这里调用了 <code>View.draw</code>，里面就是常规的画布绘制操作，我们继续看看 <code>RecordingCanvas</code> 这个类</p><h2 id="RecordingCanvas"><a href="#RecordingCanvas" class="headerlink" title="RecordingCanvas"></a>RecordingCanvas</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecordingCanvas</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DisplayListCanvas</span></span><br><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">abstract</span> <span class="hljs-title">class</span> <span class="hljs-title">DisplayListCanvas</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseRecordingCanvas</span></span><br><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">BaseRecordingCanvas</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Canvas</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawArc</span><span class="hljs-params">(<span class="hljs-keyword">float</span> left, <span class="hljs-keyword">float</span> top, <span class="hljs-keyword">float</span> right, <span class="hljs-keyword">float</span> bottom, <span class="hljs-keyword">float</span> startAngle,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">float</span> sweepAngle, <span class="hljs-keyword">boolean</span> useCenter, <span class="hljs-meta">@NonNull</span> Paint paint)</span> </span>&#123;<br>        nDrawArc(mNativeCanvasWrapper, left, top, right, bottom, startAngle, sweepAngle,<br>                useCenter, paint.getNativeInstance());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawBitmap</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Bitmap bitmap, <span class="hljs-keyword">float</span> left, <span class="hljs-keyword">float</span> top,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@Nullable</span> Paint paint)</span> </span>&#123;<br>        throwIfCannotDraw(bitmap);<br>        nDrawBitmap(mNativeCanvasWrapper, bitmap.getNativeInstance(), left, top,<br>                paint != <span class="hljs-keyword">null</span> ? paint.getNativeInstance() : <span class="hljs-number">0</span>, mDensity, mScreenDensity,<br>                bitmap.mDensity);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawRect</span><span class="hljs-params">(<span class="hljs-keyword">float</span> left, <span class="hljs-keyword">float</span> top, <span class="hljs-keyword">float</span> right, <span class="hljs-keyword">float</span> bottom,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> Paint paint)</span> </span>&#123;<br>        nDrawRect(mNativeCanvasWrapper, left, top, right, bottom, paint.getNativeInstance());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>RecordingCanvas</code> 继承自 <code>DisplayListCanvas</code>，<code>DisplayListCanvas</code> 继承自 <code>BaseRecordingCanvas</code></p><p>在 <code>BaseRecordingCanvas</code> 里，<code>View.draw(Canvas)</code> 所用到的 <code>drawBitmap</code>、<code>drawText</code>、<code>drawRect</code> 等绘图方法都被重定向到 <code>BaseCanvas.mNativeCanvasWrapper</code>，继续看看它指向谁</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 从构造开始</span><br>RecordingCanvas RenderNode.beginRecording(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height) &#123;<br>    <span class="hljs-comment">// ...</span><br>    mCurrentRecordingCanvas = RecordingCanvas.obtain(<span class="hljs-keyword">this</span>, width, height);<br>    <span class="hljs-keyword">return</span> mCurrentRecordingCanvas;<br>&#125;<br>RecordingCanvas RecordingCanvas.obtain(RenderNode node, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height) &#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;node cannot be null&quot;</span>);<br>    RecordingCanvas canvas = sPool.acquire();<br>    <span class="hljs-keyword">if</span> (canvas == <span class="hljs-keyword">null</span>) &#123;<br>        canvas = <span class="hljs-keyword">new</span> RecordingCanvas(node, width, height);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        nResetDisplayListCanvas(canvas.mNativeCanvasWrapper, node.mNativeRenderNode, width, height);<br>    &#125;<br>    canvas.mNode = node;<br>    canvas.mWidth = width;<br>    canvas.mHeight = height;<br>    <span class="hljs-keyword">return</span> canvas;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>RecordingCanvas</code> 会被频繁地创建和销毁，所以用了池化，池子大小是 25，从池子里拿出的对象用 <code>nResetDisplayListCanvas</code> 重置；我们走创建新实例这条路继续看下去</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">RecordingCanvas</span><span class="hljs-params">(RenderNode node, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(nCreateDisplayListCanvas(node.mNativeRenderNode, width, height));<br>&#125;<br><br><span class="hljs-comment">// /frameworks/base/core/jni/android_view_DisplayListCanvas.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">android_view_DisplayListCanvas_createDisplayListCanvas</span><span class="hljs-params">(jlong renderNodePtr, jint width, jint height)</span> </span>&#123;<br>    RenderNode* renderNode = reinterpret_cast&lt;RenderNode*&gt;(renderNodePtr);<br>    <span class="hljs-keyword">return</span> reinterpret_cast&lt;jlong&gt;(Canvas::create_recording_canvas(width, height, renderNode));<br>&#125;<br><br>Canvas* Canvas::create_recording_canvas(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, uirenderer::RenderNode* renderNode) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> uirenderer::skiapipeline::SkiaRecordingCanvas(renderNode, width, height);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到 <code>RecordingCanvas.mNativeCanvasWrapper</code> 是 native <code>SkiaRecordingCanvas</code></p><p><code>SkiaRecordingCanvas</code> 继承自 <code>SkiaCanvas</code>，大部分 2D 绘图方法都是由 <code>SkiaCanvas</code> 实现的，而 <code>SkiaCanvas</code> 又把绘图操作交由 <code>SkiaCanvas.mCanvas</code> 执行，我们看下它指向谁</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SkiaRecordingCanvas</span><span class="hljs-params">(uirenderer::RenderNode* renderNode, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>    <span class="hljs-built_in">initDisplayList</span>(renderNode, width, height);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkiaRecordingCanvas::initDisplayList</span><span class="hljs-params">(uirenderer::RenderNode* renderNode, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>    mCurrentBarrier = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-built_in">SkASSERT</span>(mDisplayList.<span class="hljs-built_in">get</span>() == <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-keyword">if</span> (renderNode) &#123;<br>        mDisplayList = renderNode-&gt;<span class="hljs-built_in">detachAvailableList</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!mDisplayList) &#123;<br>        mDisplayList.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">SkiaDisplayList</span>());<br>    &#125;<br><br>    mDisplayList-&gt;<span class="hljs-built_in">attachRecorder</span>(&amp;mRecorder, SkIRect::<span class="hljs-built_in">MakeWH</span>(width, height));<br>    SkiaCanvas::<span class="hljs-built_in">reset</span>(&amp;mRecorder);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkiaCanvas::reset</span><span class="hljs-params">(SkCanvas* skiaCanvas)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mCanvas != skiaCanvas) &#123;<br>        mCanvas = skiaCanvas;<br>        mCanvasOwned.<span class="hljs-built_in">reset</span>();<br>    &#125;<br>    mSaveStack.<span class="hljs-built_in">reset</span>(<span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>SkiaRecordingCanvas.mRecorder</code> 被赋值给了 <code>SkiaCanvas.mCanvas</code>，它是 <code>RecordingCanvaas</code>，而它又把 draw 交由 <code>RecordingCanvas.fDL</code> 执行</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DisplayListData::drawRect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> SkRect&amp; rect, <span class="hljs-keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;push&lt;DrawRect&gt;(<span class="hljs-number">0</span>, rect, paint);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DrawRect</span> <span class="hljs-keyword">final</span> :</span> Op &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> kType = Type::DrawRect;<br>    <span class="hljs-built_in">DrawRect</span>(<span class="hljs-keyword">const</span> SkRect&amp; rect, <span class="hljs-keyword">const</span> SkPaint&amp; paint) : <span class="hljs-built_in">rect</span>(rect), <span class="hljs-built_in">paint</span>(paint) &#123;&#125;<br>    SkRect rect;<br>    SkPaint paint;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(SkCanvas* c, <span class="hljs-keyword">const</span> SkMatrix&amp;)</span> <span class="hljs-keyword">const</span> </span>&#123; c-&gt;<span class="hljs-built_in">drawRect</span>(rect, paint); &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DisplayListData::drawImage</span><span class="hljs-params">(sk_sp&lt;<span class="hljs-keyword">const</span> SkImage&gt; image, SkScalar x, SkScalar y, onst SkPaint* paint, BitmapPalette palette)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;push&lt;DrawImage&gt;(<span class="hljs-number">0</span>, std::<span class="hljs-built_in">move</span>(image), x, y, paint, palette);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DrawImage</span> <span class="hljs-keyword">final</span> :</span> Op &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> kType = Type::DrawImage;<br>    <span class="hljs-built_in">DrawImage</span>(sk_sp&lt;<span class="hljs-keyword">const</span> SkImage&gt;&amp;&amp; image, SkScalar x, SkScalar y, <span class="hljs-keyword">const</span> SkPaint* paint, BitmapPalette palette)<br>            : <span class="hljs-built_in">image</span>(std::<span class="hljs-built_in">move</span>(image)), <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y), <span class="hljs-built_in">palette</span>(palette) &#123;<br>        <span class="hljs-keyword">if</span> (paint) &#123;<br>            <span class="hljs-keyword">this</span>-&gt;paint = *paint;<br>        &#125;<br>    &#125;<br>    sk_sp&lt;<span class="hljs-keyword">const</span> SkImage&gt; image;<br>    SkScalar x, y;<br>    SkPaint paint;<br>    BitmapPalette palette;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(SkCanvas* c, <span class="hljs-keyword">const</span> SkMatrix&amp;)</span> <span class="hljs-keyword">const</span> </span>&#123; c-&gt;<span class="hljs-built_in">drawImage</span>(image.<span class="hljs-built_in">get</span>(), x, y, &amp;paint); &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><code>RecordingCanvas.fDL</code> 是个 <code>DisplayListData</code>，它把绘图操作的所有参数记录为一个结构体 Op 并记录起来</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkiaRecordingCanvas::initDisplayList</span><span class="hljs-params">(uirenderer::RenderNode* renderNode, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SkiaDisplayList::attachRecorder</span><span class="hljs-params">(RecordingCanvas* recorder, <span class="hljs-keyword">const</span> SkIRect&amp; bounds)</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RecordingCanvas::reset</span><span class="hljs-params">(DisplayListData* dl, <span class="hljs-keyword">const</span> SkIRect&amp; bounds)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">resetCanvas</span>(bounds.<span class="hljs-built_in">right</span>(), bounds.<span class="hljs-built_in">bottom</span>());<br>    fDL = dl;<br>    mClipMayBeComplex = <span class="hljs-literal">false</span>;<br>    mSaveCount = mComplexSaveCount = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>总结下：java <code>RecordingCanvas.mNativeCanvasWrapper</code> 持有 native <code>SkiaRecordingCanvas</code>，<code>SkiaRecordingCanvas→mDisplayList→mDisplayList</code> 里记录所有的绘图操作</p><h2 id="endRecording"><a href="#endRecording" class="headerlink" title="endRecording"></a>endRecording</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">RenderNode View.<span class="hljs-built_in">updateDisplayListIfDirty</span>() &#123;<br>    <span class="hljs-keyword">final</span> RenderNode renderNode = mRenderNode;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">final</span> RecordingCanvas canvas = renderNode.<span class="hljs-built_in">beginRecording</span>(width, height);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-built_in">draw</span>(canvas);<br>        <span class="hljs-comment">// ...</span><br>    &#125; finally &#123;<br>        renderNode.<span class="hljs-built_in">endRecording</span>();<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> renderNode;<br>&#125;<br><br>RecordingCanvas.<span class="hljs-built_in">endRecording</span>() &#123;<br>    <span class="hljs-comment">// ...</span><br>    RecordingCanvas canvas = mCurrentRecordingCanvas;<br>    mCurrentRecordingCanvas = null;<br>    <span class="hljs-keyword">long</span> displayList = canvas.<span class="hljs-built_in">finishRecording</span>();<br>    <span class="hljs-built_in">nSetDisplayList</span>(mNativeRenderNode, displayList);<br>    canvas.<span class="hljs-built_in">recycle</span>();<br>&#125;<br><br><span class="hljs-function">uirenderer::DisplayList* <span class="hljs-title">SkiaRecordingCanvas::finishRecording</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> mDisplayList.<span class="hljs-built_in">release</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RenderNode::setStagingDisplayList</span><span class="hljs-params">(DisplayList* displayList)</span> </span>&#123;<br>    mValid = (displayList != <span class="hljs-literal">nullptr</span>);<br>    mNeedsDisplayListSync = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">delete</span> mStagingDisplayList;<br>    mStagingDisplayList = displayList;<br>&#125;<br><br>RecordingCanvas.<span class="hljs-built_in">recycle</span>() &#123;<br>    mNode = null;<br>    sPool.<span class="hljs-built_in">release</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最终，<code>RecordingCanvas</code> 被回收到池里，保存了绘制 Op 的 <code>SkiaDisplayList</code> 被转移到 native <code>RenderNode.mStagingDisplayList</code></p><h2 id="drawRenderNode"><a href="#drawRenderNode" class="headerlink" title="drawRenderNode"></a>drawRenderNode</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ThreadedRenderer.updateRootDisplayList(View view, DrawCallbacks callbacks) &#123;<br>    <span class="hljs-comment">// ...</span><br>    updateViewTreeDisplayList(view);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.hasDisplayList()) &#123;<br>        RecordingCanvas canvas = mRootNode.beginRecording(mSurfaceWidth, mSurfaceHeight);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// ...</span><br>            canvas.drawRenderNode(view.updateDisplayListIfDirty());<br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mRootNode.endRecording();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> SkiaRecordingCanvas::drawRenderNode(uirenderer::RenderNode* renderNode) &#123;<br>    <span class="hljs-comment">// Record the child node. Drawable dtor will be invoked when mChildNodes deque is cleared.</span><br>    mDisplayList-&gt;mChildNodes.emplace_back(renderNode, asSkCanvas(), <span class="hljs-keyword">true</span>, mCurrentBarrier);<br>    auto&amp; renderNodeDrawable = mDisplayList-&gt;mChildNodes.back();<br>    <span class="hljs-keyword">if</span> (Properties::getRenderPipelineType() == RenderPipelineType::SkiaVulkan) &#123;<br>        <span class="hljs-comment">// Put Vulkan WebViews with non-rectangular clips in a HW layer</span><br>        renderNode-&gt;mutateStagingProperties().setClipMayBeComplex(mRecorder.isClipMayBeComplex());<br>    &#125;<br>    drawDrawable(&amp;renderNodeDrawable);<br><br>    <span class="hljs-comment">// use staging property, since recording on UI thread</span><br>    <span class="hljs-keyword">if</span> (renderNode-&gt;stagingProperties().isProjectionReceiver()) &#123;<br>        mDisplayList-&gt;mProjectionReceiver = &amp;renderNodeDrawable;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上面，<code>DecorView</code> 的 DisplayList 已经被更新过了，所以 <code>view.updateDisplayListIfDirty()</code> 直接返回它的 <code>RenderNode</code></p><p>beginRecording → draw → endRecording 三步走跟上面的是一样的，<code>HardwareRenderer.mRootNode</code> 对应的是 native <code>RootRenderNode</code>；它的 <code>mStagingDisplayList</code> 只有一个 <code>RenderNodeDrawable</code></p><h2 id="syncAndDrawFrame"><a href="#syncAndDrawFrame" class="headerlink" title="syncAndDrawFrame"></a>syncAndDrawFrame</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 现在从新回到开头的地方</span><br><span class="hljs-keyword">void</span> ThreadedRenderer.draw(View view, AttachInfo attachInfo, DrawCallbacks callbacks) &#123;<br>    <span class="hljs-comment">// ... 这里会调用 View.draw(Canvas)，并把绘制 op 保存起来</span><br>    updateRootDisplayList(view, callbacks);<br>    <span class="hljs-comment">// ... 这个方法看起来会执行真正的绘制操作，进去看下</span><br>    <span class="hljs-keyword">int</span> syncResult = syncAndDrawFrame(choreographer.mFrameInfo);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 进入 native</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> HardwareRenderer.syncAndDrawFrame(<span class="hljs-meta">@NonNull</span> FrameInfo frameInfo) &#123;<br>    <span class="hljs-keyword">return</span> nSyncAndDrawFrame(mNativeProxy, frameInfo.frameInfo, frameInfo.frameInfo.length);<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// frameworks/base/core/jni/android_view_ThreadedRenderer.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="hljs-params">(JNIEnv* env, jobject clazz,</span></span><br><span class="hljs-function"><span class="hljs-params">        jlong proxyPtr, jlongArray frameInfo, jint frameInfoSize)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    RenderProxy* proxy = <span class="hljs-keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);<br>    env-&gt;<span class="hljs-built_in">GetLongArrayRegion</span>(frameInfo, <span class="hljs-number">0</span>, frameInfoSize, proxy-&gt;<span class="hljs-built_in">frameInfo</span>());<br>    <span class="hljs-keyword">return</span> proxy-&gt;<span class="hljs-built_in">syncAndDrawFrame</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">RenderProxy::syncAndDrawFrame</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mDrawFrameTask.<span class="hljs-built_in">drawFrame</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DrawFrameTask::drawFrame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">// 到此都还是在 ui thread</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawFrameTask::postAndWait</span><span class="hljs-params">()</span> </span>&#123;<br>    AutoMutex _lock(mLock);<br>    <span class="hljs-comment">// RenderThread 继承自 Thread，DrawFrameTask::run 被提交至 RenderThread 的 WorkQueue 等待执行</span><br>    mRenderThread-&gt;<span class="hljs-built_in">queue</span>().<span class="hljs-built_in">post</span>([<span class="hljs-keyword">this</span>]() &#123; <span class="hljs-built_in">run</span>(); &#125;);<br>    <span class="hljs-comment">// 这里会导致 ui thread 阻塞，直到 DrawFrameTask::run() 里把相关数据同步过来后才恢复 ui thread</span><br>    mSignal.<span class="hljs-built_in">wait</span>(mLock);<br>&#125;<br><br><span class="hljs-comment">// 记住此时已经是在 RenderThread 而不是 ui thread，ui thread 此时被阻塞了</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawFrameTask::run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">ATRACE_NAME</span>(<span class="hljs-string">&quot;DrawFrame&quot;</span>);<br><br>    <span class="hljs-keyword">bool</span> canUnblockUiThread;<br>    <span class="hljs-keyword">bool</span> canDrawThisFrame;<br>    &#123;<br>        <span class="hljs-function">TreeInfo <span class="hljs-title">info</span><span class="hljs-params">(TreeInfo::MODE_FULL, *mContext)</span></span>;<br>        canUnblockUiThread = <span class="hljs-built_in">syncFrameState</span>(info);<br>        canDrawThisFrame = info.out.canDrawThisFrame;<br><br>        <span class="hljs-keyword">if</span> (mFrameCompleteCallback) &#123;<br>            mContext-&gt;<span class="hljs-built_in">addFrameCompleteListener</span>(std::<span class="hljs-built_in">move</span>(mFrameCompleteCallback));<br>            mFrameCompleteCallback = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Grab a copy of everything we need</span><br>    CanvasContext* context = mContext;<br>    std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int64_t</span>)&gt; callback = std::<span class="hljs-built_in">move</span>(mFrameCallback);<br>    mFrameCallback = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// From this point on anything in &quot;this&quot; is *UNSAFE TO ACCESS*</span><br>    <span class="hljs-keyword">if</span> (canUnblockUiThread) &#123;<br>        <span class="hljs-built_in">unblockUiThread</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Even if we aren&#x27;t drawing this vsync pulse the next frame number will still be accurate</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_UNLIKELY</span>(callback)) &#123;<br>        context-&gt;<span class="hljs-built_in">enqueueFrameWork</span>(<br>                [callback, frameNr = context-&gt;<span class="hljs-built_in">getFrameNumber</span>()]() &#123; <span class="hljs-built_in">callback</span>(frameNr); &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CC_LIKELY</span>(canDrawThisFrame)) &#123;<br>        context-&gt;<span class="hljs-built_in">draw</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// wait on fences so tasks don&#x27;t overlap next frame</span><br>        context-&gt;<span class="hljs-built_in">waitOnFences</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!canUnblockUiThread) &#123;<br>        <span class="hljs-built_in">unblockUiThread</span>();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里有两个函数是需要关注的：<code>syncFrameState(info)</code> 和 <code>context-&gt;draw()</code>，但不打算深入下去，因为后续涉及到很多状态判断和方法调用，而且会进入 skia 引擎的相关方法，不是代码跟踪就可以理解的（凡是跟 opengl 相关的代码，经过层层封装都不太好理解）</p><p>搜索 <code>DrawFrameTask</code> 或者 <code>DisplayList</code> 等关键字可以找到如何把 <code>DisplayList</code> 处理为 <code>egl</code> 相关指令的文章，这里根据<a href="https://blog.csdn.net/jinzhuojun/article/details/54234354">《Android N中UI硬件渲染（hwui）的HWUI_NEW_OPS(基于Android 7.1)》</a> 的描述总结下此阶段的工作：</p><ol><li><code>syncFrameState(info)</code> 上传纹理</li><li><code>unblockUiThread()</code> 然后恢复 ui thread</li><li><code>context-&gt;draw()</code> 输出 egl 指令</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="../../../../image/2020-12-13-ui-thread-in-vsync/52054.png" alt="52054.png"></p><p>这是一个 sync_app 信号内的 systrace，结合这张图片，尝试解答开头提出的问题</p><ol><li>app 内的 ui 渲染至少包含两个线程：ui thread（执行 <code>View.draw()</code>）和 render thread（执行 egl 指令）</li><li>ui thread 和 render thread 有一段重合的地方，也就是在 ui thread 完成「Record <code>View#draw()</code>」后，ui thread 被阻塞了；而 render thread 开始执行 <code>syncFrameState</code>，完成后恢复 ui thread，此时 ui thread 的任务已完成，后续的都是 render thread 的任务了</li><li>从时长看，ui thread 执行 <code>Choreographer#doFrame</code> 用时 4ms，render thread 执行 <code>DrawFrame</code> 用时 8ms；render thread 的存在大大地释放了 ui thread 的压力</li><li>要在 16ms 内完成一帧的绘制，不能都让 ui thread 给消耗掉了，还得留出一段时间给 render thread，也就是说 ui thread 在一帧内的任务 <code>Choreographer#doFrame</code> 耗时要小于 16ms 才行；而且从上图看 render thread 的耗时远大于 ui thread，留给 ui thread 的时间应该是远小于 16ms 的</li></ol><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ol><li><code>DisplayList</code>：对 <code>Canvas</code> 的所有绘制操作并不会立刻执行，而是保存为 <code>DisplayList</code>；这一过程称为“录制”，后续可以“回放”进行渲染</li><li><code>View</code> 是表，是 framework 暴露出来的 ui api，就像 DOM 是浏览器暴露出来的 ui api；<code>RenderNode</code> 是里</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vsync</tag>
      
      <tag>ui thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 图形栈（一）vsync</title>
    <link href="/blog/2020/12/02/vsync/"/>
    <url>/blog/2020/12/02/vsync/</url>
    
    <content type="html"><![CDATA[<p>android 的垂直同步模型（vsync）是隐藏在 view 系统后面的很重要的一块，它控制着 view 渲染的节奏；而且 vsync 还是比较复杂的，我们从下到上，先从最熟悉的 <code>View.invalidate</code> 讲起，看看简单的一个 <code>invalidate</code> 后面隐藏着多么复杂的工作</p><h2 id="从-View-invalidate-说起"><a href="#从-View-invalidate-说起" class="headerlink" title="从 View.invalidate() 说起"></a>从 <code>View.invalidate()</code> 说起</h2><p><img src="../../../../image/2020-12-02-vsync/invalidate.jpg" alt="invalidate.jpg"></p><p>看上图，<code>View.invalidate()</code> 主要做了两件事：</p><ol><li>将 <code>ViewRootImpl.doTraversal()</code> 加入到 <code>Choreographer</code> 的任务列表里，等待下一次 vsync 信号到来时执行；<code>doTraversal()</code>主要执行 view tree 的三个重要方法：measure、layout 和 draw；<code>Choreographer</code>则是在一次 vsync 信号到来时，依次执行 <code>INPUT</code>，<code>ANIMATION</code> 和 <code>TRAVERSAL</code> 这三个类别的任务；也就是说 view tree 的渲染和 input 的处理都是从 vsync 到来时开始的，而且此时会开启同步栅栏，屏蔽非 ui 任务（用户任务），集中力量在下一次的 vsync 到来前完成一帧的渲染</li><li>唤醒 <code>EventThread</code> 去看看有没 vsync 信号的到来；<code>EventThread</code> 看名字就知道是一个线程，看它的 loop 流程，是将 <code>mPendingEvents</code> 分发给 consumer，那么我们可以猜想下，event 也许包含了 vsync，而 consumer 很有可能最终走到 <code>Choreographer.doFrame</code>里触发 view tree 的绘制</li></ol><p>按照从下到上追踪法，下一步就是看看是谁在什么时候把 event 放到 <code>mPendingEvents</code> 里，但这里我选择掉转方向盘，先从 surfaceflinger 讲起</p><p>继续之前，我们得先了解几个跟硬件有关的概念</p><h2 id="HAL，Hardware-Abstract-Layer，硬件抽象层"><a href="#HAL，Hardware-Abstract-Layer，硬件抽象层" class="headerlink" title="HAL，Hardware Abstract Layer，硬件抽象层"></a>HAL，Hardware Abstract Layer，硬件抽象层</h2><p>看名字就知道这是跟硬件、设备相关的东西，应该是最贴近硬件的那一层软件，我没有做过相关的开发，但是结合 google 和这两篇文章：<a href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a>，<a href="https://blog.csdn.net/qq_19923217/article/details/88398660">Android HIDL HAL 接口定义语言详解</a>，我大概了解了它是干什么的，我说说我的理解：</p><ul><li>它用接口的方式定义协议，而协议则定义了组件间的沟通规范；Android app 开发其实也就这个概念，就是各个业务、基础能力的 interface；我做过 java web 开发，所以对这个概念比较熟悉；整个 java web 是由很多协议构成的：Servlet、JSP、JDBC 等，sun 给出包含这些协议 interface 的 jar 包出来（它自己也可能会给出一个默认实现比如 glassfish），各个厂商给出自己对协议的实现如：Tomcat、Jboss、Resin 等；而 web app 开发者只需根据协议 jar 包开发业务，部署时根据条件可以放在各种厂商的容器上</li><li>HAL 也是这个道理，android HWC HAL 定义了各种 interface（在 <code>hardware/interfaces/graphics/composer/2.1/</code> 目录下），各个厂商需要实现这些接口并给出 so 文件；打包 android image 的时候，根据硬件设备挑选合适的 HAL 实现，把 so 文件放到镜像里；而 android framework 开发者只需根据 HAL 接口进行业务开发即可，无需关心实现细节</li></ul><h2 id="HIDL，HAL-Interface-Definition-Language，HAL-接口定义语言"><a href="#HIDL，HAL-Interface-Definition-Language，HAL-接口定义语言" class="headerlink" title="HIDL，HAL Interface Definition Language，HAL 接口定义语言"></a>HIDL，HAL Interface Definition Language，HAL 接口定义语言</h2><p>看名字好像跟 AIDL 有点渊源啊，对的，它是 HAL 的代码生成器；具体怎么用我们了解下即可：<a href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a>，<a href="https://blog.csdn.net/qq_19923217/article/details/88398660">Android HIDL HAL 接口定义语言详解</a>，<a href="https://blog.csdn.net/qq_19923217/article/details/89173162">Android HIDL 之 hal 进程启动及服务注册过程</a></p><p>总结下关键点：</p><ul><li>各个 HAL 是独立进程的（看看 <code>hardware/interfaces/graphics/composer/2.1/default/</code> 是怎么启动 HWC 进程并加载厂商 so 库的），surfaceflinger 进程通过 binder 与 HWC 进程通讯（也就是 C/S 架构，HWC 是 server，surfaceflinger 是 client）</li><li>HWC 将服务注册到 <code>hwservicemanager</code>，surfaceflinger 从 <code>hwservicemanager</code> 获取 composer 服务</li><li>所以用从下到上的方法找调用栈的时候会发现，onVsync 方法找不到调用的地方，那是因为发送 vsync 信号的代码是厂商代码（framework 提供 callback interface），不在 aosp 里面</li></ul><h2 id="HWC，硬件图层合成器"><a href="#HWC，硬件图层合成器" class="headerlink" title="HWC，硬件图层合成器"></a>HWC，硬件图层合成器</h2><p><a href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a> 这里也介绍了，它是一个合成多个图层的组件（原来状态栏、导航栏、壁纸、app 等不是一起渲染，而是独自渲染最后合成为屏幕内容的），这里只关心它会发出 vsync 信号</p><p><img src="../../../../image/2020-12-02-vsync/vsync_flow.jpg" alt="vsync_flow.jpg"></p><p>我们先理解这张图，屏幕（硬件）发出 vsync 信号（就是上图的 HW_VSYNC），经过软件的一系列的调整生成 SW_VSYNC，然后输出到两路：</p><ol><li><code>SF_VSYNC</code>，输出到 surfaceflinger</li><li><code>APP_VSYNC</code>，输出到 app</li></ol><h2 id="HW-VSYNC-硬件垂直同步信号"><a href="#HW-VSYNC-硬件垂直同步信号" class="headerlink" title="HW_VSYNC - 硬件垂直同步信号"></a>HW_VSYNC - 硬件垂直同步信号</h2><p><img src="../../../../image/2020-12-02-vsync/hw_vsync.jpg" alt="hw_vsync.jpg"></p><p>surfaceflinger 是一个很重要的服务进程，它跟图像和显示有关，源码在 <code>/frameworks/native/services/surfaceflinger</code>；目录下有个编译配置文件 <code>Android.bp</code> ，看下它的内容，它输出了可执行文件 surfaceflinger、共享库 libsurfaceflinger.so 和 libSurfaceFlingerProp.so；然后有个 <code>surfaceflinger.rc</code>，它是一个启动配置文件，意味着 surfaceflinger 会在系统启动后被 init 进程启动为服务进程，看下里面的内容，可执行文件是 <code>/system/bin/surfaceflinger</code>，<code>main</code> 函数入口在 main_surfaceflinger.cpp</p><p>从上图可以看到 surfaceflinger 进程启动后，会查找 HWC server 并注册 callback，当设备发出 hw_vsync 时，<code>SurfaceFlinger.onVsyncReceived</code> 被执行，看上面那张图，hw_vsync 不是直接被使用，而是被调整转换为 sw_vsync，也就是 <code>DispSync.addResyncSample</code></p><h2 id="SW-VSYNC-软件垂直同步信号"><a href="#SW-VSYNC-软件垂直同步信号" class="headerlink" title="SW_VSYNC - 软件垂直同步信号"></a>SW_VSYNC - 软件垂直同步信号</h2><p><code>DispSyncThread</code> 和 <code>DispSync</code> 收集 HW_VSYNC，计算并输出 SW_VSYNC；主循环是 <code>DispSyncThread.threadLoop()</code>，但在分析 main loop 之前，我们需要先了解 <code>DispSync</code> 几个重要的属性（参考<a href="https://www.jianshu.com/p/d3e4b1805c92">「Android SurfaceFlinger SW Vsync模型」</a>）</p><p><code>mResyncSamples</code> 数组 - 通过上面的分析我们知道 <code>addResyncSample</code> 把 HW_VSYNC 加入 <code>DispSync</code>，但 <code>mResyncSamples</code> 只会保留最新的 32 个以供后续计算；它是个首尾相连、环状的循环列表，容量为 32</p><p><code>mPeriod</code> - 两个 HW_VSYNC 之间的时间间隔，相当于刷新率，我们看下它是怎么计算的</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DispSync::updateModelLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] updateModelLocked %zu&quot;</span>, mName, mNumResyncSamples);<br>    <span class="hljs-comment">// 只有收集到足够多（≥ 6）的 HW_VSYNC 才去计算刷新率（以及其他参数）</span><br>    <span class="hljs-keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;<br>        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Computing...&quot;</span>, mName);<br>        <span class="hljs-keyword">nsecs_t</span> durationSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">nsecs_t</span> minDuration = INT64_MAX;<br>        <span class="hljs-keyword">nsecs_t</span> maxDuration = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// We skip the first 2 samples because the first vsync duration on some</span><br>        <span class="hljs-comment">// devices may be much more inaccurate than on other devices, e.g. due</span><br>        <span class="hljs-comment">// to delays in ramping up from a power collapse. By doing so this</span><br>        <span class="hljs-comment">// actually increases the accuracy of the DispSync model even though</span><br>        <span class="hljs-comment">// we&#x27;re effectively relying on fewer sample points.</span><br><br>        <span class="hljs-comment">// 把收集到的 HW_VSYNC 时间间隔去掉前两个，去掉最大值和最小值，剩下的求平均值</span><br>        <span class="hljs-comment">// 这就算出了硬件的刷新率，它是计算出来的一个平均值，因为 HW_VSYNC 速率极可能是会变动的</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> numSamplesSkipped = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = numSamplesSkipped; i &lt; mNumResyncSamples; i++) &#123;<br>            <span class="hljs-keyword">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;<br>            <span class="hljs-keyword">size_t</span> prev = (idx + MAX_RESYNC_SAMPLES - <span class="hljs-number">1</span>) % MAX_RESYNC_SAMPLES;<br>            <span class="hljs-keyword">nsecs_t</span> duration = mResyncSamples[idx] - mResyncSamples[prev];<br>            durationSum += duration;<br>            minDuration = <span class="hljs-built_in">min</span>(minDuration, duration);<br>            maxDuration = <span class="hljs-built_in">max</span>(maxDuration, duration);<br>        &#125;<br><br>        <span class="hljs-comment">// Exclude the min and max from the average</span><br>        durationSum -= minDuration + maxDuration;<br>        mPeriod = durationSum / (mNumResyncSamples - numSamplesSkipped - <span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>mPhase</code> - <code>mPeriod</code> 的偏差值；我们知道 <code>mPeriod</code> 是一个计算出来的平均值，而且还去除了一些噪音（极大值、极小值等），那么它与真实的 HW_VSYNC 之间必定会有偏差，<code>mPhase</code> 就是这个平均偏差（要从数学理论上去理解）；这里不深入细节了</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DispSync::updateModelLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] updateModelLocked %zu&quot;</span>, mName, mNumResyncSamples);<br>    <span class="hljs-keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">double</span> sampleAvgX = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">double</span> sampleAvgY = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">double</span> scale = <span class="hljs-number">2.0</span> * M_PI / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(mPeriod);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = numSamplesSkipped; i &lt; mNumResyncSamples; i++) &#123;<br>            <span class="hljs-keyword">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;<br>            <span class="hljs-keyword">nsecs_t</span> sample = mResyncSamples[idx] - mReferenceTime;<br>            <span class="hljs-keyword">double</span> samplePhase = <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(sample % mPeriod) * scale;<br>            sampleAvgX += <span class="hljs-built_in">cos</span>(samplePhase);<br>            sampleAvgY += <span class="hljs-built_in">sin</span>(samplePhase);<br>        &#125;<br><br>        sampleAvgX /= <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(mNumResyncSamples - numSamplesSkipped);<br>        sampleAvgY /= <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(mNumResyncSamples - numSamplesSkipped);<br><br>        mPhase = <span class="hljs-built_in">nsecs_t</span>(<span class="hljs-built_in">atan2</span>(sampleAvgY, sampleAvgX) / scale);<br><br>        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] mPhase = %&quot;</span> PRId64, mName, <span class="hljs-built_in">ns2us</span>(mPhase));<br><br>        <span class="hljs-keyword">if</span> (mPhase &lt; -(mPeriod / <span class="hljs-number">2</span>)) &#123;<br>            mPhase += mPeriod;<br>            <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Adjusting mPhase -&gt; %&quot;</span> PRId64, mName, <span class="hljs-built_in">ns2us</span>(mPhase));<br>        &#125;<br><br>        <span class="hljs-comment">// Artificially inflate the period if requested.</span><br>        mPeriod += mPeriod * mRefreshSkipCount;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>mReferenceTime</code>，这个最新那个 HW_VSYNC 的时间，每次计算下一个 SW_VSYNC 时都是以该时间作为基准，这样可以减少误差。如果每一个 SW_VSYNC 都以上一个 SW_VSYNC 作为基准，那误差就会不停的累加；而如果以第一个 HW_VSYNC 作基准，那每次 SW_VSYNC 误差是不会累加的</p><p>现在我们看下 main loop</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">threadLoop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">status_t</span> err;<br>    <span class="hljs-keyword">nsecs_t</span> now = <span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        std::vector&lt;CallbackInvocation&gt; callbackInvocations;<br>        <span class="hljs-keyword">nsecs_t</span> targetTime = <span class="hljs-number">0</span>;<br>        &#123; <span class="hljs-comment">// Scope for lock</span><br>            <span class="hljs-function">Mutex::Autolock <span class="hljs-title">lock</span><span class="hljs-params">(mMutex)</span></span>;<br>            <span class="hljs-keyword">if</span> (mTraceDetailedInfo) &#123;<br>                <span class="hljs-built_in">ATRACE_INT64</span>(<span class="hljs-string">&quot;DispSync:Frame&quot;</span>, mFrameNumber);<br>            &#125;<br>            <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Frame %&quot;</span> PRId64, mName, mFrameNumber);<br>            ++mFrameNumber;<br>            <span class="hljs-keyword">if</span> (mStop) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 收集到足够多的 HW_VSYNC 算出刷新率后，才计算 SW_VSYNC，否则 wait</span><br>            <span class="hljs-keyword">if</span> (mPeriod == <span class="hljs-number">0</span>) &#123;<br>                err = mCond.<span class="hljs-built_in">wait</span>(mMutex);<br>                <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;<br>                    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="hljs-built_in">strerror</span>(-err), err);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// computeNextEventTimeLocked 这个方法很重要，我们知道随着 HW_VSYNC 样本的不断更新，</span><br>            <span class="hljs-comment">// mPeriod、mPhase 和 mReferenceTime 也跟着轻微变动，上一次的 SW_VSYNC 是根据上一次的参数算出来的</span><br>            <span class="hljs-comment">// 下一次的 SW_VSYNC 则在上次时间戳的基础上重新计算</span><br>            targetTime = <span class="hljs-built_in">computeNextEventTimeLocked</span>(now);<br><br>            <span class="hljs-comment">// 没到时间则 wait</span><br>            <span class="hljs-keyword">bool</span> isWakeup = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (now &lt; targetTime) &#123;<br>                <span class="hljs-keyword">if</span> (mTraceDetailedInfo) <span class="hljs-built_in">ATRACE_NAME</span>(<span class="hljs-string">&quot;DispSync waiting&quot;</span>);<br>                <span class="hljs-keyword">if</span> (targetTime == INT64_MAX) &#123;<br>                    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Waiting forever&quot;</span>, mName);<br>                    err = mCond.<span class="hljs-built_in">wait</span>(mMutex);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;[%s] Waiting until %&quot;</span> PRId64, mName, <span class="hljs-built_in">ns2us</span>(targetTime));<br>                    err = mCond.<span class="hljs-built_in">waitRelative</span>(mMutex, targetTime - now);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (err == TIMED_OUT) &#123;<br>                    isWakeup = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;<br>                    <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;error waiting for next event: %s (%d)&quot;</span>, <span class="hljs-built_in">strerror</span>(-err), err);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            now = <span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);<br>            <span class="hljs-comment">// Don&#x27;t correct by more than 1.5 ms</span><br>            <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">nsecs_t</span> kMaxWakeupLatency = <span class="hljs-built_in">us2ns</span>(<span class="hljs-number">1500</span>);<br>            <span class="hljs-keyword">if</span> (isWakeup) &#123;<br>                mWakeupLatency = ((mWakeupLatency * <span class="hljs-number">63</span>) + (now - targetTime)) / <span class="hljs-number">64</span>;<br>                mWakeupLatency = <span class="hljs-built_in">min</span>(mWakeupLatency, kMaxWakeupLatency);<br>                <span class="hljs-keyword">if</span> (mTraceDetailedInfo) &#123;<br>                    <span class="hljs-built_in">ATRACE_INT64</span>(<span class="hljs-string">&quot;DispSync:WakeupLat&quot;</span>, now - targetTime);<br>                    <span class="hljs-built_in">ATRACE_INT64</span>(<span class="hljs-string">&quot;DispSync:AvgWakeupLat&quot;</span>, mWakeupLatency);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 发送时，再次计算发送时间，只有此时到达发送时间的才发送（时间算得很精确）</span><br>            callbackInvocations = <span class="hljs-built_in">gatherCallbackInvocationsLocked</span>(now);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (callbackInvocations.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fireCallbackInvocations</span>(callbackInvocations);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>总的来说，SW_VSYNC 它去除了噪音，而且用过去 32 个 HW_VSYNC 样本的平均值作刷新率，对比 HW_VSYNC 显得平滑了很多</p><p>那谁接收 SW_VSYNC？</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::initScheduler</span><span class="hljs-params">(DisplayId primaryDisplayId)</span> </span>&#123;<br>    <span class="hljs-comment">// ... 一个是 app，叫做 APP_VSYNC 吧</span><br>    mAppConnectionHandle =<br>            mScheduler-&gt;<span class="hljs-built_in">createConnection</span>(<span class="hljs-string">&quot;app&quot;</span>, mVsyncModulator.<span class="hljs-built_in">getOffsets</span>().app,<br>                                         mPhaseOffsets-&gt;<span class="hljs-built_in">getOffsetThresholdForNextVsync</span>(),<br>                                         impl::EventThread::<span class="hljs-built_in">InterceptVSyncsCallback</span>());<br>    <span class="hljs-comment">// ... 一个是 sf，叫做 SF_VSYNC 吧</span><br>    mSfConnectionHandle =<br>            mScheduler-&gt;<span class="hljs-built_in">createConnection</span>(<span class="hljs-string">&quot;sf&quot;</span>, mVsyncModulator.<span class="hljs-built_in">getOffsets</span>().sf,<br>                                         mPhaseOffsets-&gt;<span class="hljs-built_in">getOffsetThresholdForNextVsync</span>(),<br>                                         [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">nsecs_t</span> timestamp) &#123;<br>                                             mInterceptor-&gt;<span class="hljs-built_in">saveVSyncEvent</span>(timestamp);<br>                                         &#125;);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="APP-VSYNC-发送给-app-的垂直同步信号"><a href="#APP-VSYNC-发送给-app-的垂直同步信号" class="headerlink" title="APP_VSYNC - 发送给 app 的垂直同步信号"></a>APP_VSYNC - 发送给 app 的垂直同步信号</h2><p>还记得文章开头那张 <code>View.invalidate()</code> 时序图吗？最后面它唤醒了 <code>EventThread</code>，现在我们来看看 <code>EventThread</code> 的主循环都做了些什么</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventThread::threadMain</span><span class="hljs-params">(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span> </span>&#123;<br>    DisplayEventConsumers consumers;<br><br>    <span class="hljs-keyword">while</span> (mState != State::Quit) &#123;<br>        std::optional&lt;DisplayEventReceiver::Event&gt; event;<br><br>        <span class="hljs-comment">// 在文章的开头，我们就猜测 mPendingEvents 里放的是同步信号</span><br>        <span class="hljs-comment">// 现在我们知道了里面包含 SW_VSYNC，那是谁放进去的呢？</span><br>        <span class="hljs-keyword">if</span> (!mPendingEvents.<span class="hljs-built_in">empty</span>()) &#123;<br>            event = mPendingEvents.<span class="hljs-built_in">front</span>();<br>            mPendingEvents.<span class="hljs-built_in">pop_front</span>();<br>...<br>        &#125;<br><br>        <span class="hljs-keyword">bool</span> vsyncRequested = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// Find connections that should consume this event.</span><br>        <span class="hljs-keyword">auto</span> it = mDisplayEventConnections.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span> (it != mDisplayEventConnections.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> connection = it-&gt;<span class="hljs-built_in">promote</span>()) &#123;<br>                vsyncRequested |= connection-&gt;vsyncRequest != VSyncRequest::None;<br><br>                <span class="hljs-keyword">if</span> (event &amp;&amp; <span class="hljs-built_in">shouldConsumeEvent</span>(*event, connection)) &#123;<br>                    consumers.<span class="hljs-built_in">push_back</span>(connection);<br>                &#125;<br><br>                ++it;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                it = mDisplayEventConnections.<span class="hljs-built_in">erase</span>(it);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 分发给消费者，怎么回调给 Choreographer？</span><br>        <span class="hljs-keyword">if</span> (!consumers.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-built_in">dispatchEvent</span>(*event, consumers);<br>            consumers.<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>DispSyncThread</code> 把 SW_VSYNC 压入 <code>EventThread.mPendingEvents</code></p><p><img src="../../../../image/2020-12-02-vsync/on_vsync.jpg" alt="on_vsync.jpg"></p><p>分发 SW_VSYNC 的流程</p><ul><li><code>ViewRootImpl</code> 里拿到的是接收 APP_VSYNC 的 <code>Choreographer</code></li><li><code>Choreographer</code> 在构造函数里通过 <code>SurfaceFlinger</code> 与 <code>EventThread</code> 建立连接；这个连接其实是个 <code>Parcelable</code>，一块可以 io 的内存，<code>EventThread</code> 往里面写入 SW_VSYNC，<code>DisplayEventReceiver</code> 则通过 <code>Looper.addFd</code> 监听（这是 app main looper）</li><li>当收到 SW_VSYNC 时<code>FrameDisplayEventReceiver</code> 把 <code>Choreographer.doFrame</code> 放入 message queue，这样 input、animate 和 view 绘制即将执行</li></ul><p><img src="../../../../image/2020-12-02-vsync/consumer.jpg" alt="consumer.jpg"></p><h2 id="SF-VSYNC"><a href="#SF-VSYNC" class="headerlink" title="SF_VSYNC"></a>SF_VSYNC</h2><p>上面我们在分析是谁接收 SW_VSYNC 时，除了 APP_VSYNC 外，还有一路 SF_VSYNC</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::initScheduler</span><span class="hljs-params">(DisplayId primaryDisplayId)</span> </span>&#123;<br>    <span class="hljs-comment">// ... 一个是 sf，叫做 SF_VSYNC 吧</span><br>    mSfConnectionHandle =<br>    mScheduler-&gt;<span class="hljs-built_in">createConnection</span>(<span class="hljs-string">&quot;sf&quot;</span>, mVsyncModulator.<span class="hljs-built_in">getOffsets</span>().sf,<br>                                 mPhaseOffsets-&gt;<span class="hljs-built_in">getOffsetThresholdForNextVsync</span>(),<br>                                 [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">nsecs_t</span> timestamp) &#123;<br>                                     mInterceptor-&gt;<span class="hljs-built_in">saveVSyncEvent</span>(timestamp);<br>                                 &#125;);<br>    <span class="hljs-comment">// 看看 mEventQueue-&gt;setEventConnection 做了什么</span><br>    mEventQueue-&gt;<span class="hljs-built_in">setEventConnection</span>(mScheduler-&gt;<span class="hljs-built_in">getEventConnection</span>(mSfConnectionHandle));<br>    <span class="hljs-comment">// ...</span><br>&#125; <br><br><span class="hljs-comment">// 上面有分析过，vsync event 是写入到一块内存里，通过 fd 可以监听到，而回调是 MessageQueue::cb_eventReceiver</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MessageQueue::setEventConnection</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mEventTube.<span class="hljs-built_in">getFd</span>() &gt;= <span class="hljs-number">0</span>) &#123;<br>        mLooper-&gt;<span class="hljs-built_in">removeFd</span>(mEventTube.<span class="hljs-built_in">getFd</span>());<br>    &#125;<br>    mEvents = connection;<br>    mEvents-&gt;<span class="hljs-built_in">stealReceiveChannel</span>(&amp;mEventTube);<br>    mLooper-&gt;<span class="hljs-built_in">addFd</span>(mEventTube.<span class="hljs-built_in">getFd</span>(), <span class="hljs-number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver, <span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 继续看 eventReceiver 方法</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageQueue::cb_eventReceiver</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span>* data)</span> </span>&#123;<br>    MessageQueue* queue = <span class="hljs-keyword">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);<br>    <span class="hljs-keyword">return</span> queue-&gt;<span class="hljs-built_in">eventReceiver</span>(fd, events);<br>&#125;<br><br><span class="hljs-comment">// 把 events 解包成 DisplayEventReceiver::Event，当有 vsync 时执行 dispatchInvalidate</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MessageQueue::eventReceiver</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-comment">/*fd*/</span>, <span class="hljs-keyword">int</span> <span class="hljs-comment">/*events*/</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">ssize_t</span> n;<br>    DisplayEventReceiver::Event buffer[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">while</span> ((n = DisplayEventReceiver::<span class="hljs-built_in">getEvents</span>(&amp;mEventTube, buffer, <span class="hljs-number">8</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;<br>                mHandler-&gt;<span class="hljs-built_in">dispatchInvalidate</span>();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 看来得找出 Handler.handleMessage，看看里面怎么处理 MessageQueue::INVALIDATE</span><br><span class="hljs-keyword">void</span> MessageQueue::Handler::<span class="hljs-built_in">dispatchInvalidate</span>() &#123;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">android_atomic_or</span>(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="hljs-number">0</span>) &#123;<br>        mQueue.mLooper-&gt;<span class="hljs-built_in">sendMessage</span>(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">Message</span>(MessageQueue::INVALIDATE));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 最终发现是走到了 SurfaceFlinger::onMessageReceived</span><br><span class="hljs-keyword">void</span> MessageQueue::Handler::<span class="hljs-built_in">handleMessage</span>(<span class="hljs-keyword">const</span> Message&amp; message) &#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (message.what) &#123;<br>        <span class="hljs-keyword">case</span> INVALIDATE:<br>            <span class="hljs-built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);<br>            mQueue.mFlinger-&gt;<span class="hljs-built_in">onMessageReceived</span>(message.what);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REFRESH:<br>            <span class="hljs-built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);<br>            mQueue.mFlinger-&gt;<span class="hljs-built_in">onMessageReceived</span>(message.what);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 代码比较长，这就不贴出来了，总结下：</span><br><span class="hljs-comment">// SF_VSYNC 最终会调用 onMessageReceived(MessageQueue::INVALIDATE)，然后又会调用 onMessageReceived(MessageQueue::REFRESH)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SurfaceFlinger::onMessageReceived</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> what)</span> </span>&#123;&#125;<br></code></pre></div></td></tr></table></figure><h2 id="结合-systrace"><a href="#结合-systrace" class="headerlink" title="结合 systrace"></a>结合 systrace</h2><p>为什么会有 APP_VSYNC 和 SF_VSYNC 呢？这就不得不从屏幕上的内容讲起</p><p>实际上，我们在屏幕上看到的内容是由多个 layer 组合而成的：前台 app（多窗口模式下会有多个 app 显示）、桌面、壁纸、systemui 等，每个 app ui thread 负责绘制自己的内容，然后由 SurfaceFlinger 将它们合成在一起并显示在屏幕上</p><p>也就是说 APP_VSYNC 触发各个 app 的绘制，而最终屏幕内容的改变是由 SF_VSYNC 触发的；是不是这样呢？我们来看下 systrace </p><p><img src="../../../../image/2020-12-02-vsync/45517.png" alt="45517.png"></p><p><img src="../../../../image/2020-12-02-vsync/45545.png" alt="45545.png"></p><p><img src="../../../../image/2020-12-02-vsync/45553.png" alt="45553.png"></p><p><img src="../../../../image/2020-12-02-vsync/45532.png" alt="45532.png"></p><p><img src="../../../../image/2020-12-02-vsync/45628.png" alt="45628.png"></p><p><img src="../../../../image/2020-12-02-vsync/45643.png" alt="45643.png"></p><p>可以看到 ui thread doFrame 的确跟随着 APP_VSYNC（render thread 是执行 opengl 的线程，在 ui thread 计算完后获取结果并输出至 gpu），surfaceflinger onMessageReceived 也是跟随着 SF_VSYNC 的；但有没发现，它们俩似乎是同时执行的？surfaceflinger 不是应该等待 app 渲染完它那一层再合成吗？</p><p>我们重新回顾 initScheduler，有没发现这两路 vsync 都有一个 offset 参数？没错，就是这个参数控制着收到 vsync 后到执行工作的这一段延迟时间；实际上图 surfaceflinger 的延迟差不多是一个 vsync 的周期时间那么大，每个 surfaceflinger 合成的内容却是上一个周期里 app 渲染的内容；而且在合成工作完成后，当前周期的 app 渲染工作（render thread）才开始，避免了 layer 的内容被覆盖；这几个线程就这样有节奏地工作在一起。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vsync</tag>
      
      <tag>invalidate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scoped Storage（沙盒）</title>
    <link href="/blog/2020/11/19/scoped-storage/"/>
    <url>/blog/2020/11/19/scoped-storage/</url>
    
    <content type="html"><![CDATA[<h2 id="以前的存储访问权限"><a href="#以前的存储访问权限" class="headerlink" title="以前的存储访问权限"></a>以前的存储访问权限</h2><p>先看看以前（ &lt; 10/Q ）的存储访问权限是怎样的</p><p>从 APP 目录（app-specific directories）的角度看，可以分为：</p><ol><li>内部存储（app-specific directories in internal storage）<ol><li>对于 app 自己，无需申请任何读/写权限</li><li>对于其他 app，没有访问权限</li></ol></li><li>外部存储（app-specific directories in external storage）<ol><li>对于 app 自己，无需申请任何读/写权限</li><li>对于其他 app，可以访问但需要申请读/写权限</li></ol></li></ol><p>从存储设备的角度看，可以分为：</p><ol><li>内部存储，除了自己的目录，没有访问权限</li><li>外部存储，可以访问但需申请读/写权限（除了自己的目录）</li></ol><h2 id="启用-Scoped-Storage-后"><a href="#启用-Scoped-Storage-后" class="headerlink" title="启用 Scoped Storage 后"></a>启用 Scoped Storage 后</h2><p>而启用 Scoped Storage（ ≥ 10/Q）后，APP 只能通过下述三种方法访问文件：</p><ol><li>对于 APP 目录（ app-specific directories ），无论是内部存储还是外部存储，无需申请任何读/写权限即可访问（ File API ），APP 卸载时被删除</li><li>通过 MediaStore API 操作媒体文件，读/写 APP 自己的文件时无需任何权限，访问其他 APP 的内容时需要申请 READ_EXTERNAL_STORAGE；开启 Scoped Storage 后，只能访问 <code>MediaStore.Images</code>，<code>MediaStore.Video</code>，<code>MediaStore.Audio</code> 和自己的 <code>MediaStore.Downloads</code></li><li>通过 SAF（ <code>Storage Access Framework</code>，也就是文件选择器 ）读/写其他的文件，参考 <a href="https://developer.android.google.cn/guide/topics/providers/document-provider">Open files using storage access framework</a></li><li>其他方式即使拥有读写权限也会抛出 <code>java.io.IOException: Permission denied</code></li></ol><p>兼容性（ targetSDK ）</p><ol><li>&lt; 29，默认关闭，可以通过 <code>requestLegacyExternalStorage = false</code> 打开</li><li>= 29，默认开启，可以通过 <code>requestLegacyExternalStorage = true</code> 关闭</li><li>&gt; 29，强制开启，<code>requestLegacyExternalStorage</code> 被忽略</li></ol><p>常用的 APP 目录</p><table><thead><tr><th align="left">API</th><th align="left">Storage</th><th align="left">权限</th><th align="left">返回值</th></tr></thead><tbody><tr><td align="left">getDataDir()</td><td align="left">internal storage</td><td align="left">NO</td><td align="left">/data/user/0/com.example.myapplication</td></tr><tr><td align="left">getFilesDir()</td><td align="left">internal storage</td><td align="left">NO</td><td align="left">/data/user/0/com.example.myapplication/files</td></tr><tr><td align="left">getCacheDir()</td><td align="left">internal storage</td><td align="left">NO</td><td align="left">/data/user/0/com.example.myapplication/cache</td></tr><tr><td align="left">getDir(“apple”, Context.MODE_PRIVATE)</td><td align="left">internal storage</td><td align="left">NO</td><td align="left">/data/user/0/com.example.myapplication/app_apple</td></tr><tr><td align="left">getExternalCacheDir()</td><td align="left">external storage</td><td align="left">NO</td><td align="left">/storage/emulated/0/Android/data/com.example.myapplication/cache</td></tr><tr><td align="left">getExternalFilesDir(“apple”)</td><td align="left">external storage</td><td align="left">NO</td><td align="left">/storage/emulated/0/Android/data/com.example.myapplication/files/apple</td></tr><tr><td align="left">Environment.getExternalStoragePublicDirectory()</td><td align="left">external storage</td><td align="left">YES</td><td align="left">/storage/emulated/0/Pictures, /storage/emulated/0/Alarms, …</td></tr></tbody></table><h2 id="学会使用-MediaStore-API"><a href="#学会使用-MediaStore-API" class="headerlink" title="学会使用 MediaStore API"></a>学会使用 MediaStore API</h2><p>当 APP 卸载时，APP 目录也随之被删除；如果需要将一些文件，比如图片，持久地保存下来， 媒体文件如图片、视频和音频 CURD 操作可以参考 <a href="https://developer.android.com/training/data-storage/shared/media">Access media files from shared storage</a></p><p>APP 访问自己创建的媒体文件时，无需额外的权限，因为这些媒体文件的属性「owner app」被设置为此 APP；当 APP 被卸载，这些媒体文件的「owner app」被清空；当 APP 被再次安装并访问这些媒体文件时，需要 <code>READ_EXTERNAL_STORAGE</code>，参考 <a href="https://developer.android.com/training/data-storage/shared/media#app-attribution">App attribution of media files</a></p><p>创建媒体文件时，可以通过 <code>RELATIVE_PATH</code> 指定路径，例如图片可以放在 <code>&quot;$&#123;Environment.DIRECTORY_PICTURES&#125;/tangzhi&quot;</code> 下（/storage/emulated/0/Pictures/tangzhi）</p><ol><li><code>MediaStore.Images</code> 可选择 <code>Environment.DIRECTORY_PICTURES</code> 和 <code>Environment.DIRECTORY_DCIM</code></li><li><code>MediaStore.Video</code> 可选择 <code>Environment.DIRECTORY_MOVIES</code> 和 <code>Environment.DIRECTORY_DCIM</code></li><li><code>MediaStore.Audio</code> 可选择 <code>Environment.DIRECTORY_MUSIC</code>，<code>Environment.DIRECTORY_RINGTONES</code>，<code>Environment.DIRECTORY_PODCASTS</code> …</li><li><code>MediaStore.Downloads</code> 可选择 <code>Environment.DIRECTORY_DOWNLOADS</code></li></ol><p><code>MediaStore</code> 一些重要的列</p><table><thead><tr><th align="left">字段</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">BUCKET_DISPLAY_NAME</td><td align="left">媒体文件的分类，例如：Camera，Screenshot，WeiXin</td></tr><tr><td align="left">BUCKET_ID</td><td align="left">媒体的分类 ID</td></tr><tr><td align="left">DISPLAY_NAME</td><td align="left">媒体文件名，例如：Screenshot_20201102_123620.jpg</td></tr><tr><td align="left">RELATIVE_PATH</td><td align="left">在 external storage 的相对路径，例如：Pictures/WeiXin/，DCIM/Camera/，一般是正确的</td></tr><tr><td align="left">DATA</td><td align="left">一般会将媒体文件的真实路径保存在这一列，但不保证它是正确的</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Feature</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scoped Storage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>starting window 和 windowDisablePreview</title>
    <link href="/blog/2020/11/11/starting-window/"/>
    <url>/blog/2020/11/11/starting-window/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>中午和同事聊天时，提到一个问题：设计把爱范儿 app 的启动页改成暗黑样式，本来很简单的一个改动，测试却发现启动会有闪屏；下午我看了下效果，发现确实有问题：</p><ul><li>把启动页的图片换成暗黑主体的图片后，冷/热启动都会有从白色到黑色的闪动</li><li>同事给的 bug fixed 是 <code>windowDisablePreview = true</code>，这导致 app 热启动时，会有很长的一段延迟</li></ul><h2 id="starting-window-是如何出现的"><a href="#starting-window-是如何出现的" class="headerlink" title="starting window 是如何出现的"></a>starting window 是如何出现的</h2><p>网上搜索下，发现是 starting widow 引起的，我决定看看这个 starting window 是怎么打开和关闭的，以及如何设置它的背景色来匹配启动页的黑色背景</p><p>跟寻<a href="../../../../2020/11/03/launch-activity-sequence/">上一篇文章</a>的脚步，找到 start point：<code>ActivityStarter.startActivityUnchecked</code></p><p><img src="../../../../image/2020-11-11-starting-window/starting_window.jpg" alt="starting_window.jpg"></p><p>从上图可以看到，starting window 其实是系统通过 <code>ViewManager.addView</code> 往屏幕上添加的一个 <code>window</code>；而且它的显示时间比较早，比创建 app 进程（<code>ActivityStackSupervisor.startProcessAsync</code>）和 <code>ActivityThread</code> 执行 <code>Activity</code> 生命周期函数（<code>ActivityThread.performLaunchActivity</code>）都要早，所以它才能起到快速响应用户点击操作的效果；其次它的 view 是很简单的纯色背景，这样渲染也比较快出来，下面是构建 starting window 的代码，我们来看看它的样式是如何设置的</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> StartingSurface <span class="hljs-title">addSplashScreen</span><span class="hljs-params">(...)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ... theme 是 launch activity theme，在这个 theme 里我们可以设置 starting window 样式</span><br>        <span class="hljs-keyword">if</span> (theme != context.getThemeResId() || labelRes != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                context = context.createPackageContext(packageName, CONTEXT_RESTRICTED);<br>                context.setTheme(theme);<br>            &#125; <span class="hljs-keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;<br>                <span class="hljs-comment">// Ignore</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (overrideConfig != <span class="hljs-keyword">null</span> &amp;&amp; !overrideConfig.equals(EMPTY)) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.d(TAG, <span class="hljs-string">&quot;addSplashScreen: creating context based&quot;</span><br>                    + <span class="hljs-string">&quot; on overrideConfig&quot;</span> + overrideConfig + <span class="hljs-string">&quot; for splash screen&quot;</span>);<br>            <span class="hljs-keyword">final</span> Context overrideContext = context.createConfigurationContext(overrideConfig);<br>            overrideContext.setTheme(theme);<br>            <span class="hljs-keyword">final</span> TypedArray typedArray = overrideContext.obtainStyledAttributes(com.android.internal.R.styleable.Window);<br><br>            <span class="hljs-comment">// 我们可以通过 windowBackground 设置窗口背景</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> resId = typedArray.getResourceId(R.styleable.Window_windowBackground, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (resId != <span class="hljs-number">0</span> &amp;&amp; overrideContext.getDrawable(resId) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// We want to use the windowBackground for the override context if it is</span><br>                <span class="hljs-comment">// available, otherwise we use the default one to make sure a themed starting</span><br>                <span class="hljs-comment">// window is displayed for the app.</span><br>                <span class="hljs-keyword">if</span> (DEBUG_SPLASH_SCREEN) Slog.d(TAG, <span class="hljs-string">&quot;addSplashScreen: apply overrideConfig&quot;</span><br>                        + overrideConfig + <span class="hljs-string">&quot; to starting window resId=&quot;</span> + resId);<br>                context = overrideContext;<br>            &#125;<br>            typedArray.recycle();<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> PhoneWindow win = <span class="hljs-keyword">new</span> PhoneWindow(context);<br>        <span class="hljs-comment">// ...</span><br>        addSplashscreenContent(win, context);<br>        wm = (WindowManager) context.getSystemService(WINDOW_SERVICE);<br>        view = win.getDecorView();<br>        wm.addView(view, params);<br>        <span class="hljs-comment">// ....</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSplashscreenContent</span><span class="hljs-params">(PhoneWindow win, Context ctx)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> TypedArray a = ctx.obtainStyledAttributes(R.styleable.Window);<br><br>    <span class="hljs-comment">// 看这里，我们可以通过 windowSplashscreenContent 设置 starting window content view 背景</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> resId = a.getResourceId(R.styleable.Window_windowSplashscreenContent, <span class="hljs-number">0</span>);<br>    a.recycle();<br>    <span class="hljs-keyword">if</span> (resId == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> Drawable drawable = ctx.getDrawable(resId);<br>    <span class="hljs-keyword">if</span> (drawable == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// We wrap this into a view so the system insets get applied to the drawable.</span><br>    <span class="hljs-keyword">final</span> View v = <span class="hljs-keyword">new</span> View(ctx);<br>    v.setBackground(drawable);<br>    win.setContentView(v);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>从上面的代码可以看出，starting window 有两个样式是比较重要的，而它们都来自于 launch activity theme</p><ol><li><code>windowBackground</code> 设置窗口背景</li><li><code>windowSplashscreenContent</code> 设置 content view 背景（requires API level 26）</li></ol><p>把 launch activity 的窗口背景设置为黑色，即可避免启动时由白到黑的闪屏问题</p><p>更进一步，把窗口背景替换为 launch activity 的 ifanr logo 素材，这样 starting window 和 launch activity 的背景一致，两个窗口无缝切换，视觉上就感受不到 starting window 的存在了，感觉上 app 的启动非常块</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windowDisablePreview</tag>
      
      <tag>starting window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity 启动流程时序图</title>
    <link href="/blog/2020/11/03/launch-activity-sequence/"/>
    <url>/blog/2020/11/03/launch-activity-sequence/</url>
    
    <content type="html"><![CDATA[<p>记录下启动 <code>Activity</code> 的时序图，方便后面查找</p><p><img src="../../../../image/2020-11-03-launch-activity-sequence/launch_activity.jpg" alt="launch_activity.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图解 Glide</title>
    <link href="/blog/2020/10/31/how-glide-work/"/>
    <url>/blog/2020/10/31/how-glide-work/</url>
    
    <content type="html"><![CDATA[<p>网上讲解 <code>Glide</code> 的文章一搜一大把，但几乎都是以文字的形式来讲解；我自己也写过不少 <code>Glide</code> 的笔记，也是文字为主；但是时间长了经常忘了其中的细节，加上 <code>Glide</code> 的源码不太易懂，所以决定用时序图来分析和记录研究 <code>Glide</code> 的过程</p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>下面两张图是一次图片加载的大体流程，有读过源码的同学基本上通过这两种图就能回忆起其中的细节；没读过源码的同学也可以先了解下 <code>Glide</code> 里各个类的作用</p><p><img src="../../../../image/2020-10-31-how-glide-work/glide_1.jpg" alt="glide_1.jpg"></p><p><img src="../../../../image/2020-10-31-how-glide-work/glide_task.jpg" alt="glide_task.jpg"></p><h2 id="RequestManager-请求管理器"><a href="#RequestManager-请求管理器" class="headerlink" title="RequestManager - 请求管理器"></a><code>RequestManager</code> - 请求管理器</h2><p>往 <code>Activity</code>/<code>Fragment</code> 添加一个 <code>RequestManagerFragment</code>（没有 <code>View</code>） 用以监听宿主的生命周期，从而实现请求的管理和绑定</p><p><img src="../../../../image/2020-10-31-how-glide-work/1.jpg" alt="1.jpg"></p><h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>内存缓存有 <code>ActiveResources</code> 和 <code>LruResourceCache</code>（<code>MemoryCache</code>），如下图，它们关系是：</p><ul><li>从 source/data 解码的 resource 将被加入 <code>ActiveResources</code></li><li>当 <code>onStop</code>/<code>onDestory</code>/<code>onTrimMemory</code> 时 resource 被释放，从 <code>ActiveResources</code> 移除并放入 <code>MemoryCache</code></li><li>加载时如果命中缓存，则从 <code>MemoryCache</code> 移除并加入 <code>ActiveResources</code></li></ul><p>它们的不同之处：</p><ul><li>它们对应 resource 的不同生命周期：使用中 - <code>ActiveResources</code>，释放后 - <code>MemoryCache</code></li><li><code>ActiveResources</code> 是对所有使用中 resource 的弱引用，相当于对所有使用中 resource 的收集和统计，没有大小限制</li><li><code>MemoryCache</code> 引用释放的资源，有大小限制，实现是 <code>LruResourceCache</code></li></ul><p><img src="../../../../image/2020-10-31-how-glide-work/glide_memory_cache.jpg" alt="glide_memory_cache.jpg"></p><h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><p>磁盘缓存有两层：data cache 和 resource cache，它们的关系在于：</p><ul><li>都是磁盘缓存，都以文件的形式存在于 disk cache dir，只是 key 不同</li><li>从网络抓取 → 保存为 data cache → 解码为 resource → 保存为 resource cache（optional）→ 返回 resource</li><li>下次加载时，先尝试加载 resource cache 再尝试加载 data cache</li></ul><p>它们的区别在于：</p><ul><li>data cache 缓存的是原始数据（也就是从 source 直接抓取到的数据流），resource cache 缓存的是解码后（比如 <code>Bitmap</code>）的数据</li><li>resource cache 能够加速解码的速度；比如 source 是网络上的图片，一般是 jpg or png，则从 data cache 加载需要解码为 Bitmap，而 resource cache 直接缓存 bitmap bytes，省了解码这步</li><li>resource cache 会增大磁盘缓存起码一倍；比如上述的 bitmap bytes 比压缩格式的 jpg 要大</li><li>是否有 resource cache 受几个条件的影响</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">DiskCacheStrategy<br>NONE      - 没有磁盘缓存<br>DATA      - 只缓存 data cache<br>RESOURCE  - 只缓存 resource cache<br>ALL       - 都缓存<br>AUTOMATIC - 自动<br><br><span class="hljs-comment">// 看下 AUTOMATIC 的情况</span><br><span class="hljs-comment">// data cache，只缓存网络资源，不缓存 asset file，local disk file 等本地资源</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDataCacheable</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> dataSource == DataSource.REMOTE;<br>&#125;<br><br><span class="hljs-comment">// resource cache 只缓存 asset file，local disk file 等本地资源</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isResourceCacheable</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((isFromAlternateCacheKey &amp;&amp; dataSource == DataSource.DATA_DISK_CACHE)<br>            || dataSource == DataSource.LOCAL)<br>            &amp;&amp; encodeStrategy == EncodeStrategy.TRANSFORMED;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="../../../../image/2020-10-31-how-glide-work/glide_disk_cache.jpg" alt="glide_disk_cache.jpg"></p><h2 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h2><p>使用池化技术（<code>ArrayPool</code> 和 <code>BitmapPool</code>）降低内存抖动</p><p><code>Glide</code> 在很多地方都需要临时用到一小块的内存，使用 byte array pool 可以平缓内存使用，避免频繁的内存申请</p><ul><li>io 时需要一个内存缓冲区来读写</li><li>从文件解码图片时 <code>BitmapFactory.Options.inTempStorage</code></li><li><code>downsample</code> 时需要先加载 image exif 信息</li></ul><p><code>BitmapPool</code> 则在 <code>Transformation.transform</code> 做 <code>Bitmap</code> 转换时用得比较多</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><ul><li>load memory cache 阶段是 ui 线程</li><li>decode cache 阶段是一个 decode 线程；此阶段会将 data 解码至 memory resource，采用单个线程排队解码，可以防止多个线程同时解码申请大内存造成内存抖动甚至 OOM</li><li>fetch source 阶段是线程池</li></ul><h2 id="加载路径"><a href="#加载路径" class="headerlink" title="加载路径"></a>加载路径</h2><p>加载路径把 model - dataClass - resourceClass - transcodeClass 串联起来</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// url string 是 model，类型是 String；transcodeClass 是 Drawable.class，最终的目标类型；此时的 resourceClass 是 Object.class</span><br>GlideApp.with(<span class="hljs-keyword">this</span>).as(Drawable.class).load(url).into(photoView);<br></code></pre></div></td></tr></table></figure><ol><li>通过 <code>ModelLoaderRegistry</code> 知道 model 能使用哪些 <code>ModelLoader</code>，能加载到 jvm 里成为哪些 dataClass；string url 的话，适用于 <code>StringLoader</code>，能加载为 <code>InputStream</code> 和 <code>ParcelFileDescriptor</code>；如果有多个 loader 可以用，则使用 <code>MultiModelLoader</code>，它专门用来包裹多个 loader，因为对于一个 model 可能会有多个 loader 可以处理它；对于 <code>MultiXXX</code>，内部都有个属性 <code>currentIndex</code> 指定使用哪个实例（一般情况下就是第 0 个了，除非有代码设置过 <code>currentIndex</code>）；loader 在注册表中的位置可以通过 append、prepend 调整</li><li>通过 <code>ResourceDecoderRegistry</code> 知道上述 dataClass 列表能够 decode 为哪些 resourceClass；<code>InputStream</code> 能够 decode 为 <code>Bitmap</code>，<code>GifDrawable</code> 和 <code>BitmapDrawable</code>；<code>ParcelFileDescriptor</code> 能够 decode 为 <code>Bitmap</code> 和 <code>BitmapDrawable</code></li><li>如果上述的 resourceClass 等于 transcodeClass 或它的子类，则把 resourceClass 加入到目标类型列表里；否则通过 <code>TranscoderRegistry</code> 判断能否使用注册的 <code>ResourceTranscoder</code> 将 resourceClass 转换为 transcodeClass 或它的子类，可以的话也将其加入目标类型列表里面；比如 <code>Bitmap</code> 可以用 <code>BitmapDrawableTranscoder</code> 转换为 <code>Drawable</code></li><li>最终得到一个目标类型列表，里面的类型等于 transcodeClass 或它的子类；它表明可以从 model 加载得到 <code>Drawable</code>；这个列表有：<code>Bitmap</code>，<code>BitmapDrawable</code>，<code>GifDrawable</code></li><li>按顺序（也即是注册表里的顺序），使用对应的 decoder 把 <code>InputStream</code> 解码；这里说下，因为 url 所在的是一张图片，所以 <code>StreamGifDecoder.handles</code> 发现不是 gif 会返回 false，于是不能转为 <code>GifDrawable</code>，跳到下一个；假设下一个是 <code>Bitmap</code>，可以正常 decode 为 <code>Drawable</code>，于是就略过了 <code>BitmapDrawable</code> 这个目标类型</li></ol><p><code>Glide</code> 有三层主要的 component：<code>ModelLoader</code>，<code>ResourceDecoder</code> 和 <code>ResourceTranscoder</code>；每层都注册了大量的实现，所以对于某个加载请求，会有多个路径；而到底使用哪条加载路径，取决于 component 在 <code>Register</code> 里的位置，靠前的 component 会被优先选择，如果这条路径走得通，那么后续的路径就被忽略了</p><ol><li>string url -&gt; <code>InputStream</code> -&gt; <code>Bitmap</code> -&gt; <code>Drawable</code>（用了 transcode，<code>Bitmap</code> 可以转换成 <code>BitmapDrawable</code>）</li><li>string url -&gt; <code>InputStream</code> -&gt; <code>BitmapDrawable</code></li><li>string url -&gt; <code>ByteBuffer</code> -&gt; <code>Bitmap</code> -&gt; <code>Drawable</code></li><li>…</li></ol><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><ol><li>同一个 <code>ImageView</code>，加载多个图片，为什么不会错乱呢？</li></ol><p>将 <code>Request</code> 放入 <code>View.setTag</code>，旧的 <code>Resquest</code> 将被新的 <code>Request</code> 取消，防止同一个 <code>ImageView</code> 的多个请求错乱</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Library</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Glide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读源码系列：ANR 是怎么产生的</title>
    <link href="/blog/2020/10/20/anr/"/>
    <url>/blog/2020/10/20/anr/</url>
    
    <content type="html"><![CDATA[<p>根据日常的经验我们大概知道，如果 app 没有及时消费 <code>MotionEvent</code>，超过 5s 就会弹出 ANR 对话框；那么 ANR 的逻辑肯定是在事件分发过程中产生的，我们从事件的源头找起，看看 input 事件是怎么产生的</p><h2 id="input-的分发"><a href="#input-的分发" class="headerlink" title="input 的分发"></a>input 的分发</h2><p><img src="../../../../image/2020-10-20-anr/sequence.png" alt="sequence.png"></p><p>事件分发是从线程 <code>InputReaderThread</code> 开始的，它的主要工作是：</p><ol><li>从目录 <code>/dev/input</code> 获取 input event<ul><li>看来 android 的输入设备是挂载在 <code>/dev/input</code> 下的，当然会有多个输入设备：屏幕触摸、键盘、手柄等，使用 <code>epoll</code> 监听多个 <code>fd</code></li><li><code>EventHub.getEvents()</code> 从 <code>fd</code> 读取 <code>input_event</code> 并转换为 <code>RawEvent</code>（看来输入设备的驱动都需要构造 <code>input_event</code> 给系统）</li></ul></li><li>经过识别分类（按键、手势、手柄、滚轮等）、过滤等一系列操作后，添加到 <code>mInboundQueue</code>（等待 <code>InputDispatcher</code> 分发）<ul><li><code>InputDevice</code> 将 <code>RawEvent</code> 交由各种 <code>InputMapper</code> 处理，例如：<code>KeyboardInputMapper</code> 将 <code>RawEvent</code> 包装为 <code>NotifyKeyArgs</code>，<code>TouchInputMapper</code> 将 <code>RawEvent</code> 包装为 <code>NotifyMotionArgs</code></li><li><code>InputDispatcher.notifyXXX</code> 将各种 <code>NotifyXXXArgs</code> 包装为 <code>XXXEntry</code> 放入 <code>mInboundQueue</code></li></ul></li></ol><p>这里需要补充下 Native Looper 不同于 Java Looper 的地方：提供了监听文件描述符的机制</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @param fd       需要监听的文件描述符</span><br><span class="hljs-comment"> * @param ident    表示为当前发生事件的标识符，必须 &gt;= 0，或者为 POLL_CALLBACK(-2) 如果指定了 callback</span><br><span class="hljs-comment"> * @param events   表示为要监听的文件类型，默认是 EVENT_INPUT</span><br><span class="hljs-comment"> * @param callback 当有事件发生时，会回调该 callback 函数</span><br><span class="hljs-comment"> * @param data</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 主要做了两件事：</span><br><span class="hljs-comment"> * 1，把输入参数构造成 Request，添加到 mRequests</span><br><span class="hljs-comment"> * 2，将 fd 添加到 epoll</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addFd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> ident, <span class="hljs-keyword">int</span> events, Looper_callbackFunc callback, <span class="hljs-keyword">void</span>* data)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addFd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> ident, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="hljs-keyword">void</span>* data)</span></span>;<br></code></pre></div></td></tr></table></figure><p>它有两种使用方式：</p><ul><li>指定 callback 来处理事件 : 当该文件描述符上有事件到来时，该 callback 会被执行；调用 <code>Looper.wake()</code> 也会触发 callback 执行</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// pollAll() -&gt; pollOnce() -&gt; pollInner()</span><br><br><span class="hljs-keyword">int</span> eventCount = <span class="hljs-built_in">epoll_wait</span>(mEpollFd.<span class="hljs-built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis)<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; eventCount; i++) &#123;<br>    <span class="hljs-keyword">int</span> fd = eventItems[i].data.fd;<br>    <span class="hljs-keyword">uint32_t</span> epollEvents = eventItems[i].events;<br>    <span class="hljs-keyword">if</span> (fd == mWakeEventFd.<span class="hljs-built_in">get</span>()) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">ssize_t</span> requestIndex = mRequests.<span class="hljs-built_in">indexOfKey</span>(fd);<br>        <span class="hljs-keyword">if</span> (requestIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-built_in">pushResponse</span>(events, mRequests.<span class="hljs-built_in">valueAt</span>(requestIndex));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mResponses.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    Response&amp; response = mResponses.<span class="hljs-built_in">editItemAt</span>(i);<br>    <span class="hljs-keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;<br>        <span class="hljs-keyword">int</span> fd = response.request.fd;<br>        <span class="hljs-keyword">int</span> events = response.events;<br>        <span class="hljs-keyword">void</span>* data = response.request.data;<br>        <span class="hljs-keyword">int</span> callbackResult = response.request.callback-&gt;<span class="hljs-built_in">handleEvent</span>(fd, events, data);<br>        <span class="hljs-keyword">if</span> (callbackResult == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">removeFd</span>(fd, response.request.seq);<br>        &#125;<br>        <span class="hljs-comment">// Clear the callback reference in the response structure promptly because we</span><br>        <span class="hljs-comment">// will not clear the response vector itself until the next poll.</span><br>        response.request.callback.<span class="hljs-built_in">clear</span>();<br>        result = POLL_CALLBACK;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>通过指定的 ident 来处理事件：当该文件描述符有数据到来时，<code>pollOnce()</code> 会返回一个 ident，调用者会判断该 ident 是否等于自己需要处理的事件 ident，如果是的话，则开始处理事件</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// pollAll() -&gt; pollOnce()</span><br><br><span class="hljs-keyword">for</span> (;;) &#123;<br>    <span class="hljs-keyword">while</span> (mResponseIndex &lt; mResponses.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">const</span> Response&amp; response = mResponses.<span class="hljs-built_in">itemAt</span>(mResponseIndex++);<br>        <span class="hljs-keyword">int</span> ident = response.request.ident;<br>        <span class="hljs-keyword">if</span> (ident &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> fd = response.request.fd;<br>            <span class="hljs-keyword">int</span> events = response.events;<br>            <span class="hljs-keyword">void</span>* data = response.request.data;<br>            <span class="hljs-keyword">if</span> (outFd != <span class="hljs-literal">nullptr</span>) *outFd = fd;<br>            <span class="hljs-keyword">if</span> (outEvents != <span class="hljs-literal">nullptr</span>) *outEvents = events;<br>            <span class="hljs-keyword">if</span> (outData != <span class="hljs-literal">nullptr</span>) *outData = data;<br>            <span class="hljs-keyword">return</span> ident;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="ui-如何接收和处理-input"><a href="#ui-如何接收和处理-input" class="headerlink" title="ui 如何接收和处理 input"></a>ui 如何接收和处理 input</h2><p>在分析事件分发的逻辑之前，我们先看看 ui 线程是怎么接收 input 事件的</p><p><img src="../../../../image/2020-10-20-anr/input_channel.png" alt="input_channel.png"></p><p>可以看到在 native 层打开了一对 socket，server socket fd 给 <code>InputDispatcher</code> 线程，client socket fd 给 ui 线程（<code>ViewRootImpl.mInputChannel</code>），也就是说它们之间通过 socket 双向通讯</p><p><img src="../../../../image/2020-10-20-anr/ui_thread.png" alt="ui_thread.png"></p><ol><li>接收：在 native 层用 Native Looper 监听 client socket fd（epoll），封装成 <code>InputMessage</code> 传递给 java 层处理</li><li>经过一个 <code>InputStage</code> 责任链的处理，最终到达我们最熟悉的 <code>View.dispatchTouchEvent</code></li><li>响应：ui 线程在消费完 input event 后，通过双向的 socket 告知 dispatcher 线程；如果此时 client socket 不可写，则将响应保存起来，等待下次 client socket 可写时</li><li>dispatcher - ui 这一段分发过程实际上是异步的，那么整个事件分发的过程也就是异步的，这是 ANR 产生的前提</li></ol><h2 id="input-的生命周期"><a href="#input-的生命周期" class="headerlink" title="input 的生命周期"></a>input 的生命周期</h2><p><img src="../../../../image/2020-10-20-anr/input_dispatcher.png" alt="input_dispatcher.png"></p><p>一个 input event 的生命流程大概是这样的：</p><ul><li><code>InputReader</code> 放入 <code>InputDispatcher.mInboundQueue</code> 等待分发</li><li><code>InputDispatcher</code> 将其移入 window 对应的 <code>Connection→outboundQueue</code> 等待发送</li><li>发送成功后，移入 <code>Connection→waitQueue</code> 等待 ui 线程的确认应答</li><li>收到确认应答，将 input event 移出 <code>Connection→waitQueue</code></li></ul><p>产生 ANR 的逻辑就在 <code>dispatchKeyLocked</code>（分发一个 input event 的过程）</p><p><img src="../../../../image/2020-10-20-anr/anr.jpg" alt="anr.jpg"></p><p>1，<code>findFocusedWindowTargetsLocked</code> 找到 input event 的分发 window 对象，然后 <code>checkWindowReadyForMoreInputLocked</code> 检查 widnow 是否可以接收 input event，这里截取一段检查逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// outboundQueue 不为空说明此 window 仍有 input event 未发送，waitQueue 不为空说明有 input event 在消费中（未收到消费完成的响应）</span><br><span class="hljs-comment">// 也就是说 input event 必须是按顺序分发和消费的，不能乱序</span><br><span class="hljs-keyword">if</span> (eventEntry-&gt;type == EventEntry::TYPE_KEY) &#123;<br>    <span class="hljs-keyword">if</span> (!connection-&gt;outboundQueue.<span class="hljs-built_in">isEmpty</span>() || !connection-&gt;waitQueue.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;Waiting to send key event because the %s window has not &quot;</span><br>                            <span class="hljs-string">&quot;finished processing all of the input events that were previously &quot;</span><br>                            <span class="hljs-string">&quot;delivered to it.  Outbound queue length: %d.  Wait queue length: &quot;</span><br>                            <span class="hljs-string">&quot;%d.&quot;</span>,<br>                            targetType, connection-&gt;outboundQueue.<span class="hljs-built_in">count</span>(),<br>                            connection-&gt;waitQueue.<span class="hljs-built_in">count</span>());<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (!connection-&gt;waitQueue.<span class="hljs-built_in">isEmpty</span>() &amp;&amp;<br>        currentTime &gt;= connection-&gt;waitQueue.head-&gt;deliveryTime + STREAM_AHEAD_EVENT_TIMEOUT) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;Waiting to send non-key event because the %s window has not &quot;</span><br>                            <span class="hljs-string">&quot;finished processing certain input events that were delivered to &quot;</span><br>                            <span class="hljs-string">&quot;it over &quot;</span><br>                            <span class="hljs-string">&quot;%0.1fms ago.  Wait queue length: %d.  Wait queue head age: &quot;</span><br>                            <span class="hljs-string">&quot;%0.1fms.&quot;</span>,<br>                            targetType, STREAM_AHEAD_EVENT_TIMEOUT * <span class="hljs-number">0.000001f</span>,<br>                            connection-&gt;waitQueue.<span class="hljs-built_in">count</span>(),<br>                            (currentTime - connection-&gt;waitQueue.head-&gt;deliveryTime) *<br>                                    <span class="hljs-number">0.000001f</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>2，最后走到 <code>AppErrors.handleShowAnrUi</code> 里就是弹出 ANR dialog 的地方</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>三个线程，<code>InputReader</code> 负责监听 input fd，<code>InputDispatcher</code> 负责分发给 ui，ui 消费并反馈给 <code>InputDispatcher</code></li><li><code>InputReader</code> 和 <code>InputDispatcher</code> 在同一进程，<code>mInboundQueue</code> 加锁使用即可；<code>InputDispatcher</code> 和 ui 在不同的进程，通过 socket 通讯</li><li>事件分发是一个异步的过程，所以它会在 <code>mInboundQueue</code>（待分发）、<code>outboundQueue</code>（待发送） 和 <code>waitQueue</code>（待响应） 之间流转</li><li>input event 必须按顺序分发和消费，一个 input event 在分发前必须等待上一个 input event 的响应，如果等待时间超过 5s 则发生 ANR</li><li>ANR dialog 是在 AMS 进程弹出的</li></ol><p>还学到了什么</p><p><code>epoll</code>（或者说 IO 多路复用）ui 线程是通过 socket 与 <code>InputDispatcher</code> 线程交互的，它既要等待 input event（不能阻塞）又要处理 ui 相关工作，靠的就是 epoll；具体来说是 native Looper，因为 epoll 可以同时监听多个 fd；用一个 wakeUpFd + messageQueue，当 enqueueMessage 时往 wakeUpFd 写入，从而唤醒线程处理 message；添加 socket fd，当 socket 可读时，唤醒线程处理 socket 过来的消息，而且还可以同时处理 message 和 socket</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://gityuan.com/2017/01/01/input-anr/">Input系统-ANR原理分析</a></li><li><a href="http://gityuan.com/2019/04/06/android-anr/">彻底理解安卓应用无响应机制</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ANR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文搞懂事件分发，手势冲突和滑动冲突</title>
    <link href="/blog/2020/10/04/dispatchtouchevent/"/>
    <url>/blog/2020/10/04/dispatchtouchevent/</url>
    
    <content type="html"><![CDATA[<p>手势冲突是 android 开发中经常遇到的一类问题了，网上讲解此问题的文章也很多，但是大都浅显地过一遍事件分发的调用栈，然后给出一个调用栈流程图；要不就是使用日志大法，用日志来验证自己的想法，完全没有参考价值；这里根据事件分发相关源码，记录下我的理解。</p><p><code>MotionEvent</code> 里定义的 <code>ACTION_XXX</code> 还不少有 10 多个，看起来情况很复杂的样子，实际上只需要关注三个：<code>ACTION_DOWN</code>，<code>ACTION_MOVE</code> 和 <code>ACTION_UP</code>，而且在一个手势里它们的顺序是：<code>ACTION_DOWN</code> → <code>ACTION_MOVE</code> → <code>ACTION_MOVE</code> → … → <code>ACTION_UP</code>。</p><h2 id="跟踪源码的调用栈"><a href="#跟踪源码的调用栈" class="headerlink" title="跟踪源码的调用栈"></a>跟踪源码的调用栈</h2><ul><li><code>Window.Callback.dispatchTouchEvent</code>（<code>Activity.dispatchTouchEvent</code> 实现了它，在 <code>Activity.attach</code> 里通过 <code>Window.setCallback</code> 设置进去）</li><li><code>Window.superDispatchTouchEvent</code>（实现在 <code>PhoneWindow.superDispatchTouchEvent</code>）</li><li><code>DecorView.superDispatchTouchEvent</code></li><li><code>ViewGroup.dispatchTouchEvent</code></li><li><code>ViewGroup.onInterceptTouchEvent</code></li><li><code>View.dispatchTouchEvent</code></li><li><code>View.onTouchEvent</code></li><li><code>ViewGroup.onTouchEvent</code></li><li><code>Activity.onTouchEvent</code></li></ul><p>网上大部分文章到此就结束了，实际上重点应该在 <code>ViewGroup.dispatchTouchEvent</code>，里面是事件分发的核心逻辑，我把它切分为三个阶段：</p><h3 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// DOWN 会被拦截，后续的 MOVE 和 UP 如果有 touch target 也会被拦截</span><br><span class="hljs-comment">// Check for interception.</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> intercepted;<br><span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// 可以通过 requestDisallowInterceptTouchEvent 跳过此阶段，</span><br>    <span class="hljs-comment">// 一般是 child 调用 parent.requestDisallowInterceptTouchEvent 来阻止 parent 拦截 touch event</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!disallowIntercept) &#123;<br>        intercepted = onInterceptTouchEvent(ev);<br>        ev.setAction(action); <span class="hljs-comment">// restore action in case it was changed</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        intercepted = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 后续的 MOVE 和 UP 没有 touch target 则直接走向 onTouchEvent 也就不需要拦截了</span><br>    <span class="hljs-comment">// There are no touch targets and this action is not an initial down</span><br>    <span class="hljs-comment">// so this view group continues to intercept touches.</span><br>    intercepted = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 收到 CANCEL 或者 onInterceptTouchEvent 返回 true，则不分发 DOWN 给 children</span><br><span class="hljs-comment">// 导致 children 收不到 DOWN 以及没有 touch target</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="hljs-keyword">this</span>) || actionMasked == MotionEvent.ACTION_CANCEL;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN<br>        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)<br>        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;<br>        <span class="hljs-comment">// ... 按顺序分发 ACTION_DOWN，child index(in children array) 越大优先级越高，child z value 越大优先级越高</span><br>        <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = childrenCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);<br>            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);<br>            <span class="hljs-comment">// ... touch 是否落在 child 的矩形区域内</span><br>            <span class="hljs-keyword">if</span> (!child.canReceivePointerEvents()<br>                || !isTransformedTouchPointInView(x, y, child, <span class="hljs-keyword">null</span>)) &#123;<br>                ev.setTargetAccessibilityFocus(<span class="hljs-keyword">false</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// ... 将 touch event 坐标转换为 child 区域坐标，分发给 child；当有第一个 child 消费时，记录起来并中断剩下的分发过程</span><br>            <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="hljs-keyword">false</span>, child, idBitsToAssign)) &#123;<br>                <span class="hljs-comment">// ...</span><br>                newTouchTarget = addTouchTarget(child, idBitsToAssign);<br>                alreadyDispatchedToNewTouchTarget = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 如果没有 touch target，则走自己的 View.dispatchTouchEvent 流程（相当于流向 onTouchEvent）</span><br><span class="hljs-comment">// Dispatch to touch targets.</span><br><span class="hljs-keyword">if</span> (mFirstTouchTarget == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// No touch targets so treat this as an ordinary view.</span><br>    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="hljs-keyword">null</span>, TouchTarget.ALL_POINTER_IDS);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 分发给 touch target</span><br>    <span class="hljs-comment">// 但如果 onInterceptTouchEvent 返回 true，则发送 CANCEL 给 touch target，后续将不再流向 touch target，而是直接流向 onTouchEvent</span><br>    <span class="hljs-comment">// onInterceptTouchEvent 拦截的那个 touch 不会流向 onTouchEvent</span><br>    TouchTarget predecessor = <span class="hljs-keyword">null</span>;<br>    TouchTarget target = mFirstTouchTarget;<br>    <span class="hljs-keyword">while</span> (target != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">final</span> TouchTarget next = target.next;<br>        <span class="hljs-keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;<br>            handled = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)<br>                    || intercepted;<br>            <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,<br>                    target.child, target.pointerIdBits)) &#123;<br>                handled = <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cancelChild) &#123;<br>                <span class="hljs-keyword">if</span> (predecessor == <span class="hljs-keyword">null</span>) &#123;<br>                    mFirstTouchTarget = next;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    predecessor.next = next;<br>                &#125;<br>                target.recycle();<br>                target = next;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        predecessor = target;<br>        target = next;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结-dispatchTouchEvent"><a href="#总结-dispatchTouchEvent" class="headerlink" title="总结 dispatchTouchEvent"></a>总结 <code>dispatchTouchEvent</code></h2><ul><li><code>onInterceptTouchEvent</code> 总是会收到 DOWN，但不一定会收到后续的 MOVE 和 UP（没有 touch target 的话，就不需要拦截了，直接走到 <code>onTouchEvent</code> 去了）</li><li>只有在第一个 DOWN 时，才会分发给所有的 children，找到第一个消费的 child（就是 touch target，后续的 MOVE 和 UP 只分发给它）</li><li><code>onInterceptTouchEvent</code> 返回 true 会导致 touch target 置空（并收到 CANCEL），这样后续的 MOVE 和 UP 因为没有 touch target 而直接走向 <code>onTouchEvent</code></li><li>child 通过 <code>requestDisallowInterceptTouchEvent</code> 告知 parent 不要拦截事件流，交由 child 处理</li></ul><h2 id="常见滑动效果的实现"><a href="#常见滑动效果的实现" class="headerlink" title="常见滑动效果的实现"></a>常见滑动效果的实现</h2><p>了解 <code>dispatchTouchEvent</code> 后，我们看看常用的具有滑动效果的 widget 是怎么处理 touch event 的，参考 <code>ViewPager</code> 和 <code>RecyclerView</code>，代码比较多，这里就不贴了，总结下其套路：</p><ul><li>在 <code>onInterceptTouchEvent</code> 和 <code>onTouchEvent</code> 这两个方法里介入</li><li><code>onInterceptTouchEvent</code> 只监听不拦截 DOWN；拦截 DOWN 会导致 children 接收不到 DOWN，那么它们的 OnClick 和 OnLongClick 就无法触发；更复杂的情况是 children 里也包含具有滑动效果的 widget</li><li><code>onTouchEvent</code> 返回 true 做一个兜底方案；万一没有 child 消费 touch（一般情况是没有 <code>OnClickListener</code>），而自己也不消费 touch 的话，就会没有 touch target，后续的 touch event 会直接流向 parent.<code>onTouchEvent</code>，我们想拦截也拦截不了</li><li>在 <code>onInterceptTouchEvent</code> 里监听和拦截（满足情况下）MOVE，<code>onTouchEvent</code> 里也要消费 MOVE（没有 child 消费 touch 的话，后续的 touch 就直接流向 <code>onTouchEvent</code> 了）</li><li><code>ACTION_MOVE</code> 不会直接触发滑动，而是与 <code>ACTION_DOWN</code> 的点有了一定长度的距离后才触发，这个距离叫 touch slop（<code>ViewConfiguration#getScaledTouchSlop</code>），用以消除抖动，使滑动效果更加顺滑</li></ul><p>记住上面的关键点，基本上就可以解决大部分手势冲突，并能够开发稳健的具有手势的 <code>ViewGroup</code> 了；但实际开发中，有一个问题是更加常见的：滑动冲突。在引入嵌套滑动之前，说说为什么 <code>dispatchTouchEvent</code> 很难解决滑动冲突。滑动一般是由 MOVE &gt; touch slop 触发，这样 parent 总是会优先触发而 child 总是会被屏蔽，而且只能由 child 发起 <code>requestDisallowInterceptTouchEvent</code> 告知 parent 不要拦截，从 parent 的视角看，没有其他办法主动得知 child 的需求，而大多数滑动冲突是需要在 parent 里解决的（脑补淘宝、京东这类 app 的首页）。</p><h2 id="引入-NestedScrollingChild-和-NestedScrollingParent-解决滑动冲突"><a href="#引入-NestedScrollingChild-和-NestedScrollingParent-解决滑动冲突" class="headerlink" title="引入 NestedScrollingChild 和 NestedScrollingParent 解决滑动冲突"></a>引入 <code>NestedScrollingChild</code> 和 <code>NestedScrollingParent</code> 解决滑动冲突</h2><p>上面我们在分析 <code>ViewPager</code> 和 <code>RecyclerView</code> 的与滚动相关的代码时了解到，<code>ACTION_MOVE</code> 会产生 scroll 和 fling 的动量 dy（垂直方向），全部由自己消费掉（View.scrollBy）就会产生滑动的效果；而嵌套滑动引入了协商机制，对于动量 dy：</p><ol><li>先给 parent 消费，parent 可以根据自身情况，选择不消费、消费一部分或者消费全部，此时 dy = dy - consumed</li><li>child 根据滋生情况，消费剩下的 dy（全部 or 部分），此时 dy = dy - consumed</li><li>如果还有 dy 剩余（dy &gt; 0），则把剩余的 dy 的处置权交由 parent</li></ol><p>对于上述流程，android 提供了实现：NestedScrollingChildHelper，我们在实现 NestedScrollingChild 时，只需把方法代理至 helper 即可实现通用的 child 逻辑</p><p>具体 api 调用流如下图：</p><p><img src="../../../../image/2020-10-04-dispatchtouchevent/01.jpg" alt="01.jpg"></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="三段式布局"><a href="#三段式布局" class="headerlink" title="三段式布局"></a>三段式布局</h3><p><img src="../../../../image/2020-10-04-dispatchtouchevent/02.jpeg" alt="02.jpeg"></p><p>这里以常见的三段式布局为例子看下嵌套滑动怎么用；上图是淘宝首页，由 head、bar 和 list 三个部分组成，bar 在滑动时会粘连在顶部</p><ol><li>当 touch 落在 list 上时，由 list 产生动量 dy，在 list 消费 dy 前，先给 parent 消费，parent 完全消费 dy，scroll 三个 child 直到 head 不可见</li><li>list 因为 dy 被 parent 消费掉而不产生滑动，直到 head 不可见才有剩下的 dy 用以消费，产生滑动</li><li>当 touch 落在 head 和 bar 上时，由 parent 产生动量 dy；此时 parent 才是 child，而 list 是 parent（明确谁是 child，谁是 parent，view tree 结构上的父子关系不一定是嵌套滑动里的父子关系，动量产生者才是 child，child 主动分发动量）</li><li>parent 先消费 dy 直到 head 不可见，然后分发给 list</li><li>fling 同理</li></ol><h3 id="更复杂的布局"><a href="#更复杂的布局" class="headerlink" title="更复杂的布局"></a>更复杂的布局</h3><p><img src="../../../../image/2020-10-04-dispatchtouchevent/03.jpg" alt="03.jpg"></p><p>结合上述的所有办法，解决更加复杂的页面；上图是糖纸的首页，最外层是 <code>ViewPager</code>，然后是 refresh layout 加上三段式的布局，head 里又有可以左右滑动的 banner 和卡片列表，还有可以上下滑动的滚动资讯条，我们一个个解决：</p><ul><li>banner 是可以左右滑动的，会与 <code>ViewPager</code> 冲突；我的期望是当 touch 落在 banner 上时，左右滑动完全交由 banner 处理，所以给 <code>ViewPager</code> 添加一个 freeze 方法（当 ViewPager is freeze 时不拦截 touch，此时不能使用 <code>requestDisallowInterceptTouchEvent</code> 否则上下滑动被屏蔽）；而上下滑动距离又会引起 refresh 和三段布局的滑动，需在 banner 触发左右滑动时，调用 <code>requestDisallowInterceptTouchEvent</code> 让 parents 不在拦截 touch</li><li>上下滚动的咨询条，同 banner 的处理方式，只不过它只需解决 refresh 和三段布局的上下滑动冲突即可：它自己完全消费动量 dy</li><li>左右滑动的卡片列表同 banner</li><li><code>SwipeRefreshLayout</code> 看下述源码可以看到是由 touch event 和 nested scroll 两种方式触发，touch event 不够灵活屏蔽掉，选用 nested scroll；<code>dispatchNestedPreScroll</code>、<code>dispatchNestedScroll</code>、<code>dispatchNestedPreFling</code> 和 <code>dispatchNestedFling</code> 正常触发，<code>startNestedScroll</code> 则在 scrollY == 0 时触发，这样就只在滚动到顶的时候才触发 refresh。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 显示 loading</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startDragging</span><span class="hljs-params">(<span class="hljs-keyword">float</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> yDiff = y - mInitialDownY;<br>    <span class="hljs-keyword">if</span> (yDiff &gt; mTouchSlop &amp;&amp; !mIsBeingDragged) &#123;<br>        mInitialMotionY = mInitialDownY + mTouchSlop;<br>        mIsBeingDragged = <span class="hljs-keyword">true</span>;<br>        mProgress.setAlpha(STARTING_PROGRESS_ALPHA);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 由 touch event 触发 loading</span><br><span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>    pointerIndex = ev.findPointerIndex(mActivePointerId);<br>    <span class="hljs-keyword">if</span> (pointerIndex &lt; <span class="hljs-number">0</span>) &#123;<br>        Log.e(LOG_TAG, <span class="hljs-string">&quot;Got ACTION_MOVE event but have an invalid active pointer id.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> y = ev.getY(pointerIndex);<br>    startDragging(y);<br><br>    <span class="hljs-keyword">if</span> (mIsBeingDragged) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> overscrollTop = (y - mInitialMotionY) * DRAG_RATE;<br>        <span class="hljs-keyword">if</span> (overscrollTop &gt; <span class="hljs-number">0</span>) &#123;<br>            moveSpinner(overscrollTop);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 由 nested scroll 触发 loading</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNestedScroll</span><span class="hljs-params">(<span class="hljs-keyword">final</span> View target, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dxConsumed, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dyConsumed,</span></span><br><span class="hljs-function"><span class="hljs-params">                           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dxUnconsumed, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dyUnconsumed)</span> </span>&#123;<br>    <span class="hljs-comment">// Dispatch up to the nested parent first</span><br>    dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed,<br>            mParentOffsetInWindow);<br><br>    <span class="hljs-comment">// This is a bit of a hack. Nested scrolling works from the bottom up, and as we are</span><br>    <span class="hljs-comment">// sometimes between two nested scrolling views, we need a way to be able to know when any</span><br>    <span class="hljs-comment">// nested scrolling parent has stopped handling events. We do that by using the</span><br>    <span class="hljs-comment">// &#x27;offset in window &#x27;functionality to see if we have been moved from the event.</span><br>    <span class="hljs-comment">// This is a decent indication of whether we should take over the event stream or not.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dy = dyUnconsumed + mParentOffsetInWindow[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (dy &lt; <span class="hljs-number">0</span> &amp;&amp; !canChildScrollUp()) &#123;<br>        mTotalUnconsumed += Math.abs(dy);<br>        moveSpinner(mTotalUnconsumed);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TouchEvent</tag>
      
      <tag>Motion</tag>
      
      <tag>NestedScrolling</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官家常之Handler、MessageQueue 和 Looper</title>
    <link href="/blog/2020/09/27/handler-messagequeue-looper/"/>
    <url>/blog/2020/09/27/handler-messagequeue-looper/</url>
    
    <content type="html"><![CDATA[<p><code>MessageQueue</code> 是个单向链表，按 <code>Message.when</code> 自然序排</p><p>它有类似于「生产者 - 消费者」模型的阻塞队列：没有 <code>Message</code> 时，阻塞直到新 <code>Message</code> 入队；否则阻塞到下一个 <code>Message.when</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 这里会阻塞</span><br>nativePollOnce(ptr, nextPollTimeoutMillis);<br><br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-comment">// ... ...</span><br>    <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>            <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>            <span class="hljs-comment">// 阻塞一段时间，直到时间到达下一个 message.when</span><br>            nextPollTimeoutMillis = (<span class="hljs-keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Got a message.</span><br>            mBlocked = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-keyword">null</span>) &#123;<br>                prevMsg.next = msg.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mMessages = msg.next;<br>            &#125;<br>            msg.next = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);<br>            msg.markInUse();<br>            <span class="hljs-keyword">return</span> msg;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// No more messages.</span><br>        <span class="hljs-comment">// 没有 Message，阻塞直到 enqueueMessage 时被唤醒</span><br>        nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// ... ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 查看 c 层源码，可以看到 nativePollOnce 是通过 epoll 实现的</span><br><br><span class="hljs-comment">// 阻塞</span><br>MessageQueue.nativePollOnce -&gt;<br>android_os_MessageQueue_nativePollOnce -&gt;<br>NativeMessageQueue::pollOnce -&gt;<br>Looper::pollOnce -&gt;<br>Looper::pollInner -&gt;<br><span class="hljs-built_in">epoll_wait</span>(mEpollFd.<span class="hljs-built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);<br><br><span class="hljs-comment">// 唤醒</span><br>MessageQueue.enqueueMessage -&gt;<br>MessageQueue.nativeWake -&gt;<br>android_os_MessageQueue_nativeWake -&gt;<br>NativeMessageQueue::wake -&gt;<br>Looper::wake -&gt;<br><span class="hljs-built_in">write</span>(mWakeEventFd.<span class="hljs-built_in">get</span>(), &amp;inc, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">uint64_t</span>));<br></code></pre></div></td></tr></table></figure><p>与 <code>NativeMessageQueue</code>、<code>NativeLooper</code> 的关系</p><ol><li>每个 <code>MessageQueue</code> 持有一个 <code>NativeMessageQueue</code>，而 <code>NativeMessageQueue</code> 又持有当前线程的 <code>NativeLooper</code></li><li>关键的阻塞和唤醒函数都是由 <code>NativeLooper</code> 实现的，也就是 <code>epoll</code> 实现的阻塞和唤醒；只不过这个线程在 <code>native</code> 层进行 loop poll 操作<ul><li><code>MessageQueue.nativePollOnce</code> → <code>NativeMessageQueue.pollOnce</code> → <code>NativeLooper.pollOnce</code></li><li><code>MessageQueue.nativeWake</code> → <code>NativeMessageQueue.wake</code> → <code>NativeLooper.wake</code></li></ul></li></ol><p>同步栅栏（<code>SyncBarrier</code>）</p><p>开启同步栅栏后，“栅栏”将会把 sync message 过滤掉，仅处理 async message，是一种提高 <code>Message</code> 优先级的方法</p><p><code>postSyncBarrier</code> 开启同步栅栏，<code>removeSyncBarrier</code> 关闭同步栅栏，“栅栏”就是一个 target == null 的 <code>Message</code></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Message msg = mMessages;    <span class="hljs-comment">// head of linked list</span><br><span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; msg.target == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// it is a barrier</span><br>    <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        prevMsg = msg;<br>        msg = msg.next;<br>    &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; !msg.isAsynchronous());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>主线程 <code>Looper</code> 与子线程 <code>Looper</code> 有什么不同？</p><p>主要区别在于 main looper <code>queue.mQuitAllowed == false</code>，即不允许 <code>looper.quit</code> 退出</p><p><code>Looper.quit()</code> 和 <code>Looper.quitSafely()</code> 有什么区别？</p><p><code>quit</code> 直接回收所有 message；而 <code>quitSafely</code> 则只回收 future message（还未到执行时间），继续执行完所有已到时间的 message 才结束</p><p>既然可以存在多个 <code>Handler</code> 往 <code>MessageQueue</code> 中添加数据（发消息时各个 <code>Handler</code> 可能处于不同线程），那它内部是如何确保线程安全的？</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 加了锁</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>    <span class="hljs-comment">// ... ...</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-comment">// ... ...</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>Looper.loop()</code> 为什么不会导致死循环？</p><p>queue 是个阻塞队列，（当前时间点）没有 message 时，会阻塞 thread 而不消耗 cpu；当有新 message 入队时，会唤醒 thread；参考上面阻塞和唤醒的代码片段</p><p><code>Handler </code>造成泄露的原因</p><p>非静态内部类会持有一个外部类的隐式引用，比如下述写法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Handler handler = <span class="hljs-keyword">new</span> Handler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> </span>&#123;&#125;<br>&#125;;<br><br>handler.post(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>那么我们可以追溯出一条完整的 gc root path：</p><p>activity → handler/runnable → message(target/callback) → queue → looper → class looper(static field sThreadLocal) → thread</p><p>解决办法：使用 <code>WeakReference</code></p><p>tip:</p><p>可以在 <a href="https://cs.android.com/android">https://cs.android.com/android</a> 用类名、方法名等 symbol 搜索 aosp 代码，简单方便；各种 symbol 之间还有关联，可以点击跳转</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Handler</tag>
      
      <tag>Looper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git log命令全解析，打log还能这么随心所欲！</title>
    <link href="/blog/2020/09/15/git-log/"/>
    <url>/blog/2020/09/15/git-log/</url>
    
    <content type="html"><![CDATA[<p><code>git log</code> 命令非常强大而好用，在复杂系统的版本管理中扮演着重要的角色，但默认的 <code>git log</code> 命令显示出的东西实在太丑，不好好打扮一下根本没法见人，打扮好了用 <code>alias</code> 命令拍个照片，就正式出道了！</p><p>下面先详细而系统地介绍 <code>git log</code> 的所有配置知识（用我一向简洁清晰的表述方式），熟悉了这些东西，你就可以自由配置自己美丽的 <code>git log</code> 了～<br>最后上个干货，直接给一个我打扮好的 <code>alias</code> 配置，懒人直接跳到最后吧 ！</p><p><code>git log</code> 用于查询版本的历史，命令形式如下：<code>git log [&lt;options&gt;] [&lt;since&gt;..&lt;until&gt;] [[--] &lt;path&gt;...]</code></p><h2 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h2><ul><li>如果不带任何参数，它会列出所有历史记录，最近的排在最上方，显示提交对象的哈希值，作者、提交日期、和提交说明</li><li>如果记录过多，则按Page Up、Page Down、↓、↑来控制显示</li><li>按q退出历史记录列表</li></ul><h2 id="显示参数"><a href="#显示参数" class="headerlink" title="显示参数"></a>显示参数</h2><ul><li><code>p</code>：按补丁显示每个更新间的差异，比下一条 <code>-stat</code> 命令信息更全</li><li><code>-stat</code>：显示每次更新的修改文件的统计信息，每个提交都列出了修改过的文件，以及其中添加和移除的行数，并在最后列出所有增减行数小计</li><li><code>-shortstat</code>：只显示 <code>-stat</code> 中最后的行数添加修改删除统计</li><li><code>-name-only</code>：尽在已修改的提交信息后显示文件清单</li><li><code>-name-status</code>：显示新增、修改和删除的文件清单</li><li><code>-abbrev-commit</code>：仅显示SHA-1的前几个字符，而非所有的40个字符</li><li><code>-relative-date</code>：使用较短的相对时间显示（例如：”two weeks ago”）</li><li><code>-graph</code>：显示 ASCII 图形表示的分支合并历史</li><li><code>-pretty＝</code>：使用其他格式显示历史提交信息，可选项有：<code>oneline</code>, <code>short</code>, <code>medium</code>, <code>full</code>, <code>fuller</code>, <code>email</code>, <code>raw</code> 以及 <code>format</code>，默认为 <code>medium</code>，如：<ul><li><code>-pretty=oneline</code>：一行显示，只显示哈希值和提交说明（<code>--online</code> 本身也可以作为单独的属性）</li><li><code>-pretty=format:</code>：控制显示的记录格式，如：<ul><li><code>%H</code> 提交对象（commit）的完整哈希字串</li><li><code>%h</code> 提交对象的简短哈希字串</li><li><code>%T</code> 树对象（tree）的完整哈希字串</li><li><code>%t</code> 树对象的简短哈希字串</li><li><code>%P</code> 父对象（parent）的完整哈希字串</li><li><code>%p</code> 父对象的简短哈希字串</li><li><code>%an</code> 作者（author）的名字</li><li><code>%ae</code> 作者的电子邮件地址</li><li><code>%ad</code> 作者修订日期（可以用 -date= 选项定制格式）</li><li><code>%ar</code> 作者修订日期，按多久以前的方式显示</li><li><code>%cn</code> 提交者(committer)的名字<ul><li>作者和提交者的区别不知道是啥？</li><li>作者与提交者的关系：作者是程序的修改者，提交者是代码提交人（自己的修改不提交是怎么能让别人拉下来再提交的？）</li><li>其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者（soga）</li></ul></li><li><code>%ce</code> 提交者的电子邮件地址</li><li><code>%cd</code> 提交日期（可以用 <code>-date=</code> 选项定制格式）</li><li><code>%cr</code> 提交日期，按多久以前的方式显示</li><li><code>%s</code> 提交说明</li></ul></li><li>带颜色的 <code>--pretty=format:</code>，这个另外写出来分析；以这句为例：<code>%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;</code>，它的效果是 <img src="../../../../image/2020-09-15-git-log/1.png" alt="1.png">；先断句：[<code>%Cred%h</code>]，[<code>%Creset -</code>]，[<code>%C(yellow)%d</code>]，[<code>%Cblue%s</code>]，[<code>%Cgreen(%cd)</code>]，[<code>%C(bold blue)&lt;%an&gt;</code>]；然后就是很明显能得到的规律了：一个颜色＋一个内容，颜色以 <code>％C</code> 开头，后边接几种颜色，还可以设置字体，如果要设置字体的话，要一块加个括号，能设置的颜色值包括：<code>reset</code>（默认的灰色），<code>normal</code>, <code>black</code>, <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>magenta</code>, <code>cyan</code>, <code>white</code>。字体属性则有 <code>bold</code>, <code>dim</code>, <code>ul</code>, <code>blink</code>, <code>reverse</code>；内容可以是占位元字符，也可以是直接显示的普通字符。</li></ul></li><li><code>-date=(relative|local|default|iso|rfc|short|raw)</code>：定制后边如果出现 <code>%ad</code> 或 <code>%cd</code> 时的日期格式<ul><li>有几个默认选项<ol><li><code>-date=relative</code>：shows dates relative to the current time, e.g. “2 hours ago”.</li><li><code>-date=local</code>：shows timestamps in user’s local timezone.</li><li><code>-date=iso</code> (or <code>--date=iso8601</code>)：shows timestamps in ISO 8601 format.</li><li><code>-date=rfc</code> (or <code>--date=rfc2822</code>)：shows timestamps in RFC 2822 format,often found in E-mail messages.</li><li><code>-date=short</code>：shows only date but not time, in YYYY-MM-DD format.这个挺好用</li><li><code>-date=raw</code>：shows the date in the internal raw git format %s %z format.</li><li><code>-date=default</code>：shows timestamps in the original timezone (either committer’s or author’s).</li></ol></li><li>也可以自定义格式（需要git版本2.6.0以上），比如 <code>--date=format:&#39;%Y-%m-%d %H:%M:%S&#39;</code> 会格式化成：2016-01-13 11:32:13，其他的格式化占位符如下：<ol><li><code>%a</code>：Abbreviated weekday name</li><li><code>%A</code>：Full weekday name</li><li><code>%b</code>：Abbreviated month name</li><li><code>%B</code>：Full month name</li><li><code>%c</code>：Date and time representation appropriate for locale</li><li><code>%d</code>：Day of month as decimal number (01 – 31)</li><li><code>%H</code>： Hour in 24-hour format (00 – 23)</li><li><code>%I</code>：Hour in 12-hour format (01 – 12)</li><li><code>%j</code>：Day of year as decimal number (001 – 366)</li><li><code>%m</code>：Month as decimal number (01 – 12)</li><li><code>%M</code>：Minute as decimal number (00 – 59)</li><li><code>%p</code>：Current locale’s A.M./P.M. indicator for 12-hour clock</li><li><code>%S</code>：Second as decimal number (00 – 59)</li><li><code>%U</code>：Week of year as decimal number, with Sunday as first day of week (00 – 53)</li><li><code>%w</code>：Weekday as decimal number (0 – 6; Sunday is 0)</li><li><code>%W</code>：Week of year as decimal number, with Monday as first day of week (00 – 53)</li><li><code>%x</code>：Date representation for current locale</li><li><code>%X</code>：Time representation for current locale</li><li><code>%y</code>：Year without century, as decimal number (00 – 99)</li><li><code>%Y</code>：Year with century, as decimal number</li><li><code>%z</code>, <code>%Z</code>：Either the time-zone name or time zone abbreviation, depending on registry settings; no characters if time zone is unknown</li><li><code>%%</code>：Percent sign</li></ol></li></ul></li></ul><h2 id="筛选参数"><a href="#筛选参数" class="headerlink" title="筛选参数"></a>筛选参数</h2><ol><li>按数量<ol><li>n：显示前n条log</li></ol></li><li>按日期<ol><li><code>-after=</code><ol><li>比如 <code>git log --after=&quot;2014-7-1”</code>，显示2014年7月1号之后的commit(包含7月1号)</li><li>后边的日期还可以用相对时间表示，比如”1 week ago”和”yesterday”，比如 <code>git log --after=&quot;yesterday&quot;</code></li><li>这里的格式可以是什么？</li></ol></li><li><code>-before=</code><ol><li>同上</li><li>另外这两条命令可以同时使用表示时间段，比如 <code>git log --after=&quot;2014-7-1&quot; --before=&quot;2014-7-4&quot;</code></li><li>另外 <code>--since</code> <code>--until</code> 和 <code>--after`` --before</code> 是一个意思，都可以用</li></ol></li></ol></li><li>按作者<ol><li><code>-author=</code><ol><li>比如 <code>git log --author=“John&quot;</code>，显示John贡献的commit</li><li>注意：作者名不需要精确匹配，只需要包含就行了</li><li>而且：可以使用正则表达式，比如 <code>git log --author=&quot;John\|Mary”</code>，搜索Marry和John贡献的commit</li><li>而且：这个 <code>--author</code> 不仅包含名还包含email, 所以你可以用这个搜索email</li></ol></li></ol></li><li>按commit描述<ol><li><code>-grep=</code><ol><li>比如：<code>git log --grep=&quot;JRA-224&quot;</code></li><li>而且：可以传入-i用来忽略大小写</li><li>注意：如果想同时使用 <code>--grep</code> 和 <code>--author</code>，必须在附加一个 <code>--all-match</code> 参数</li></ol></li></ol></li><li>按文件<ol><li>（空格）或［没有］<ol><li>有时你可能只对某个文件的修改感兴趣, 你只想查看跟某个文件相关的历史信息, 你只需要插入你感兴趣文件的路径［对，是路径，所以经常是不太好用］就可以了</li><li>比如：<code>git log -- foo.py bar.py</code>，只返回和 foo.py 或 bar.py 相关的 commit</li><li>这里的–是告诉 Git 后面的参数是文件路径而不是 branch name. 如果后面的文件路径不会和某个 branch 产生混淆, 你可以省略 <code>--</code>，比如 <code>git log foo.py</code></li><li>另外，后边的路径还支持正则，比如：<code>git log *install.md</code> 是，指定项目路径下的所有以 install.md 结尾的文件的提交历史</li><li>另外，文件名应该放到参数的最后位置，通常在前面加上 <code>--</code> 并用空格隔开表示是文件</li><li>另外，<code>git log file/</code> 查看 file 文件夹下所有文件的提交记录</li></ol></li></ol></li><li>按分支<ol><li><ol><li><code>-branchName</code> branchName为任意一个分支名字，查看某个分支上的提交记录</li><li>需要放到参数中的最后位置处</li><li>如果分支名与文件名相同，系统会提示错 误，可通过–选项来指定给定的参数是分支名还是文件名<ol><li>比如：在当前分支中有一个名为v1的文件，同时还存在一个名为v1的分支</li><li><code>git log v1 --</code> 此时的v1代表的是分支名字（－－后边是空的）</li><li><code>git log -- v1</code> 此时的v1代表的是名为v1的文件</li><li><code>git log v1 －－ v1</code> 代表v1分支下的v1文件</li></ol></li></ol></li></ol></li><li>按内容<ol><li><code>-S&quot;&lt;&gt;&quot;</code>、<code>-G&quot;&lt;&gt;&quot;</code><ol><li>有时你想搜索和新增或删除某行代码相关的commit. 可以使用这条命令</li><li>假设你想知道Hello, World!这句话是什么时候加入到项目里去的，可以用：<code>git log -S&quot;Hello,World!&quot;</code></li><li>另外：如果你想使用正则表达式去匹配而不是字符串, 那么你可以使用-G代替-S.</li><li>这是一个非常有用的debug工具, 使用他你可以定位所有跟某行代码相关的commit. 甚至可以查看某行是什么时候被copy的, 什么时候移到另外一个文件中去的</li><li>注：-S后没有”=”，与查询内容之间也没有空格符</li></ol></li></ol></li><li>按范围<ol><li><code>git log &lt;since&gt;..&lt;until&gt;</code><ol><li>这个命令可以查看某个范围的commit</li><li>这个命令非常有用当你使用branch做为range参数的时候. 能很方便的显示2个branch之间的不同</li><li>比如：<code>git log master..feature</code>，<code>master..feature</code> 这个range包含了在feature有而在master没有的所有commit，同样，如果是feature..master包含所有master有但是feature没有的commit</li><li>另外，如果是三个点，表示或的意思：<code>git log master...test</code> 查询master或test分支中的提交记录</li></ol></li></ol></li><li>过滤掉 merge commit<ol><li><code>-no-merges</code><ol><li>默认情况下 <code>git log</code> 会输出 merge commit. 你可以通过 <code>--no-merges</code> 标记来过滤掉 merge commit，<code>git log --no-merges</code></li><li>另外，如果你只对 merge commit 感兴趣可以使用 <code>—merges</code>，<code>git log --merges</code></li></ol></li></ol></li><li>按标签tag<ol><li><code>git log v1.0</code><ol><li>直接这样是查询标签之前的commit</li><li>加两个点 <code>git log v1.0..</code> 查询从v1.0以后的提交历史记录(不包含v1.0)</li></ol></li></ol></li><li>按commit<ol><li><code>git log commit</code> ：查询commit之前的记录，包含commit</li><li><code>git log commit1 commit2</code>：查询commit1与commit2之间的记录，包括commit1和commit2</li><li><code>git log commit1..commit2</code>：同上，但是不包括commit1<ol><li>其中，commit可以是提交哈希值的简写模式，也可以使用HEAD代替<ol><li>HEAD代表最后一次提交，HEAD^为最后一个提交的父提交，等同于HEAD～1</li><li>HEAD～2代表倒数第二次提交</li></ol></li></ol></li></ol></li></ol><h2 id="最后干货，你会喜欢的"><a href="#最后干货，你会喜欢的" class="headerlink" title="最后干货，你会喜欢的~"></a>最后干货，你会喜欢的~</h2><p>下面第一条的效果是这样：<br><img src="../../../../image/2020-09-15-git-log/2.png" alt="2.png"></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config --global alias.lm  <span class="hljs-string">&quot;log --no-merges --color --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --author=&#x27;你的名字！自己修改！&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br>git config --global alias.lms  <span class="hljs-string">&quot;log --no-merges --color --stat --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --author=&#x27;你的名字！自己修改！&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br>git config --global [alias.ls](http://alias.ls/) <span class="hljs-string">&quot;log --no-merges --color --graph --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br>git config --global alias.lss <span class="hljs-string">&quot;log --no-merges --color --stat --graph --date=format:&#x27;%Y-%m-%d %H:%M:%S&#x27; --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cnblogs.com/bellkosmos/p/5923439.html">git log命令全解析，打log还能这么随心所欲！</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 的 merge, rebase 和 squash</title>
    <link href="/blog/2020/09/05/merge-rebase-squash/"/>
    <url>/blog/2020/09/05/merge-rebase-squash/</url>
    
    <content type="html"><![CDATA[<p>在团队合作中，毫无疑问，我们需要一个版本管理工具，相对于 SVN 这种在我们看来是老古董的工具，Git 在年轻化的团队中更受欢迎。并不仅仅是跟着大神们（Linux系）的路子在走，所以感觉很牛逼，而是 Git 真的很牛逼，当然，牛逼的同时你需要的学习曲线也是很陡的。<br>这几天我就遇到了一个问题，其实也不是遇到问题，而是遇到了疑惑，那就是我在 github 系统中 <code>merge</code> 同时的 PR 的时候发现有好几个选项，但是，却说不清楚这几个选项分别代表什么含义，所以就稍微花了点时间了解了下，顺带做个总结。<br>在 merge pr 的时候，默认是有三种选项的，分别是</p><ul><li>普通的 merge</li><li>rebase merge</li><li>squash merge</li></ul><p>这其实对应于我们在合并分支的时候的几种方式，所以我就以本地分支的形式来说说有啥区别。</p><p>假设我们一开始的 <code>master</code> 分支上已经有了几个提交，就像这样：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/00.png" alt="00.png"></p><p>然后，我们切出一条开发的分支，进行了一些 Feature 的开发，然后我们的分支可能就是这种情况：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/01.png" alt="01.png"></p><p>这种情况还好，也比较常遇到，但是，现在问题来了，如果在这个时候 <code>master</code> 有了一些新提交（可能是其他分支合并进来的），那么这个时候情形就成了这样：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/02.png" alt="02.png"></p><p>这个情况很有趣，但是我们不讨论，因为这和我们今天的主题无关，以后可以另外开一个话题来说，今天要说的是第二个情况。<br>说到合并分支，可能我们最熟悉的操作是这样的：</p><ol><li>先切换到目标分支（<code>master</code>）</li><li>执行命令： <code>git merge devel</code></li><li>删除旧分支（可以在上面一同做）： <code>git branch -D devel</code></li><li>提交到远程分支： <code>git push origin master</code></li></ol><p>好像这样没啥问题的样子，但是这样操作之后，你知道结果是怎么样吗？假设合并之前的这样的：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/03.png" alt="03.png"></p><p>我们这么一番操作之后，那么最后我们的分支的历史将会是这样的：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/04.png" alt="04.png"></p><p>是的，看上去很不错，也是一条直直的 commit line，我们在 <code>devel</code> 分支中的 commit 也是一个不差得保留在了 <code>master</code> 中。但是，很多时候，我们并不需要那么多的 commit，假设你给一个开源项目提交一个 Bug Fixes，然后一个简单的修改因为你的粗心大意 pr 了十几个 commit 过去，如果作者给你 <code>merge</code> 了，这就在这个项目的历史长河中增加了十几个 commit 啊，以后的人看 commit history 估计都崩溃了吧；同时，对于你自己管理的项目来说，当你 <code>merge</code> 之后发现有问题，想回滚都蛋疼！</p><p>在使用 git 的过程中，可能你遇到过想要合并多个 commit 为一个，然后很多人会告诉你用 <code>git commit --amend</code>，然后你发现里面有你的多个 commit 历史，你可以通过 <code>pick</code> 选择，<code>squash</code> 合并等等。同样得，<code>merge</code> 的时候也可以这么干，你只需要这么简单的两步：</p><ol><li>切换到目标分支： <code>git checkout master</code></li><li>以 squash 的形式 merge： <code>git merge --squash devel</code></li></ol><p>你会发现，在 <code>master</code> 分支上居然有未提交的修改，然后你就需要在 <code>master</code> 上主动提交了修改，注意，这里是你 commit 的，也就是改变了 commit 的 <code>author</code>。结果是这样的：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/05.png" alt="05.png"></p><p>这里好了，比前面普通的 <code>merge</code> 来说，我们只有一个 commit 了，不管在分支中 commit 了多少，这里都只有一个！</p><p>但是，作为处女座的程序员肯定是不能忍受目前的情况的，因为我们既想合并 commits，又想保留作者的信息，那么有没有什么好办法呢？肯定是有的啦，这个时候我们可以尝试一下 <code>rebase</code>，操作步骤是这样的：</p><ol><li>先切换到 <code>devel</code> 分支（不一样咯）： <code>git checkout devel</code></li><li>变基： <code>git rebase -i master</code></li><li>切换回目标分支： <code>git checkout master</code></li><li>合并: <code>git merge devel</code></li></ol><p>这里完成了第二步之后我想你应该大概知道发生了什么事了，我们在 <code>devel</code> 里面对照 <code>master</code> 进行了变基，所谓的变基其实就是找到两个分支共同的祖先，然后在当前分支上合并从共同祖先到现在的所有 commit，所以我们在第二步的时候会选择怎么处理这些 commit，然后我们就得到了一个从公共 commit 到现在的单个 commit，这个时候别人讲我们这个 commit 合并到 <code>master</code> 也只会在 <code>master</code> 上留下一个 commit 记录，就像这样：</p><p><img src="../../../../image/2020-09-05-merge-rebase-squash/06.png" alt="06.png"></p><p>虽然这个 commit history 线看上去很不错，而且也比较符合实际情况，但是我们需要注意到的有点就是分支上的开发者需要自己执行变基操作，从而导致他的原始 commit history 变化了（可以理解成被合并了）。</p><p>相比一下前面三种方式，我们可以总结出一些东西：</p><ol><li><code>rebase</code> 可以尽可能保持 <code>master</code> 分支干净整洁，并且易于识别 <code>author</code></li><li><code>squash</code> 也可以保持 <code>master</code> 分支干净，但是 <code>master</code> 中 <code>author</code> 都是 <code>maintainer</code>，而不是原 <code>owner</code></li><li><code>merge</code> 不能保持 <code>master</code> 分支干净，但是保持了所有的 commit history，大多数情况下都是不好的，个别情况挺好</li></ol><p>参考</p><ol><li><a href="https://liqiang.io/post/difference-between-merge-squash-and-rebase">merge squash 和 merge rebase 区别</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/blog/"/>
    <url>/blog/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/blog/"/>
    <url>/blog/</url>
    
    <content type="html"><![CDATA[code {    color: #e83e8c;}]]></content>
    
  </entry>
  
  
  
</search>
