<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://cyruslin.com/blog/blog/</id><title>Cyrus</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-04-12T18:52:11+08:00</updated> <author> <name>Cyrus</name> <uri>https://cyruslin.com/blog/blog/</uri> </author><link rel="self" type="application/atom+xml" href="https://cyruslin.com/blog/blog/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://cyruslin.com/blog/blog/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 Cyrus </rights> <icon>/blog/assets/img/favicons/favicon.ico</icon> <logo>/blog/assets/img/favicons/favicon-96x96.png</logo> <entry><title>浅析 LeakCanary</title><link href="https://cyruslin.com/blog/blog/posts/leakcanary/" rel="alternate" type="text/html" title="浅析 LeakCanary" /><published>2021-04-12T12:00:00+08:00</published> <updated>2021-04-12T12:00:00+08:00</updated> <id>https://cyruslin.com/blog/blog/posts/leakcanary/</id> <content src="https://cyruslin.com/blog/blog/posts/leakcanary/" /> <author> <name>Cyrus</name> </author> <category term="内存优化" /> <summary> 发现泄漏对象 四种引用类型 强引用 平时写代码最常用的引用类型，对象只要被强引用就不会被 GC 软引用 SoftReference 只有当内存不足时才会被 GC 弱引用 WeakReference 会被正常 GC 虚引用 PhantomReference 会被正常 GC，因为 get() 总是返回 null，一般用来跟踪对象的生命周期 所有的引用类型都可以在构造时与一个 ReferenceQueue 关联，当引用的对象被 GC 后，这个 Reference 将被入队到关联的引用队列里 public abstract class Reference&amp;lt;T&amp;gt; { /* --... </summary> </entry> <entry><title>HashMap 的一些知识点</title><link href="https://cyruslin.com/blog/blog/posts/hashmap/" rel="alternate" type="text/html" title="HashMap 的一些知识点" /><published>2021-04-05T12:00:00+08:00</published> <updated>2021-04-05T12:00:00+08:00</updated> <id>https://cyruslin.com/blog/blog/posts/hashmap/</id> <content src="https://cyruslin.com/blog/blog/posts/hashmap/" /> <author> <name>Cyrus</name> </author> <category term="JDK" /> <category term="Collection" /> <summary> HashMap 的桶由链表变为红黑树（树化）的过程 红黑树的特性 节点为红色或者黑色 根节点必须是黑的 红色节点的左右子节点必须为黑色 一个节点到叶子节点的每条路径必须包含相同数目的黑色节点 颜色变换和两种选择 添加新节点后，因为新节点总是红色的，那么会有几种情况出现： 新节点是根节点，也就是说树是空的，根据规则二，把新节点设为黑色即可 新节点的父节点是黑色，或者父节点是根，满足规则 父节点是红色，违反规则三，需要进行 平衡 操作 平衡操作主要是根据情况组合使用下面三种转换（方块表示一棵满足红黑树规则的子树）： 几个问题 为什么要进行旋转？ 由于 P（父节点 和 X（新节点）都为红色，违反规则三 为什么新节点总是红色？ 因为添加新节点前的树结构是构建好的，一但我们添加黑色节点，无论添加在哪里都会破坏原有路径上的黑色... </summary> </entry> <entry><title>JUC 下一些线程安全的容器</title><link href="https://cyruslin.com/blog/blog/posts/juc-collection/" rel="alternate" type="text/html" title="JUC 下一些线程安全的容器" /><published>2021-03-31T12:00:00+08:00</published> <updated>2021-04-05T18:12:01+08:00</updated> <id>https://cyruslin.com/blog/blog/posts/juc-collection/</id> <content src="https://cyruslin.com/blog/blog/posts/juc-collection/" /> <author> <name>Cyrus</name> </author> <category term="JDK" /> <category term="JUC" /> <summary> 写时复制（Copy On Write） CopyOnWriteArrayList 使用 写时复制 实现的线程安全版 ArrayList，当发生修改操作时（add、set、remove）才加锁，将原数组复制一份并在上面修改成为新数组，最后用新数组替换原数组 public boolean add(E e) { synchronized (lock) { Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); retur... </summary> </entry> <entry><title>什么是 https ？</title><link href="https://cyruslin.com/blog/blog/posts/https/" rel="alternate" type="text/html" title="什么是 https ？" /><published>2021-03-30T12:00:00+08:00</published> <updated>2021-03-31T13:45:14+08:00</updated> <id>https://cyruslin.com/blog/blog/posts/https/</id> <content src="https://cyruslin.com/blog/blog/posts/https/" /> <author> <name>Cyrus</name> </author> <category term="网络" /> <summary> https = http + tls tcp 三次握手建立连接后，再进行 tls 握手/协商得到一个秘钥，然后双方使用这个秘钥加密（对称加密）明文的 http 为密文后再发送，同样双方收到密文后也用这个秘钥解密得到明文 对称加密 使用同一秘钥加密和解密，性能高，http 明文就是通过对称加密后才进行传输的，对称加密算法有：DES、3DES、AES 等；但秘钥交换是个问题，所以需要非对称加密的帮助 非对称加密 公钥加密则私钥解密，私钥加密则公钥解密，性能比对称加密要差，不适合加解密大量的数据，但很适合于解决秘钥交换的问题，常用的有：RSA、DSA 等 tls 协商的过程 Client Hello 客户端发送：客户端随机数（client random）和客户端支持的 加密套件列表 Server Hello 服务端从客户端支持的加密套件中选择一个，然后发送：服务端随机数（s... </summary> </entry> <entry><title>TCP 的三次握手和四次挥手</title><link href="https://cyruslin.com/blog/blog/posts/tcp-handshake-goodbye/" rel="alternate" type="text/html" title="TCP 的三次握手和四次挥手" /><published>2021-03-13T12:00:00+08:00</published> <updated>2021-03-30T17:35:09+08:00</updated> <id>https://cyruslin.com/blog/blog/posts/tcp-handshake-goodbye/</id> <content src="https://cyruslin.com/blog/blog/posts/tcp-handshake-goodbye/" /> <author> <name>Cyrus</name> </author> <category term="网络" /> <summary> 序号和确认号 从 TCP 连接建立的开始，到 TCP 连接的断开，你要传输的所有数据的每一个字节都要编号，这个序号称为 字节序号 如果一个 TCP 报文的 报文序号 为 301，它携带了 100 字节的数据，就表示这 100 个字节的数据的字节序号范围是 [301, 400]，该报文携带的第一个字节序号是 301，最后一个字节序号是 400 每传送一个 TCP 报文都要等待对方回复一个确认，但这种方式效率太低，在 TCP 协议中，一般采用累积确认的方式，即每次传送多个连续 TCP 报文，可以只对最后一个 TCP 报文进行确认。对方通过回复一个 确认号 来表示已经接收到了哪个 TCP 报文。比如发送方发送了一个序号为 301 的 TCP 报文，这个报文携带了 100 字节数据，则接收方应当回复的确认号是 401，它表示接收方已经收到了字节序号为 [300, 400]... </summary> </entry> </feed>
