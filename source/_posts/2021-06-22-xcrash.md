---
title: 崩溃日志收集库 xCrash 浅析
date: 2021-06-22 12:00:00 +0800
categories: [Library]
tags: [uncaught exception, exception, 崩溃, 崩溃日志, crash, xcrash]
---

[xCrash](https://github.com/iqiyi/xCrash) 是爱奇艺团队开源的一款崩溃日志收集库，可以收集 **java crash**、**native crash** 和 **ANR** 日志

日志格式为专用格式，内容还算丰富：**机器信息**、**崩溃线程和其他线程的方法栈**、**logcat**、**打开的 fd** 等等 ...


## Java Crash

捕获 Java Crash 用的是 `DefaultUncaughtExceptionHandler`，相关的基础知识参考 [Uncaught Exception Handling](../../../../2021/06/18/uncaught-exception-handler/)

```java
class JavaCrashHandler implements UncaughtExceptionHandler {

    @Override
    public void uncaughtException(Thread thread, Throwable throwable) {
        if (defaultHandler != null) {
            Thread.setDefaultUncaughtExceptionHandler(defaultHandler);
        }

        try {
            handleException(thread, throwable);
        } catch (Exception e) {
            XCrash.getLogger().e(Util.TAG, "JavaCrashHandler handleException failed", e);
        }

        // 可以选择重新抛出给上一个 handler，或者杀死 app
        if (this.rethrow) {
            if (defaultHandler != null) {
                defaultHandler.uncaughtException(thread, throwable);
            }
        } else {
            ActivityMonitor.getInstance().finishAllActivities();
            Process.killProcess(this.pid);
            System.exit(10);
        }
    }

    // 收集各种各样的信息，写入到日志文件
    private void handleException(Thread thread, Throwable throwable) {
        Date crashTime = new Date();

        //notify the java crash
        NativeHandler.getInstance().notifyJavaCrashed();
        AnrHandler.getInstance().notifyJavaCrashed();

        //create log file
        File logFile = null;
        try {
            String logPath = String.format(Locale.US, "%s/%s_%020d_%s__%s%s", logDir, Util.logPrefix, startTime.getTime() * 1000, appVersion, processName, Util.javaLogSuffix);
            logFile = FileManager.getInstance().createLogFile(logPath);
        } catch (Exception e) {
            XCrash.getLogger().e(Util.TAG, "JavaCrashHandler createLogFile failed", e);
        }

        //get emergency
        String emergency = null;
        try {
            emergency = getEmergency(crashTime, thread, throwable);
        } catch (Exception e) {
            XCrash.getLogger().e(Util.TAG, "JavaCrashHandler getEmergency failed", e);
        }

        //write info to log file
        if (logFile != null) {
            RandomAccessFile raf = null;
            try {
                raf = new RandomAccessFile(logFile, "rws");

                //write emergency info
                if (emergency != null) {
                    raf.write(emergency.getBytes("UTF-8"));
                }

                //If we wrote the emergency info successfully, we don't need to return it from callback again.
                emergency = null;

                //write logcat
                if (logcatMainLines > 0 || logcatSystemLines > 0 || logcatEventsLines > 0) {
                    raf.write(Util.getLogcat(logcatMainLines, logcatSystemLines, logcatEventsLines).getBytes("UTF-8"));
                }

                //write fds
                if (dumpFds) {
                    raf.write(Util.getFds().getBytes("UTF-8"));
                }

                //write network info
                if (dumpNetworkInfo) {
                    raf.write(Util.getNetworkInfo().getBytes("UTF-8"));
                }

                //write memory info
                raf.write(Util.getMemoryInfo().getBytes("UTF-8"));

                //write background / foreground
                raf.write(("foreground:\n" + (ActivityMonitor.getInstance().isApplicationForeground() ? "yes" : "no") + "\n\n").getBytes("UTF-8"));

                //write other threads info
                if (dumpAllThreads) {
                    raf.write(getOtherThreadsInfo(thread).getBytes("UTF-8"));
                }
            } catch (Exception e) {
                XCrash.getLogger().e(Util.TAG, "JavaCrashHandler write log file failed", e);
            } finally {
                if (raf != null) {
                    try {
                        raf.close();
                    } catch (Exception ignored) {
                    }
                }
            }
        }

        //callback
        if (callback != null) {
            try {
                callback.onCrash(logFile == null ? null : logFile.getAbsolutePath(), emergency);
            } catch (Exception ignored) {
            }
        }
    }        
}
```

### Header

```java
private String getEmergency(Date crashTime, Thread thread, Throwable throwable) {
    //stack stace
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    throwable.printStackTrace(pw);
    String stacktrace = sw.toString();
    return Util.getLogHeader(startTime, crashTime, Util.javaCrashType, appId, appVersion)
            + "pid: " + pid + ", tid: " + Process.myTid() + ", name: " + thread.getName() + "  >>> " + processName + " <<<\n"
            + "\n"
            + "java stacktrace:\n"
            + stacktrace
            + "\n"
            + getBuildId(stacktrace);
}

static String getLogHeader(Date startTime, Date crashTime, String crashType, String appId, String appVersion) {
    DateFormat timeFormatter = new SimpleDateFormat(Util.timeFormatterStr, Locale.US);
    return Util.sepHead + "\n"
        + "Tombstone maker: '" + Version.fullVersion + "'\n"
        + "Crash type: '" + crashType + "'\n"
        + "Start time: '" + timeFormatter.format(startTime) + "'\n"
        + "Crash time: '" + timeFormatter.format(crashTime) + "'\n"
        + "App ID: '" + appId + "'\n"
        + "App version: '" + appVersion + "'\n"
        + "Rooted: '" + (Util.isRoot() ? "Yes" : "No") + "'\n"
        + "API level: '" + Build.VERSION.SDK_INT + "'\n"
        + "OS version: '" + Build.VERSION.RELEASE + "'\n"
        + "ABI list: '" + Util.getAbiList() + "'\n"
        + "Manufacturer: '" + Build.MANUFACTURER + "'\n"
        + "Brand: '" + Build.BRAND + "'\n"
        + "Model: '" + Util.getMobileModel() + "'\n"
        + "Build fingerprint: '" + Build.FINGERPRINT + "'\n";
}

private String getBuildId(String stktrace) {
    String buildId = "";
    List<String> libPathList = new ArrayList<String>();
    if (stktrace.contains("UnsatisfiedLinkError")) {
        String libInfo = null;
        String[] tempLibPathStr;
        tempLibPathStr = stktrace.split("\""); // " is the delimiter
        for (String libPathStr :  tempLibPathStr) {
            if (libPathStr.isEmpty() || !libPathStr.endsWith(".so")) continue;
            libPathList.add(libPathStr);
            String libName = libPathStr.substring(libPathStr.lastIndexOf('/') + 1);
            libPathList.add(XCrash.nativeLibDir + "/" + libName);
            libPathList.add("/vendor/lib/" + libName);
            libPathList.add("/vendor/lib64/" + libName);
            libPathList.add("/system/lib/" + libName);
            libPathList.add("/system/lib64/" + libName);
            libInfo = getLibInfo(libPathList);
        }
        buildId = "build id:"
                + "\n"
                + libInfo
                + "\n";
    }
    return buildId;
}        
```

输出的日志内容如下：

```text
*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
Tombstone maker: 'xCrash 2.4.6'                                                                    // xCrash 把日志叫做 tombstone，这里指的是生成 tombstone 的 xCrash 的版本
Crash type: 'java'                                                                                 // 指明 crash 类型，此日志包含的是 java crash（此外还有 native crash 和 ANR）
Start time: '2019-10-12T03:23:19.580+0800'                                                         // 初始化 xCrash 的时间，也就是调用 XCrash.init 的时间
Crash time: '2019-10-12T03:23:25.533+0800'                                                         // 发生崩溃的时间
App ID: 'xcrash.sample'                                                                            // 发生崩溃的 APP 的包名
App version: '1.2.3-beta456-patch789'                                                              // APP version name
Rooted: 'No'                                                                                       
API level: '29'
OS version: '10'
ABI list: 'arm64-v8a,armeabi-v7a,armeabi'
Manufacturer: 'Google'
Brand: 'google'
Model: 'Pixel'
Build fingerprint: 'google/sailfish/sailfish:10/QP1A.190711.020/5800535:user/release-keys'
pid: 21356, tid: 21356, name: main  >>> xcrash.sample <<<

java stacktrace:                                                                                    // 崩溃线程的调用栈
java.lang.IllegalStateException: Could not execute method for android:onClick
	at androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:402)
	at android.view.View.performClick(View.java:7140)
	at android.view.View.performClickInternal(View.java:7117)
	at android.view.View.access$3500(View.java:801)
	at android.view.View$PerformClick.run(View.java:27351)
	at android.os.Handler.handleCallback(Handler.java:883)
	at android.os.Handler.dispatchMessage(Handler.java:100)
	at android.os.Looper.loop(Looper.java:214)
	at android.app.ActivityThread.main(ActivityThread.java:7356)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)
Caused by: java.lang.reflect.InvocationTargetException
	at java.lang.reflect.Method.invoke(Native Method)
	at androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397)
	... 11 more
Caused by: java.lang.RuntimeException: test java exception
	at xcrash.XCrash.testJavaCrash(XCrash.java:847)
	at xcrash.sample.MainActivity.testJavaCrashInMainThread_onClick(MainActivity.java:67)
	... 13 more
```

### logcat

其实就是调用 `logcat` 命令获取崩溃时的 `main`、`system` 和 `events` 三个 buffer 的日志，如：`/system/bin/logcat -b main -d -v threadtime -t 200 --pid 21356 *:D`

```java
static String getLogcat(int logcatMainLines, int logcatSystemLines, int logcatEventsLines) {
    int pid = android.os.Process.myPid();
    StringBuilder sb = new StringBuilder();
    sb.append("logcat:\n");
    if (logcatMainLines > 0) {
        getLogcatByBufferName(pid, sb, "main", logcatMainLines, 'D');
    }
    if (logcatSystemLines > 0) {
        getLogcatByBufferName(pid, sb, "system", logcatSystemLines, 'W');
    }
    if (logcatEventsLines > 0) {
        getLogcatByBufferName(pid, sb, "events", logcatSystemLines, 'I');
    }
    sb.append("\n");
    return sb.toString();
}

private static void getLogcatByBufferName(int pid, StringBuilder sb, String bufferName, int lines, char priority) {
    boolean withPid = (android.os.Build.VERSION.SDK_INT >= 24);
    String pidString = Integer.toString(pid);
    String pidLabel = " " + pidString + " ";
    //command for ProcessBuilder
    List<String> command = new ArrayList<String>();
    command.add("/system/bin/logcat");
    command.add("-b");
    command.add(bufferName);
    command.add("-d");
    command.add("-v");
    command.add("threadtime");
    command.add("-t");
    command.add(Integer.toString(withPid ? lines : (int) (lines * 1.2)));
    if (withPid) {
        command.add("--pid");
        command.add(pidString);
    }
    command.add("*:" + priority);
    //append the command line
    Object[] commandArray = command.toArray();
    sb.append("--------- tail end of log ").append(bufferName);
    sb.append(" (").append(android.text.TextUtils.join(" ", commandArray)).append(")\n");
    //append logs
    BufferedReader br = null;
    String line;
    try {
        Process process = new ProcessBuilder().command(command).start();
        br = new BufferedReader(new InputStreamReader(process.getInputStream()));
        while ((line = br.readLine()) != null) {
            if (withPid || line.contains(pidLabel)) {
                sb.append(line).append("\n");
            }
        }
    } catch (Exception e) {
        XCrash.getLogger().w(Util.TAG, "Util run logcat command failed", e);
    } finally {
        if (br != null) {
            try {
                br.close();
            } catch (IOException ignored) {
            }
        }
    }
}    
```

输出如下：

```text
logcat:
--------- tail end of log main (/system/bin/logcat -b main -d -v threadtime -t 200 --pid 21356 *:D)
10-12 03:23:19.356 21356 21356 I xcrash.sample: Late-enabling -Xcheck:jni
10-12 03:23:19.398 21356 21356 E xcrash.sample: Unknown bits set in runtime_flags: 0x8000
10-12 03:23:19.571 21356 21356 D xcrash_sample: xCrash SDK init: start
10-12 03:23:19.586 21356 21356 D xcrash_sample: xCrash SDK init: end
10-12 03:23:19.757 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/View;->computeFitSystemWindows(Landroid/graphics/Rect;Landroid/graphics/Rect;)Z (greylist, reflection, allowed)
10-12 03:23:19.758 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/ViewGroup;->makeOptionalFitsSystemWindows()V (greylist, reflection, allowed)
10-12 03:23:19.829 21356 21356 I WebViewFactory: Loading com.google.android.webview version 77.0.3865.92 (code 386509238)
10-12 03:23:19.874 21356 21356 I cr_LibraryLoader: Time to load native libraries: 4 ms (timestamps 1922-1926)
10-12 03:23:19.920 21356 21356 I chromium: [INFO:library_loader_hooks.cc(51)] Chromium logging enabled: level = 0, default verbosity = 0
10-12 03:23:19.921 21356 21356 I cr_LibraryLoader: Expected native library version number "77.0.3865.92", actual native library version number "77.0.3865.92"
10-12 03:23:19.926 21356 21402 W cr_ChildProcLH: Create a new ChildConnectionAllocator with package name = com.google.android.webview, sandboxed = true
10-12 03:23:19.930 21356 21402 W xcrash.sample: Accessing hidden method Landroid/content/Context;->bindServiceAsUser(Landroid/content/Intent;Landroid/content/ServiceConnection;ILandroid/os/Handler;Landroid/os/UserHandle;)Z (greylist, reflection, allowed)
10-12 03:23:19.934 21356 21356 I cr_BrowserStartup: Initializing chromium process, singleProcess=false
10-12 03:23:19.979 21356 21430 W chromium: [WARNING:dns_config_service_posix.cc(339)] Failed to read DnsConfig.
10-12 03:23:20.031 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker;-><init>(Landroid/content/Context;I)V (greylist, reflection, allowed)
10-12 03:23:20.031 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker;->logEvent(Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;)V (greylist, reflection, allowed)
10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;->selectionStarted(I)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)
10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;->selectionModified(II)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)
10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;->selectionModified(IILandroid/view/textclassifier/TextClassification;)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)
10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;->selectionModified(IILandroid/view/textclassifier/TextSelection;)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)
10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;->selectionAction(III)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)
10-12 03:23:20.032 21356 21356 W xcrash.sample: Accessing hidden method Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent;->selectionAction(IIILandroid/view/textclassifier/TextClassification;)Landroid/view/textclassifier/logging/SmartSelectionEventTracker$SelectionEvent; (greylist, reflection, allowed)
10-12 03:23:20.143 21356 21395 I Adreno  : QUALCOMM build                   : 4a00b69, I4e7e888065
10-12 03:23:20.143 21356 21395 I Adreno  : Build Date                       : 04/09/19
10-12 03:23:20.143 21356 21395 I Adreno  : OpenGL ES Shader Compiler Version: EV031.26.06.00
10-12 03:23:20.143 21356 21395 I Adreno  : Local Branch                     : mybranche95ae4c8-d77f-f18d-a9ef-1458d0b52ae8
10-12 03:23:20.143 21356 21395 I Adreno  : Remote Branch                    : quic/gfx-adreno.lnx.1.0
10-12 03:23:20.143 21356 21395 I Adreno  : Remote Branch                    : NONE
10-12 03:23:20.143 21356 21395 I Adreno  : Reconstruct Branch               : NOTHING
10-12 03:23:20.143 21356 21395 I Adreno  : Build Config                     : S L 8.0.5 AArch64
10-12 03:23:20.146 21356 21395 I Adreno  : PFP: 0x005ff110, ME: 0x005ff066
10-12 03:23:20.198 21356 21395 W Gralloc3: mapper 3.x is not supported
10-12 03:23:25.531 21356 21356 D AndroidRuntime: Shutting down VM
--------- tail end of log system (/system/bin/logcat -b system -d -v threadtime -t 50 --pid 21356 *:W)
--------- tail end of log events (/system/bin/logcat -b events -d -v threadtime -t 50 --pid 21356 *:I)
10-12 03:23:20.046 21356 21356 I am_on_create_called: [0,xcrash.sample.MainActivity,performCreate]
10-12 03:23:20.053 21356 21356 I am_on_start_called: [0,xcrash.sample.MainActivity,handleStartActivity]
10-12 03:23:20.056 21356 21356 I am_on_resume_called: [0,xcrash.sample.MainActivity,RESUME_ACTIVITY]
10-12 03:23:20.083 21356 21356 I am_on_top_resumed_gained_called: [0,xcrash.sample.MainActivity,topStateChangedWhenResumed]
```

### Opened FD

打印已打开的 FD 及其路径，已打开的 FD 在目录 `/proc/self/fd` 下

```java
static String getFds() {
    StringBuilder sb = new StringBuilder("open files:\n");
    try {
        File dir = new File("/proc/self/fd");
        File[] fds = dir.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return TextUtils.isDigitsOnly(name);
            }
        });
        int count = 0;
        if (fds != null) {
            for (File fd : fds) {
                String path = null;
                try {
                    if (Build.VERSION.SDK_INT >= 21) {
                        path = Os.readlink(fd.getAbsolutePath());
                    } else {
                        path = fd.getCanonicalPath();
                    }
                } catch (Exception ignored) {
                }
                sb.append("    fd ").append(fd.getName()).append(": ")
                    .append(TextUtils.isEmpty(path) ? "???" : path.trim()).append('\n');
                count++;
                if (count > 1024) {
                    break;
                }
            }
            if (fds.length > 1024) {
                sb.append("    ......\n");
            }
            sb.append("    (number of FDs: ").append(fds.length).append(")\n");
        }
    } catch (Exception ignored) {
    }
    sb.append('\n');
    return sb.toString();
}
```

输出如下：

```text
open files:
    fd 0: /dev/null
    fd 1: /dev/null
    fd 2: /dev/null
    fd 3: /proc/21356/fd/3
    fd 4: /proc/21356/fd/4
    fd 5: /proc/21356/fd/5
    fd 6: /dev/null
    fd 7: /dev/null
    fd 8: /dev/null
    fd 9: /apex/com.android.runtime/javalib/core-oj.jar
    fd 10: /apex/com.android.runtime/javalib/core-libart.jar
    fd 11: /apex/com.android.runtime/javalib/okhttp.jar
    fd 12: /apex/com.android.runtime/javalib/bouncycastle.jar
    fd 13: /apex/com.android.runtime/javalib/apache-xml.jar
    fd 14: /system/framework/framework.jar
    fd 15: /system/framework/ext.jar
    fd 16: /system/framework/telephony-common.jar
    fd 17: /system/framework/voip-common.jar
    fd 18: /system/framework/ims-common.jar
    fd 19: /dev/null
    fd 20: /dev/null
    fd 21: /system/framework/android.test.base.jar
    fd 22: /apex/com.android.conscrypt/javalib/conscrypt.jar
    fd 23: /apex/com.android.media/javalib/updatable-media.jar
    fd 24: /system/framework/framework-res.apk
    fd 25: /system/product/overlay/GoogleConfigOverlay.apk
    fd 26: /system/product/overlay/GoogleWebViewOverlay.apk
    fd 27: /vendor/overlay/framework-res__auto_generated_rro_vendor.apk
    fd 28: /system/product/overlay/PixelConfigOverlayCommon.apk
    fd 29: /system/product/overlay/framework-res__auto_generated_rro_product.apk
    fd 30: /dev/null
    fd 31: /dev/binder
    fd 32: /proc/21356/fd/32
    fd 33: /proc/21356/fd/33
    fd 34: /proc/21356/fd/34
    fd 35: /proc/21356/fd/35
    fd 36: /proc/21356/fd/36
    fd 37: /data/app/xcrash.sample-WeCpVYjROKKgYtuzbHflHg==/base.apk
    fd 38: /proc/21356/fd/38
    fd 39: /proc/21356/fd/39
    fd 40: /system/product/overlay/NavigationBarModeGestural/NavigationBarModeGesturalOverlay.apk
    fd 41: /dev/null
    fd 42: /dev/null
    fd 43: /dev/null
    fd 44: /dev/null
    fd 45: /proc/21356/fd/45
    fd 46: /proc/21356/fd/46
    fd 47: /proc/21356/fd/47
    fd 48: /proc/21356/fd/48
    fd 49: /dev/ashmem
    fd 50: /proc/21356/fd/50
    fd 51: /proc/21356/fd/51
    fd 52: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk
    fd 53: /proc/21356/fd/53
    fd 54: /data/data/xcrash.sample/files/tombstones/tombstone_00001570821799580000_1.2.3-beta456-patch789__xcrash.sample.java.xcrash
    fd 55: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk
    fd 56: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk
    fd 57: /data/data/xcrash.sample/app_webview/webview_data.lock
    fd 58: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk
    fd 59: /system/product/overlay/NavigationBarModeGestural/NavigationBarModeGesturalOverlay.apk
    fd 60: /proc/21356/fd/60
    fd 61: /proc/21356/fd/61
    fd 62: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk
    fd 63: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk
    fd 64: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk
    fd 65: /data/app/com.google.android.trichromelibrary_386509238-C5vGqz1rgNqceBgeyyw2Aw==/base.apk
    fd 66: /dev/urandom
    fd 67: /proc/21356/fd/67
    fd 68: /proc/21356/fd/68
    fd 69: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk
    fd 70: /proc/21356/fd/70
    fd 71: /proc/21356/fd/71
    fd 72: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk
    fd 73: /data/app/com.google.android.webview-wtyVrSKc9Gzy-ujvyvTNjw==/base.apk
    fd 74: /proc/21356/fd/74
    fd 75: /proc/21356/fd/75
    fd 76: /proc/21356/fd/76
    fd 77: /proc/21356/fd/77
    fd 78: /proc/21356/fd/78
    fd 79: /proc/21356/fd/79
    fd 80: /proc/21356/fd/80
    fd 81: /proc/21356/fd/81
    fd 82: /proc/21356/fd/82
    fd 83: /proc/21356/fd/83
    fd 84: /proc/21356/fd/84
    fd 85: /proc/21356/fd/85
    fd 86: /proc/21356/fd/86
    fd 87: /proc/21356/fd/87
    fd 88: /proc/21356/fd/88
    fd 89: /proc/21356/fd/89
    fd 90: /proc/21356/fd/90
    fd 91: /dev/ashmem
    fd 92: /dev/ashmem
    fd 93: /dev/ashmem
    fd 94: /data/data/xcrash.sample/app_webview/Web Data
    fd 95: /proc/21356/fd/95
    fd 96: /proc/21356/fd/96
    fd 97: /dev/ashmem
    fd 98: /dev/ion
    fd 99: /proc/21356/fd/99
    fd 100: /proc/21356/fd/100
    fd 101: /proc/21356/fd/101
    fd 102: /dev/ashmem
    fd 103: /dev/kgsl-3d0
    fd 104: /dev/ion
    fd 105: /dev/hwbinder
    fd 106: /proc/21356/fd/106
    fd 107: /proc/21356/fd/107
    fd 110: /proc/21356/fd/110
    fd 111: /proc/21356/fd/111
    fd 113: /proc/21356/fd/113
    fd 114: /proc/21356/fd/114
    fd 115: /proc/21356/fd/115
    fd 116: /proc/21356/fd/116
    fd 117: /proc/21356/fd/117
    (number of FDs: 115)
```

### System Memory Summary

```text
System Summary (From: /proc/meminfo)
 MemTotal:        3855796 kB
 MemFree:           90124 kB
 MemAvailable:    1452636 kB
 Buffers:           77420 kB
 Cached:          1461900 kB
 SwapCached:        10232 kB
 Active:          1771504 kB
 Inactive:        1014432 kB
 Active(anon):    1046604 kB
 Inactive(anon):   368348 kB
 Active(file):     724900 kB
 Inactive(file):   646084 kB
 Unevictable:      151672 kB
 Mlocked:          151672 kB
 SwapTotal:        524284 kB
 SwapFree:         271320 kB
 Dirty:               136 kB
 Writeback:             0 kB
 AnonPages:       1391280 kB
 Mapped:           620988 kB
 Shmem:             16660 kB
 Slab:             231556 kB
 SReclaimable:      92700 kB
 SUnreclaim:       138856 kB
 KernelStack:       44448 kB
 PageTables:        57544 kB
 NFS_Unstable:          0 kB
 Bounce:                0 kB
 WritebackTmp:          0 kB
 CommitLimit:     2452180 kB
 Committed_AS:   67847232 kB
 VmallocTotal:   258998208 kB
 VmallocUsed:      223632 kB
 VmallocChunk:   258675172 kB
```

### APP Process Summary

```text
 Process Status (From: /proc/PID/status)
  Name:	xcrash.sample
  State:	R (running)
  Tgid:	21356
  Pid:	21356
  PPid:	626
  TracerPid:	0
  Uid:	10180	10180	10180	10180
  Gid:	10180	10180	10180	10180
  Ngid:	0
  FDSize:	128
  Groups:	9997 20180 50180
  VmPeak:	 5659228 kB
  VmSize:	 5542192 kB
  VmLck:	       0 kB
  VmPin:	       0 kB
  VmHWM:	   94624 kB
  VmRSS:	   94396 kB
  VmData:	 5051840 kB
  VmStk:	    8192 kB
  VmExe:	      28 kB
  VmLib:	  166580 kB
  VmPTE:	    1068 kB
  VmSwap:	    6476 kB
  Threads:	37
  SigQ:	0/13891
  SigPnd:	0000000000000000
  ShdPnd:	0000000000000000
  SigBlk:	0000000080001200
  SigIgn:	0000000000000001
  SigCgt:	0000000e400084fc
  CapInh:	0000000000000000
  CapPrm:	0000000000000000
  CapEff:	0000000000000000
  CapBnd:	0000000000000000
  CapAmb:	0000000000000000
  Seccomp:	2
  Cpus_allowed:	f
  Cpus_allowed_list:	0-3
  Mems_allowed:	1
  Mems_allowed_list:	0
  voluntary_ctxt_switches:	343
  nonvoluntary_ctxt_switches:	301
```

### APP Process Limits

```text
 Process Limits (From: /proc/PID/limits)
  Limit                     Soft Limit           Hard Limit           Units
  Max cpu time              unlimited            unlimited            seconds
  Max file size             unlimited            unlimited            bytes
  Max data size             unlimited            unlimited            bytes
  Max stack size            8388608              unlimited            bytes
  Max core file size        0                    unlimited            bytes
  Max resident set          unlimited            unlimited            bytes
  Max processes             13891                13891                processes
  Max open files            32768                32768                files
  Max locked memory         65536                65536                bytes
  Max address space         unlimited            unlimited            bytes
  Max file locks            unlimited            unlimited            locks
  Max pending signals       13891                13891                signals
  Max msgqueue size         819200               819200               bytes
  Max nice priority         40                   40
  Max realtime priority     0                    0
  Max realtime timeout      unlimited            unlimited            us
```

### APP Memory Summary

```text
Process Summary (From: android.os.Debug.MemoryInfo)
                       Pss(KB)
                        ------
           Java Heap:     7632
         Native Heap:    10932
                Code:    19064
               Stack:       56
            Graphics:     1104
       Private Other:     3448
              System:     4414
               TOTAL:    46650           TOTAL SWAP:     6460

```

### Other StackTraces

```java
private String getOtherThreadsInfo(Thread crashedThread) {

    // 其他线程可能有很多，所以有“白名单”机制
    int thdMatchedRegex = 0;
    int thdIgnoredByLimit = 0;
    int thdDumped = 0;
    //build whitelist regex list
    ArrayList<Pattern> whiteList = null;
    if (dumpAllThreadsWhiteList != null) {
        whiteList = new ArrayList<Pattern>();
        for (String s : dumpAllThreadsWhiteList) {
            try {
                whiteList.add(Pattern.compile(s));
            } catch (Exception e) {
                XCrash.getLogger().w(Util.TAG, "JavaCrashHandler pattern compile failed", e);
            }
        }
    }

    // dump trace
    StringBuilder sb = new StringBuilder();
    Map<Thread, StackTraceElement[]> map = Thread.getAllStackTraces();
    for (Map.Entry<Thread, StackTraceElement[]> entry : map.entrySet()) {
        Thread thd = entry.getKey();
        StackTraceElement[] stacktrace = entry.getValue();
        //skip the crashed thread
        if (thd.getName().equals(crashedThread.getName())) continue;
        //check regex for thread name
        if (whiteList != null && !matchThreadName(whiteList, thd.getName())) continue;
        thdMatchedRegex++;
        //check dump count limit
        if (dumpAllThreadsCountMax > 0 && thdDumped >= dumpAllThreadsCountMax) {
            thdIgnoredByLimit++;
            continue;
        }
        sb.append(Util.sepOtherThreads + "\n");
        sb.append("pid: ").append(pid).append(", tid: ").append(thd.getId()).append(", name: ").append(thd.getName()).append("  >>> ").append(processName).append(" <<<\n");
        sb.append("\n");
        sb.append("java stacktrace:\n");
        for (StackTraceElement element : stacktrace) {
            sb.append("    at ").append(element.toString()).append("\n");
        }
        sb.append("\n");
        thdDumped++;
    }

    // 统计
    if (map.size() > 1) {
        if (thdDumped == 0) {
            sb.append(Util.sepOtherThreads + "\n");
        }
        sb.append("total JVM threads (exclude the crashed thread): ").append(map.size() - 1).append("\n");
        if (whiteList != null) {
            sb.append("JVM threads matched whitelist: ").append(thdMatchedRegex).append("\n");
        }
        if (dumpAllThreadsCountMax > 0) {
            sb.append("JVM threads ignored by max count limit: ").append(thdIgnoredByLimit).append("\n");
        }
        sb.append("dumped JVM threads:").append(thdDumped).append("\n");
        sb.append(Util.sepOtherThreadsEnding + "\n");
    }
    return sb.toString();
}
```

输出如下：

```text
--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4364, name: RenderThread  >>> xcrash.sample <<<

java stacktrace:

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4349, name: Jit thread pool worker thread 0  >>> xcrash.sample <<<

java stacktrace:

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4357, name: Binder:21356_2  >>> xcrash.sample <<<

java stacktrace:

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4374, name: NetworkService  >>> xcrash.sample <<<

java stacktrace:

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4353, name: ReferenceQueueDaemon  >>> xcrash.sample <<<

java stacktrace:
    at java.lang.Object.wait(Native Method)
    at java.lang.Object.wait(Object.java:442)
    at java.lang.Object.wait(Object.java:568)
    at java.lang.Daemons$ReferenceQueueDaemon.runInternal(Daemons.java:215)
    at java.lang.Daemons$Daemon.run(Daemons.java:137)
    at java.lang.Thread.run(Thread.java:919)

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4359, name: Profile Saver  >>> xcrash.sample <<<

java stacktrace:

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4371, name: GoogleApiHandler  >>> xcrash.sample <<<

java stacktrace:
    at android.os.MessageQueue.nativePollOnce(Native Method)
    at android.os.MessageQueue.next(MessageQueue.java:336)
    at android.os.Looper.loop(Looper.java:174)
    at android.os.HandlerThread.run(HandlerThread.java:67)

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4362, name: xcrash_trace_dp  >>> xcrash.sample <<<

java stacktrace:

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4361, name: xcrash_crash_cb  >>> xcrash.sample <<<

java stacktrace:

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4352, name: HeapTaskDaemon  >>> xcrash.sample <<<

java stacktrace:

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4354, name: FinalizerDaemon  >>> xcrash.sample <<<

java stacktrace:
    at java.lang.Object.wait(Native Method)
    at java.lang.Object.wait(Object.java:442)
    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:190)
    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:211)
    at java.lang.Daemons$FinalizerDaemon.runInternal(Daemons.java:271)
    at java.lang.Daemons$Daemon.run(Daemons.java:137)
    at java.lang.Thread.run(Thread.java:919)

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4372, name: Chrome_IOThread  >>> xcrash.sample <<<

java stacktrace:

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4370, name: CrAsyncTask #2  >>> xcrash.sample <<<

java stacktrace:
    at sun.misc.Unsafe.park(Native Method)
    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:230)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2109)
    at java.util.concurrent.ArrayBlockingQueue.poll(ArrayBlockingQueue.java:402)
    at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1091)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1152)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
    at Js.run(PG:2)
    at java.lang.Thread.run(Thread.java:919)

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4375, name: PlatformServiceBridgeHandlerThread  >>> xcrash.sample <<<

java stacktrace:
    at android.os.MessageQueue.nativePollOnce(Native Method)
    at android.os.MessageQueue.next(MessageQueue.java:336)
    at android.os.Looper.loop(Looper.java:174)
    at android.os.HandlerThread.run(HandlerThread.java:67)

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4355, name: FinalizerWatchdogDaemon  >>> xcrash.sample <<<

java stacktrace:
    at java.lang.Thread.sleep(Native Method)
    at java.lang.Thread.sleep(Thread.java:440)
    at java.lang.Thread.sleep(Thread.java:356)
    at java.lang.Daemons$FinalizerWatchdogDaemon.sleepForMillis(Daemons.java:383)
    at java.lang.Daemons$FinalizerWatchdogDaemon.waitForFinalization(Daemons.java:411)
    at java.lang.Daemons$FinalizerWatchdogDaemon.runInternal(Daemons.java:323)
    at java.lang.Daemons$Daemon.run(Daemons.java:137)
    at java.lang.Thread.run(Thread.java:919)

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4378, name: process reaper  >>> xcrash.sample <<<

java stacktrace:
    at sun.misc.Unsafe.park(Native Method)
    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:230)
    at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:461)
    at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:362)
    at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:937)
    at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1091)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1152)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
    at java.lang.Thread.run(Thread.java:919)

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4377, name: CleanupReference  >>> xcrash.sample <<<

java stacktrace:
    at java.lang.Object.wait(Native Method)
    at java.lang.Object.wait(Object.java:442)
    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:190)
    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:211)
    at Po.run(PG:2)

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4350, name: Signal Catcher  >>> xcrash.sample <<<

java stacktrace:

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4373, name: ThreadPoolForeg  >>> xcrash.sample <<<

java stacktrace:

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4369, name: Chrome_ProcessLauncherThread  >>> xcrash.sample <<<

java stacktrace:
    at android.os.MessageQueue.nativePollOnce(Native Method)
    at android.os.MessageQueue.next(MessageQueue.java:336)
    at android.os.Looper.loop(Looper.java:174)
    at android.os.HandlerThread.run(HandlerThread.java:67)

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4358, name: Binder:21356_3  >>> xcrash.sample <<<

java stacktrace:

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4366, name: CrAsyncTask #1  >>> xcrash.sample <<<

java stacktrace:
    at sun.misc.Unsafe.park(Native Method)
    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:230)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2109)
    at java.util.concurrent.ArrayBlockingQueue.poll(ArrayBlockingQueue.java:402)
    at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1091)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1152)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
    at Js.run(PG:2)
    at java.lang.Thread.run(Thread.java:919)

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4376, name: ThreadPoolForeg  >>> xcrash.sample <<<

java stacktrace:

--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 21356, tid: 4356, name: Binder:21356_1  >>> xcrash.sample <<<

java stacktrace:

total JVM threads (exclude the crashed thread): 24
dumped JVM threads:24
```


## Native Crash

捕获 Native Crash 靠的是信号处理器（`sigaction`），比如说访问非法地址时，APP 进程会收到 `SIGSEGV`，对应的信号处理器就可以在这个时间点收集堆栈信息

### sigaction

    signal 产生后会处于几种状态中：
        1. blocked，让内核先持有信号不要分发（deliver），在 unblocked 之前都不会被分发出去；被 blocked 的信号集合叫做 singal mask，每个线程都有自己的 signal mask
        2. pending，内核正在分发信号给指定的进程/线程（但还没分发出去）

    signal 可以是进程范围的，比如内核产生的信号、kill 和 sigqueue；也可以是线程范围的，比如因执行机器指令而导致的硬件异常（SIGSEGV、SIGFPE）、通过 tgkill 或者 pthread_kill 指定目标线程

    进程范围的信号会随机选择一个 signal unblocked 的线程来消费（deliver）

`sigaction` 用来注册信号处理器，是升级版的 `signal`

```cpp
// 如果 act != null，它被注册为新的信号处理器；如果 oldact != null，上一个信号处理器将被保存在此
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);

struct sigaction {
    void     (*sa_handler)(int);                        // 只收到 signal 作为参数的处理器
    void     (*sa_sigaction)(int, siginfo_t *, void *); // 当指定 SA_SIGINFO 时，替代 sa_handler 作为处理器（能收到三个参数）
    sigset_t   sa_mask;                                 // 处理器运行时，暂时屏蔽指定信号（将它们加到线程的 signal mask）
    int        sa_flags;
    void     (*sa_restorer)(void);                      // not for app
};

// sa_flags:
//     SA_SIGINFO 使用 sa_sigaction 作为处理器
//     SA_RESTART 当线程阻塞在系统调用/库函数上，因为信号的到来转而进入信号处理器，退出信号处理器后如何恢复上一个系统调用/库函数；
//                默认是使其返回失败码，此 flag 指示重新执行系统调用/库函数
//     SA_ONSTACK 用另一个方法调用栈来执行处理器函数

void sa_sigaction(int sig, siginfo_t *info, void *ucontext)

siginfo_t {
    int      si_signo;     /* Signal number */
    int      si_errno;     /* An errno value */
    int      si_code;      /* Signal code */
    int      si_trapno;    /* Trap number that caused
                              hardware-generated signal
                              (unused on most architectures) */
    pid_t    si_pid;       /* Sending process ID */
    uid_t    si_uid;       /* Real user ID of sending process */
    int      si_status;    /* Exit value or signal */
    clock_t  si_utime;     /* User time consumed */
    clock_t  si_stime;     /* System time consumed */
    sigval_t si_value;     /* Signal value */
    int      si_int;       /* POSIX.1b signal */
    void    *si_ptr;       /* POSIX.1b signal */
    int      si_overrun;   /* Timer overrun count;
                              POSIX.1b timers */
    int      si_timerid;   /* Timer ID; POSIX.1b timers */
    void    *si_addr;      /* Memory location which caused fault */
    long     si_band;      /* Band event (was int in
                              glibc 2.3.2 and earlier) */
    int      si_fd;        /* File descriptor */
    short    si_addr_lsb;  /* Least significant bit of address
                              (since Linux 2.6.32) */
    void    *si_lower;     /* Lower bound when address violation
                              occurred (since Linux 3.19) */
    void    *si_upper;     /* Upper bound when address violation
                              occurred (since Linux 3.19) */
    int      si_pkey;      /* Protection key on PTE that caused
                              fault (since Linux 4.6) */
    void    *si_call_addr; /* Address of system call instruction
                              (since Linux 3.5) */
    int      si_syscall;   /* Number of attempted system call
                              (since Linux 3.5) */
    unsigned int si_arch;  /* Architecture of attempted system call
                              (since Linux 3.5) */
}
```

### sigaltstack

```cpp
/** 
 * 为当前进程设置一个新的（获取上一个）信号处理器调用栈，其实就是为信号处理器预先分配一块内存，作为其调用栈
 * The most common usage of an alternate signal stack is to handle the SIGSEGV signal 
 * that is generated if the space available for the normal process stack is exhausted: 
 * in this case, a signal handler for SIGSEGV cannot be invoked on the process stack; 
 * if we wish to handle it, we must use an alternate signal stack
 */
int sigaltstack(const stack_t *ss, stack_t *old_ss);

typedef struct {
    void  *ss_sp;     /* Base address of stack */
    int    ss_flags;  /* Flags */
    size_t ss_size;   /* Number of bytes in stack */
} stack_t;
```

### xc_crash_signal_handler

```cpp
// XCrash.init
// NativeHandler.initialize
// NativeHandler.nativeInit
// xc_jni_init
// xc_crash_init

// 需要捕获的信号
static xcc_signal_crash_info_t xcc_signal_crash_info[] =
{
    {.signum = SIGABRT},
    {.signum = SIGBUS},
    {.signum = SIGFPE},
    {.signum = SIGILL},
    {.signum = SIGSEGV},
    {.signum = SIGTRAP},
    {.signum = SIGSYS},
    {.signum = SIGSTKFLT}
};

int xcc_signal_crash_register(void (*handler)(int, siginfo_t *, void *))
{
    // 预先为处理器分配一块内存
    stack_t ss;
    if(NULL == (ss.ss_sp = calloc(1, XCC_SIGNAL_CRASH_STACK_SIZE))) return XCC_ERRNO_NOMEM;
    ss.ss_size  = XCC_SIGNAL_CRASH_STACK_SIZE;
    ss.ss_flags = 0;
    if(0 != sigaltstack(&ss, NULL)) return XCC_ERRNO_SYS;

    struct sigaction act;
    memset(&act, 0, sizeof(act));
    sigfillset(&act.sa_mask);
    act.sa_sigaction = handler;
    act.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;
    
    // 为上述信号注册处理器
    size_t i;
    for(i = 0; i < sizeof(xcc_signal_crash_info) / sizeof(xcc_signal_crash_info[0]); i++)
        if(0 != sigaction(xcc_signal_crash_info[i].signum, &act, &(xcc_signal_crash_info[i].oldact)))
            return XCC_ERRNO_SYS;

    return 0;
}

// 信号处理器，跟上面的 JavaCrashHandler 一样，主要是收集各种信息，写入 tombstone 文件
// 比较复杂，下一章节进行分析
static void xc_crash_signal_handler(int sig, siginfo_t *si, void *uc)
```

### 核心步骤

1. 信号处理器（`xc_crash_signal_handler`，在 APP 进程）收集相关的信息到 `xc_crash_spot`
2. `fork` 出子进程 dumper，子进程继承了父进程的内存布局，也就捕获到了 APP 进程 crash 时刻的内存布局
3. dumper 进程的入口点是 `xc_crash_exec_dumper`，signal handler 线程通过 `waitpid` 阻塞直到 dumper 进程完成工作
4. dumper 将 signal 和调用堆栈等信息写入管道，然后加载程序 `libxcrash_dumper.so` 替换当前的内存空间（旧的内存空间的所有信息将被清空）
5. `xcd_core.c` 里的 main 函数从管道里读取 `xc_crash_spot` 并写入 tombstone 日志文件，退出
6. signal handler 线程从阻塞中恢复，退出 APP 进程

```cpp
// APP 进程，signal hander 线程，dump 开始的地方
static void xc_crash_signal_handler(int sig, siginfo_t *si, void *uc)
{
    // set crash spot info
    xc_crash_spot.crash_time = xc_crash_time;
    xc_crash_spot.crash_tid = xc_crash_tid;
    memcpy(&(xc_crash_spot.siginfo), si, sizeof(siginfo_t));
    memcpy(&(xc_crash_spot.ucontext), uc, sizeof(ucontext_t));
    xc_crash_spot.log_pathname_len = strlen(xc_crash_log_pathname);

    // spawn crash dumper process
    pid_t dumper_pid = xc_crash_fork(xc_crash_exec_dumper);

    // wait the crash dumper process terminated
    int wait_r = XCC_UTIL_TEMP_FAILURE_RETRY(waitpid(dumper_pid, &status, __WALL));

    // exit
}

// dumper 进程的入口
static int xc_crash_exec_dumper(void *arg)
{
    // 创建一个管道，第一个用来读，第二个用来写
    int pipefd[2];
    if(0 != pipe2(pipefd, O_CLOEXEC))

    // 将 xc_crash_spot 写入管道
    struct iovec iovs[12] = {
        {.iov_base = &xc_crash_spot,                      .iov_len = sizeof(xcc_spot_t)},
        {.iov_base = xc_crash_log_pathname,               .iov_len = xc_crash_spot.log_pathname_len},
        {.iov_base = xc_common_os_version,                .iov_len = xc_crash_spot.os_version_len},
        {.iov_base = xc_common_kernel_version,            .iov_len = xc_crash_spot.kernel_version_len},
        {.iov_base = xc_common_abi_list,                  .iov_len = xc_crash_spot.abi_list_len},
        {.iov_base = xc_common_manufacturer,              .iov_len = xc_crash_spot.manufacturer_len},
        {.iov_base = xc_common_brand,                     .iov_len = xc_crash_spot.brand_len},
        {.iov_base = xc_common_model,                     .iov_len = xc_crash_spot.model_len},
        {.iov_base = xc_common_build_fingerprint,         .iov_len = xc_crash_spot.build_fingerprint_len},
        {.iov_base = xc_common_app_id,                    .iov_len = xc_crash_spot.app_id_len},
        {.iov_base = xc_common_app_version,               .iov_len = xc_crash_spot.app_version_len},
        {.iov_base = xc_crash_dump_all_threads_whitelist, .iov_len = xc_crash_spot.dump_all_threads_whitelist_len}
    };
    int iovs_cnt = (0 == xc_crash_spot.dump_all_threads_whitelist_len ? 11 : 12);
    ssize_t ret = XCC_UTIL_TEMP_FAILURE_RETRY(writev(pipefd[1], iovs, iovs_cnt));

    // 将 stdin (fd 0) 指向管道的读端口
    XCC_UTIL_TEMP_FAILURE_RETRY(dup2(pipefd[0], STDIN_FILENO));
    
    syscall(SYS_close, pipefd[0]);
    syscall(SYS_close, pipefd[1]);

    // 加载程序 libxcrash_dumper.so 替换当前的内存空间
    execl(xc_crash_dumper_pathname, XCC_UTIL_XCRASH_DUMPER_FILENAME, NULL);
    return 100 + errno;
}

// libxcrash_dumper.so 的入口点，在 xcd_core.c
int main(int argc, char** argv)
{
    // 从 stdin 读取 xc_crash_spot
    if(0 != xcd_core_read_args()) exit(1);

    //open log file
    if(0 > (xcd_core_log_fd = XCC_UTIL_TEMP_FAILURE_RETRY(open(xcd_core_log_pathname, O_WRONLY | O_CLOEXEC)))) exit(2);

    //create process object
    if(0 != xcd_process_create(&xcd_core_proc,
                               xcd_core_spot.crash_pid,
                               xcd_core_spot.crash_tid,
                               &(xcd_core_spot.siginfo),
                               &(xcd_core_spot.ucontext))) exit(3);

    //suspend all threads in the process
    xcd_process_suspend_threads(xcd_core_proc);

    //load process info
    if(0 != xcd_process_load_info(xcd_core_proc)) exit(4);

    //record system info
    if(0 != xcd_sys_record(xcd_core_log_fd,
                           xcd_core_spot.time_zone,
                           xcd_core_spot.start_time,
                           xcd_core_spot.crash_time,
                           xcd_core_app_id,
                           xcd_core_app_version,
                           xcd_core_spot.api_level,
                           xcd_core_os_version,
                           xcd_core_kernel_version,
                           xcd_core_abi_list,
                           xcd_core_manufacturer,
                           xcd_core_brand,
                           xcd_core_model,
                           xcd_core_build_fingerprint)) exit(5);

    //record process info
    if(0 != xcd_process_record(xcd_core_proc,
                               xcd_core_log_fd,
                               xcd_core_spot.logcat_system_lines,
                               xcd_core_spot.logcat_events_lines,
                               xcd_core_spot.logcat_main_lines,
                               xcd_core_spot.dump_elf_hash,
                               xcd_core_spot.dump_map,
                               xcd_core_spot.dump_fds,
                               xcd_core_spot.dump_network_info,
                               xcd_core_spot.dump_all_threads,
                               xcd_core_spot.dump_all_threads_count_max,
                               xcd_core_dump_all_threads_whitelist,
                               xcd_core_spot.api_level)) exit(6);

    //resume all threads in the process
    xcd_process_resume_threads(xcd_core_proc);

    // exit
}
```




