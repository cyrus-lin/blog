<!DOCTYPE html><html lang="zh-CN" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Android 图形栈（三）render thread" /><meta name="author" content="Cyrus" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="接着上一篇文章，在上篇文章里我们知道了 ui thread 在 view drawing 阶段产生了 DisplayList，而 render thread 会根据 DisplayList 执行真正的渲染工作，主要是 DrawFrameTask.syncFrameState 和 CanvasContext.draw 这两个方法" /><meta property="og:description" content="接着上一篇文章，在上篇文章里我们知道了 ui thread 在 view drawing 阶段产生了 DisplayList，而 render thread 会根据 DisplayList 执行真正的渲染工作，主要是 DrawFrameTask.syncFrameState 和 CanvasContext.draw 这两个方法" /><link rel="canonical" href="https://cyruslin.com/blog/blog/posts/render-thread/" /><meta property="og:url" content="https://cyruslin.com/blog/blog/posts/render-thread/" /><meta property="og:site_name" content="Cyrus" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-12-27T12:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Android 图形栈（三）render thread" /><meta name="twitter:site" content="@magicboy_linw" /><meta name="twitter:creator" content="@Cyrus" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"headline":"Android 图形栈（三）render thread","dateModified":"2021-03-22T10:45:38+08:00","datePublished":"2020-12-27T12:00:00+08:00","description":"接着上一篇文章，在上篇文章里我们知道了 ui thread 在 view drawing 阶段产生了 DisplayList，而 render thread 会根据 DisplayList 执行真正的渲染工作，主要是 DrawFrameTask.syncFrameState 和 CanvasContext.draw 这两个方法","url":"https://cyruslin.com/blog/blog/posts/render-thread/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://cyruslin.com/blog/blog/posts/render-thread/"},"author":{"@type":"Person","name":"Cyrus"},"@context":"https://schema.org"}</script><title>Android 图形栈（三）render thread | Cyrus</title><link rel="shortcut icon" href="/blog/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/blog/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/blog/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/blog/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/blog/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/blog/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/blog/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/blog/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/blog/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/blog/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/blog/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/blog/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/blog/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/blog/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/blog/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/blog/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/blog/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/blog/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/blog/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/blog/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/blog/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/blog/assets/js/dist/post.min.js"></script> <script defer src="/blog/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="main-wrapper" style="margin-left: 0px;"><div id="main"><div class="row" style="padding-left: 0px;"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8" style="max-width: 75%;margin-top: 0rem;padding-left: 0.5rem;"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Android 图形栈（三）render thread</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Dec 27, 2020, 12:00 PM +0800" > Dec 27, 2020 <i class="unloaded">2020-12-27T12:00:00+08:00</i> </span> by <span class="author"> Cyrus </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Mar 22, 2021, 10:45 AM +0800" > Mar 22 <i class="unloaded">2021-03-22T10:45:38+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3483 words">19 min</span></div></div><div class="post-content"><p>接着<a href="../ui-thread-in-vsync/">上一篇文章</a>，在上篇文章里我们知道了 ui thread 在 view drawing 阶段产生了 <code class="language-plaintext highlighter-rouge">DisplayList</code>，而 render thread 会根据 <code class="language-plaintext highlighter-rouge">DisplayList</code> 执行真正的渲染工作，主要是 <code class="language-plaintext highlighter-rouge">DrawFrameTask.syncFrameState</code> 和 <code class="language-plaintext highlighter-rouge">CanvasContext.draw</code> 这两个方法</p><h2 id="syncframestate">syncFrameState</h2><p>重要的方法有三个：<code class="language-plaintext highlighter-rouge">makeCurrent</code>，<code class="language-plaintext highlighter-rouge">unpinImages</code> 和 <code class="language-plaintext highlighter-rouge">prepareTree</code></p><p><code class="language-plaintext highlighter-rouge">TreeInfo</code> 用来在后续的一系列操作中收集信息，你会看到它在各个方法中作为参数传递</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">bool</span> <span class="n">DrawFrameTask</span><span class="o">::</span><span class="n">syncFrameState</span><span class="p">(</span><span class="n">TreeInfo</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kt">bool</span> <span class="n">canDraw</span> <span class="o">=</span> <span class="n">mContext</span><span class="o">-&gt;</span><span class="n">makeCurrent</span><span class="p">();</span>
    <span class="n">mContext</span><span class="o">-&gt;</span><span class="n">unpinImages</span><span class="p">();</span>
    <span class="c1">// ...</span>
    <span class="n">mContext</span><span class="o">-&gt;</span><span class="n">setContentDrawBounds</span><span class="p">(</span><span class="n">mContentDrawBounds</span><span class="p">);</span>
    <span class="n">mContext</span><span class="o">-&gt;</span><span class="n">prepareTree</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">mFrameInfo</span><span class="p">,</span> <span class="n">mSyncQueued</span><span class="p">,</span> <span class="n">mTargetNode</span><span class="p">);</span>
    <span class="c1">// ... If prepareTextures is false, we ran out of texture cache space</span>
    <span class="k">return</span> <span class="n">info</span><span class="p">.</span><span class="n">prepareTextures</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="makecurrent">makeCurrent</h2><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">bool</span> <span class="n">CanvasContext</span><span class="o">::</span><span class="n">makeCurrent</span><span class="p">()</span>
<span class="n">MakeCurrentResult</span> <span class="n">SkiaOpenGLPipeline</span><span class="o">::</span><span class="n">makeCurrent</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mEglManager</span><span class="p">.</span><span class="n">makeCurrent</span><span class="p">(</span><span class="n">mEglSurface</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">MakeCurrentResult</span><span class="o">::</span><span class="n">AlreadyCurrent</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">EglManager</span><span class="o">::</span><span class="n">makeCurrent</span><span class="p">(</span><span class="n">EGLSurface</span> <span class="n">surface</span><span class="p">,</span> <span class="n">EGLint</span><span class="o">*</span> <span class="n">errOut</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">force</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eglMakeCurrent</span><span class="p">(</span><span class="n">mEglDisplay</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">mEglContext</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最终是调用了 opengl 的 <code class="language-plaintext highlighter-rouge">[eglMakeCurrent](https://www.khronos.org/registry/EGL/sdk/docs/man/html/eglMakeCurrent.xhtml)</code> 方法准备 opengl 环境；现在是 ui thread，并不会在这里进行渲染，而是为了待会将 mutable images 上传到 gpu</p><p>opengl api 都是像 <code class="language-plaintext highlighter-rouge">glDrawArrays</code>、<code class="language-plaintext highlighter-rouge">glDrawElements</code>、<code class="language-plaintext highlighter-rouge">glBindTexture</code> 这样只有方法名和参数的，它的上下文是绑定在 thread 上的，在调用 opengl api 前 <code class="language-plaintext highlighter-rouge">eglMakeCurrent</code> 就是确保当前线程有 opengl 上下文；mEglDisplay 可以理解为设备的屏幕；opengl 有双缓冲，一个被主线程读取，一个被渲染线程写入，就是第二和第三个参数，渲染完交换一下，读变写，写变读，当前都是用得同一个 surface；第四个就是 opengl 的上下文，保存了 opengl 状态机</p><h2 id="unpinimages">unpinImages</h2><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="cm">/** \class SkImage
    SkImage describes a two dimensional array of pixels to draw. The pixels may be
    decoded in a raster bitmap, encoded in a SkPicture or compressed data stream,
    or located in GPU memory as a GPU texture.

    SkImage cannot be modified after it is created. SkImage may allocate additional
    storage as needed; for instance, an encoded SkImage may decode when drawn.

    SkImage width and height are greater than zero. Creating an SkImage with zero width
    or height returns SkImage equal to nullptr.

    SkImage may be created from SkBitmap, SkPixmap, SkSurface, SkPicture, encoded streams,
    GPU texture, YUV_ColorSpace data, or hardware buffer. Encoded streams supported
    include BMP, GIF, HEIF, ICO, JPEG, PNG, WBMP, WebP. Supported encoding details
    vary with platform.
*/</span>
<span class="k">class</span> <span class="nc">SK_API</span> <span class="n">SkImage</span>	

    <span class="cm">/**
     * Pin any mutable images to the GPU cache. A pinned images is guaranteed to
     * remain in the cache until it has been unpinned. We leverage this feature
     * to avoid making a CPU copy of the pixels.
     *
     * @return true if all images have been successfully pinned to the GPU cache
     *         and false otherwise (e.g. cache limits have been exceeded).
     */</span>
    <span class="kt">bool</span> <span class="nf">pinImages</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SkImage</span><span class="o">*&gt;&amp;</span> <span class="n">mutableImages</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">mRenderPipeline</span><span class="o">-&gt;</span><span class="n">pinImages</span><span class="p">(</span><span class="n">mutableImages</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/**
     * Unpin any image that had be previously pinned to the GPU cache
     */</span>
    <span class="kt">void</span> <span class="nf">unpinImages</span><span class="p">()</span> <span class="p">{</span> <span class="n">mRenderPipeline</span><span class="o">-&gt;</span><span class="n">unpinImages</span><span class="p">();</span> <span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">SkImage</code> 对一切图像的抽象，包括 jpg、webp 等压缩格式、Bitmap 位图、流、甚至 gpu 上的纹理</p><p><code class="language-plaintext highlighter-rouge">pinImages</code> 把在内存的 SkImage 作为纹理上传到 gpu 内存，然后可以通过纹理 id 引用，从而避免在内存里操作（复制）像素</p><p><code class="language-plaintext highlighter-rouge">unpinImages</code> 从 gpu 内存里移除纹理</p><h2 id="damageaccumulator">DamageAccumulator</h2><p><code class="language-plaintext highlighter-rouge">DamageAccumulator</code> 是 <code class="language-plaintext highlighter-rouge">DirtyStack</code> stack（FIFO，用双向链表实现），用来累计脏区，它的一般用法是这样的</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="n">info</span><span class="p">.</span><span class="n">damageAccumulator</span><span class="o">-&gt;</span><span class="n">pushTransform</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="n">damageSelf</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="n">info</span><span class="p">.</span><span class="n">damageAccumulator</span><span class="o">-&gt;</span><span class="n">popTransform</span><span class="p">();</span>

<span class="c1">// 将 node 压入栈顶</span>
<span class="kt">void</span> <span class="n">DamageAccumulator</span><span class="o">::</span><span class="n">pushTransform</span><span class="p">(</span><span class="k">const</span> <span class="n">RenderNode</span><span class="o">*</span> <span class="n">transform</span><span class="p">)</span>

<span class="c1">// 更新栈顶元素的脏区 = 已有脏区 + node 大小，也就是并集</span>
<span class="kt">void</span> <span class="n">RenderNode</span><span class="o">::</span><span class="n">damageSelf</span><span class="p">(</span><span class="n">TreeInfo</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isRenderable</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">mDamageGenerationId</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">damageGenerationId</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">properties</span><span class="p">().</span><span class="n">getClipDamageToBounds</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">info</span><span class="p">.</span><span class="n">damageAccumulator</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">properties</span><span class="p">().</span><span class="n">getWidth</span><span class="p">(),</span> <span class="n">properties</span><span class="p">().</span><span class="n">getHeight</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Hope this is big enough?</span>
            <span class="c1">// TODO: Get this from the display list ops or something</span>
            <span class="n">info</span><span class="p">.</span><span class="n">damageAccumulator</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">(</span><span class="n">DIRTY_MIN</span><span class="p">,</span> <span class="n">DIRTY_MIN</span><span class="p">,</span> <span class="n">DIRTY_MAX</span><span class="p">,</span> <span class="n">DIRTY_MAX</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">DamageAccumulator</span><span class="o">::</span><span class="n">dirty</span><span class="p">(</span><span class="kt">float</span> <span class="n">left</span><span class="p">,</span> <span class="kt">float</span> <span class="n">top</span><span class="p">,</span> <span class="kt">float</span> <span class="n">right</span><span class="p">,</span> <span class="kt">float</span> <span class="n">bottom</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">mHead</span><span class="o">-&gt;</span><span class="n">pendingDirty</span><span class="p">.</span><span class="n">join</span><span class="p">({</span><span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">bottom</span><span class="p">});</span>
<span class="p">}</span>

<span class="c1">// 弹出栈顶元素 head，并将栈顶元素的脏区合并到当前栈顶元素 prev 的脏区</span>
<span class="c1">// 可见脏区是累加的</span>
<span class="kt">void</span> <span class="n">DamageAccumulator</span><span class="o">::</span><span class="n">popTransform</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">LOG_ALWAYS_FATAL_IF</span><span class="p">(</span><span class="n">mHead</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">==</span> <span class="n">mHead</span><span class="p">,</span> <span class="s">"Cannot pop the root frame!"</span><span class="p">);</span>
    <span class="n">DirtyStack</span><span class="o">*</span> <span class="n">dirtyFrame</span> <span class="o">=</span> <span class="n">mHead</span><span class="p">;</span>
    <span class="n">mHead</span> <span class="o">=</span> <span class="n">mHead</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">dirtyFrame</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">TransformRenderNode</span><span class="p">:</span>
            <span class="n">applyRenderNodeTransform</span><span class="p">(</span><span class="n">dirtyFrame</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">TransformMatrix4</span><span class="p">:</span>
            <span class="n">applyMatrix4Transform</span><span class="p">(</span><span class="n">dirtyFrame</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">TransformNone</span><span class="p">:</span>
            <span class="n">mHead</span><span class="o">-&gt;</span><span class="n">pendingDirty</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirtyFrame</span><span class="o">-&gt;</span><span class="n">pendingDirty</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
            <span class="n">LOG_ALWAYS_FATAL</span><span class="p">(</span><span class="s">"Tried to pop an invalid type: %d"</span><span class="p">,</span> <span class="n">dirtyFrame</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="preparetree">prepareTree</h2><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">CanvasContext</span><span class="o">::</span><span class="n">prepareTree</span><span class="p">(</span><span class="n">TreeInfo</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">*</span> <span class="n">uiFrameInfo</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">syncQueued</span><span class="p">,</span> <span class="n">RenderNode</span><span class="o">*</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">RenderNode</span><span class="o">&gt;&amp;</span> <span class="n">node</span> <span class="o">:</span> <span class="n">mRenderNodes</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Only the primary target node will be drawn full - all other nodes would get drawn in</span>
        <span class="c1">// real time mode. In case of a window, the primary node is the window content and the other</span>
        <span class="c1">// node(s) are non client / filler nodes.</span>
        <span class="n">info</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="n">target</span> <span class="o">?</span> <span class="n">TreeInfo</span><span class="o">::</span><span class="n">MODE_FULL</span> <span class="o">:</span> <span class="n">TreeInfo</span><span class="o">::</span><span class="n">MODE_RT_ONLY</span><span class="p">);</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">prepareTree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>target 是 <code class="language-plaintext highlighter-rouge">HardwareRenderer.mRootNode</code> 对应的 native <code class="language-plaintext highlighter-rouge">RootRenderNode</code>，<code class="language-plaintext highlighter-rouge">mRenderNodes</code> 正常情况下应该只有一个元素 target，所以这里应该总是 <code class="language-plaintext highlighter-rouge">TreeInfo::MODE_FULL</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">RenderNode</span><span class="o">::</span><span class="n">prepareTree</span><span class="p">(</span><span class="n">TreeInfo</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">RenderNode</span><span class="o">::</span><span class="n">prepareTreeImpl</span><span class="p">(</span><span class="n">TreeObserver</span><span class="o">&amp;</span> <span class="n">observer</span><span class="p">,</span> <span class="n">TreeInfo</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">functorsNeedLayer</span><span class="p">)</span> <span class="p">{</span>    
    <span class="c1">// ...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">TreeInfo</span><span class="o">::</span><span class="n">MODE_FULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pushStagingDisplayListChanges</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mDisplayList</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">info</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">hasFunctors</span> <span class="o">|=</span> <span class="n">mDisplayList</span><span class="o">-&gt;</span><span class="n">hasFunctor</span><span class="p">();</span>
        <span class="kt">bool</span> <span class="n">isDirty</span> <span class="o">=</span> <span class="n">mDisplayList</span><span class="o">-&gt;</span><span class="n">prepareListAndChildren</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">childFunctorsNeedLayer</span><span class="p">,</span>
            <span class="p">[](</span><span class="n">RenderNode</span><span class="o">*</span> <span class="n">child</span><span class="p">,</span> <span class="n">TreeObserver</span><span class="o">&amp;</span> <span class="n">observer</span><span class="p">,</span> <span class="n">TreeInfo</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">functorsNeedLayer</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">child</span><span class="o">-&gt;</span><span class="n">prepareTreeImpl</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">functorsNeedLayer</span><span class="p">);</span>
            <span class="p">});</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
    <span class="n">pushLayerUpdate</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RenderNode</span><span class="o">::</span><span class="n">pushStagingDisplayListChanges</span><span class="p">(</span><span class="n">TreeObserver</span><span class="o">&amp;</span> <span class="n">observer</span><span class="p">,</span> <span class="n">TreeInfo</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mNeedsDisplayListSync</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mNeedsDisplayListSync</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">damageSelf</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
        <span class="n">syncDisplayList</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
        <span class="n">damageSelf</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RenderNode</span><span class="o">::</span><span class="n">syncDisplayList</span><span class="p">(</span><span class="n">TreeObserver</span><span class="o">&amp;</span> <span class="n">observer</span><span class="p">,</span> <span class="n">TreeInfo</span><span class="o">*</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mStagingDisplayList</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mStagingDisplayList</span><span class="o">-&gt;</span><span class="n">updateChildren</span><span class="p">([](</span><span class="n">RenderNode</span><span class="o">*</span> <span class="n">child</span><span class="p">)</span> <span class="p">{</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">incParentRefCount</span><span class="p">();</span> <span class="p">});</span>
    <span class="p">}</span>
    <span class="n">deleteDisplayList</span><span class="p">(</span><span class="n">observer</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
    <span class="n">mDisplayList</span> <span class="o">=</span> <span class="n">mStagingDisplayList</span><span class="p">;</span>
    <span class="n">mStagingDisplayList</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mDisplayList</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">WebViewSyncData</span> <span class="n">syncData</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">applyForceDark</span> <span class="o">=</span> <span class="n">info</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">disableForceDark</span>
        <span class="p">};</span>
        <span class="n">mDisplayList</span><span class="o">-&gt;</span><span class="n">syncContents</span><span class="p">(</span><span class="n">syncData</span><span class="p">);</span>
        <span class="n">handleForceDark</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>还记得在<a href="../ui-thread-in-vsync/">上篇文章</a>里提到， DisplayList 在 endRecording 阶段被放在 <code class="language-plaintext highlighter-rouge">RenderNode.mStagingDisplayList</code>，这时候转移到 <code class="language-plaintext highlighter-rouge">mDisplayList</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">bool</span> <span class="n">SkiaDisplayList</span><span class="o">::</span><span class="n">prepareListAndChildren</span><span class="p">(</span><span class="n">TreeObserver</span><span class="o">&amp;</span> <span class="n">observer</span><span class="p">,</span> <span class="n">TreeInfo</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">functorsNeedLayer</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">RenderNode</span><span class="o">*</span><span class="p">,</span> <span class="n">TreeObserver</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">TreeInfo</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">childFn</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">prepareTextures</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">info</span><span class="p">.</span><span class="n">canvasContext</span><span class="p">.</span><span class="n">pinImages</span><span class="p">(</span><span class="n">mMutableImages</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">info</span><span class="p">.</span><span class="n">prepareTextures</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">info</span><span class="p">.</span><span class="n">canvasContext</span><span class="p">.</span><span class="n">unpinImages</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">hasBackwardProjectedNodesHere</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">hasBackwardProjectedNodesSubtree</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">child</span> <span class="o">:</span> <span class="n">mChildNodes</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">RenderNode</span><span class="o">*</span> <span class="n">childNode</span> <span class="o">=</span> <span class="n">child</span><span class="p">.</span><span class="n">getRenderNode</span><span class="p">();</span>
        <span class="c1">// ...</span>
        <span class="n">childFn</span><span class="p">(</span><span class="n">childNode</span><span class="p">,</span> <span class="n">observer</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">functorsNeedLayer</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">SkiaRecordingCanvas.drawBitmap</code> 等方法会将 mutable image 放入 <code class="language-plaintext highlighter-rouge">mMutableImages</code>，然后在 prepare 阶段上传到 gpu；为什么这么做呢，我猜想是在渲染之前需要确保所有内容都计算完毕并确保不变，mutable image 可以被修改，所以放到 gpu 里确保不被改动，immutable image 因为本身就不可修改所以无需这样处理</p><p><code class="language-plaintext highlighter-rouge">TreeInfo.prepareTextures</code> 标识 mutable images 有没上传成功；如果上传成功，ui thread 在 <code class="language-plaintext highlighter-rouge">DrawFrameTask::syncFrameState</code> 之后就会被唤醒，否则会一直阻塞直到 <code class="language-plaintext highlighter-rouge">CanvasContext.draw</code> 完成；这对 ui thread 有着很大的影响</p><p><code class="language-plaintext highlighter-rouge">SkiaDisplayList.mChildNodes</code> 应该只有一个 <code class="language-plaintext highlighter-rouge">DecorView.mRenderNode</code>，在这里它的 <code class="language-plaintext highlighter-rouge">prepareTreeImpl</code> 被调用</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">RenderNode</span><span class="o">::</span><span class="n">pushLayerUpdate</span><span class="p">(</span><span class="n">TreeInfo</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">canvasContext</span><span class="p">.</span><span class="n">createOrUpdateLayer</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="o">*</span><span class="n">info</span><span class="p">.</span><span class="n">damageAccumulator</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">errorHandler</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">damageSelf</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// ... 将有 layer 的 RenderNode 和它的脏区加入 TreeInfo.layerUpdateQueue</span>
    <span class="n">SkRect</span> <span class="n">dirty</span><span class="p">;</span>
    <span class="n">info</span><span class="p">.</span><span class="n">damageAccumulator</span><span class="o">-&gt;</span><span class="n">peekAtDirty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dirty</span><span class="p">);</span>
    <span class="n">info</span><span class="p">.</span><span class="n">layerUpdateQueue</span><span class="o">-&gt;</span><span class="n">enqueueLayerWithDamage</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">dirty</span><span class="p">);</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 如果 node 没有 layer，或者 node 的大小发送了改变，则新建 layer</span>
<span class="kt">bool</span> <span class="n">SkiaPipeline</span><span class="o">::</span><span class="n">createOrUpdateLayer</span><span class="p">(</span><span class="n">RenderNode</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="n">DamageAccumulator</span><span class="o">&amp;</span> <span class="n">damageAccumulator</span><span class="p">,</span>
                                       <span class="n">ErrorHandler</span><span class="o">*</span> <span class="n">errorHandler</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">SkSurface</span><span class="o">*</span> <span class="n">layer</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">getLayerSurface</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">layer</span> <span class="o">||</span> <span class="n">layer</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">()</span> <span class="o">!=</span> <span class="n">surfaceWidth</span> <span class="o">||</span> <span class="n">layer</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">()</span> <span class="o">!=</span> <span class="n">surfaceHeight</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SkImageInfo</span> <span class="n">info</span><span class="p">;</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">SkImageInfo</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="n">surfaceWidth</span><span class="p">,</span> <span class="n">surfaceHeight</span><span class="p">,</span> <span class="n">getSurfaceColorType</span><span class="p">(),</span>
                                 <span class="n">kPremul_SkAlphaType</span><span class="p">,</span> <span class="n">getSurfaceColorSpace</span><span class="p">());</span>
        <span class="n">SkSurfaceProps</span> <span class="n">props</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">kUnknown_SkPixelGeometry</span><span class="p">);</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">setLayerSurface</span><span class="p">(</span><span class="n">SkSurface</span><span class="o">::</span><span class="n">MakeRenderTarget</span><span class="p">(</span><span class="n">mRenderThread</span><span class="p">.</span><span class="n">getGrContext</span><span class="p">(),</span>
                                                          <span class="n">SkBudgeted</span><span class="o">::</span><span class="n">kYes</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                                          <span class="k">this</span><span class="o">-&gt;</span><span class="n">getSurfaceOrigin</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">props</span><span class="p">));</span>
    <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们知道 <code class="language-plaintext highlighter-rouge">View</code> 是 framework ui api，<code class="language-plaintext highlighter-rouge">RenderNode</code> 相当于绘制这块 <code class="language-plaintext highlighter-rouge">View</code> 所需的配置文件；这里新增了一个新的概念 layer，它是这块 <code class="language-plaintext highlighter-rouge">View</code> 对应的 surface，它所呈现的内容将绘制在这个 surface 上，同 opengl 里 surface 的概念</p><p><code class="language-plaintext highlighter-rouge">RenderNode</code> 和它的脏区被添加到 <code class="language-plaintext highlighter-rouge">TreeInfo.layerUpdateQueue</code>；queue 里应该有两个元素，一个是 <code class="language-plaintext highlighter-rouge">HardwareRenderer.mRootNode</code> 对应的 native <code class="language-plaintext highlighter-rouge">RootRenderNode</code>，一个是 <code class="language-plaintext highlighter-rouge">DecorView.mRenderNode</code></p><h2 id="canvascontextdraw">CanvasContext.draw</h2><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">CanvasContext</span><span class="o">::</span><span class="n">draw</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 还记得上面说的吗，脏区是累加的，这里是总的脏区</span>
    <span class="n">SkRect</span> <span class="n">dirty</span><span class="p">;</span>
    <span class="n">mDamageAccumulator</span><span class="p">.</span><span class="n">finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dirty</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">Frame</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">mRenderPipeline</span><span class="o">-&gt;</span><span class="n">getFrame</span><span class="p">();</span>
    <span class="n">setPresentTime</span><span class="p">();</span>
    <span class="c1">// 再次计算脏区</span>
    <span class="n">SkRect</span> <span class="n">windowDirty</span> <span class="o">=</span> <span class="n">computeDirtyRect</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dirty</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">drew</span> <span class="o">=</span> <span class="n">mRenderPipeline</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">windowDirty</span><span class="p">,</span> <span class="n">dirty</span><span class="p">,</span> <span class="n">mLightGeometry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mLayerUpdateQueue</span><span class="p">,</span>
                                      <span class="n">mContentDrawBounds</span><span class="p">,</span> <span class="n">mOpaque</span><span class="p">,</span> <span class="n">mLightInfo</span><span class="p">,</span> <span class="n">mRenderNodes</span><span class="p">,</span>
                                      <span class="o">&amp;</span><span class="p">(</span><span class="n">profiler</span><span class="p">()));</span>
    <span class="kt">int64_t</span> <span class="n">frameCompleteNr</span> <span class="o">=</span> <span class="n">getFrameNumber</span><span class="p">();</span>
    <span class="n">waitOnFences</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="n">requireSwap</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">OK</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">didSwap</span> <span class="o">=</span> <span class="n">mRenderPipeline</span><span class="o">-&gt;</span><span class="n">swapBuffers</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">drew</span><span class="p">,</span> <span class="n">windowDirty</span><span class="p">,</span> <span class="n">mCurrentFrameInfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">requireSwap</span><span class="p">);</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="getframe">getFrame</h2><p>看下 <code class="language-plaintext highlighter-rouge">Frame</code>，它包含 <code class="language-plaintext highlighter-rouge">EGLSurface</code> 和 surface 宽高</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="n">Frame</span> <span class="n">SkiaOpenGLPipeline</span><span class="o">::</span><span class="n">getFrame</span><span class="p">()</span>
<span class="n">Frame</span> <span class="n">EglManager</span><span class="o">::</span><span class="n">beginFrame</span><span class="p">(</span><span class="n">EGLSurface</span> <span class="n">surface</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ... </span>
    <span class="n">makeCurrent</span><span class="p">(</span><span class="n">surface</span><span class="p">);</span>
    <span class="n">Frame</span> <span class="n">frame</span><span class="p">;</span>
    <span class="n">frame</span><span class="p">.</span><span class="n">mSurface</span> <span class="o">=</span> <span class="n">surface</span><span class="p">;</span>
    <span class="n">eglQuerySurface</span><span class="p">(</span><span class="n">mEglDisplay</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">EGL_WIDTH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">.</span><span class="n">mWidth</span><span class="p">);</span>
    <span class="n">eglQuerySurface</span><span class="p">(</span><span class="n">mEglDisplay</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">EGL_HEIGHT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">.</span><span class="n">mHeight</span><span class="p">);</span>
    <span class="n">frame</span><span class="p">.</span><span class="n">mBufferAge</span> <span class="o">=</span> <span class="n">queryBufferAge</span><span class="p">(</span><span class="n">surface</span><span class="p">);</span>
    <span class="n">eglBeginFrame</span><span class="p">(</span><span class="n">mEglDisplay</span><span class="p">,</span> <span class="n">surface</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">frame</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="irenderpipelinedraw">IRenderPipeline::draw</h2><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">bool</span> <span class="n">SkiaOpenGLPipeline</span><span class="o">::</span><span class="n">draw</span><span class="p">(...)</span>
<span class="kt">void</span> <span class="n">SkiaPipeline</span><span class="o">::</span><span class="n">renderFrame</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">SkCanvas</span><span class="o">*</span> <span class="n">canvas</span> <span class="o">=</span> <span class="n">tryCapture</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">get</span><span class="p">(),</span> <span class="n">layers</span><span class="p">);</span>
    <span class="c1">// draw all layers up front</span>
    <span class="n">renderLayersImpl</span><span class="p">(</span><span class="n">layers</span><span class="p">,</span> <span class="n">opaque</span><span class="p">);</span>
    <span class="n">renderFrameImpl</span><span class="p">(</span><span class="n">clip</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">opaque</span><span class="p">,</span> <span class="n">contentDrawBounds</span><span class="p">,</span> <span class="n">canvas</span><span class="p">,</span> <span class="n">preTransform</span><span class="p">);</span>
    <span class="n">endCapture</span><span class="p">(</span><span class="n">surface</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
    <span class="c1">// 绘制「布局边界」、「渲染分析」等 debug 信息，这里略过</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CC_UNLIKELY</span><span class="p">(</span><span class="n">Properties</span><span class="o">::</span><span class="n">debugOverdraw</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">renderOverdraw</span><span class="p">(</span><span class="n">clip</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">contentDrawBounds</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">preTransform</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">surface</span><span class="o">-&gt;</span><span class="n">getCanvas</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">();</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">SkiaPipeline::renderLayersImpl</code></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="c1">// 看上面，layers 是在 RenderNode::prepareTree 阶段加入的，包括 </span>
<span class="c1">// HardwareRenderer.mRootNode 对应的 native RootRenderNode 和 DecorView.mRenderNode</span>
<span class="kt">void</span> <span class="n">SkiaPipeline</span><span class="o">::</span><span class="n">renderLayersImpl</span><span class="p">(</span><span class="k">const</span> <span class="n">LayerUpdateQueue</span><span class="o">&amp;</span> <span class="n">layers</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">opaque</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">layers</span><span class="p">.</span><span class="n">entries</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">RenderNode</span><span class="o">*</span> <span class="n">layerNode</span> <span class="o">=</span> <span class="n">layers</span><span class="p">.</span><span class="n">entries</span><span class="p">()[</span><span class="n">i</span><span class="p">].</span><span class="n">renderNode</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
        <span class="c1">// ...</span>
        <span class="n">SkCanvas</span><span class="o">*</span> <span class="n">layerCanvas</span> <span class="o">=</span> <span class="n">layerNode</span><span class="o">-&gt;</span><span class="n">getLayerSurface</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getCanvas</span><span class="p">();</span>
        <span class="c1">// ...</span>
        <span class="n">RenderNodeDrawable</span> <span class="n">root</span><span class="p">(</span><span class="n">layerNode</span><span class="p">,</span> <span class="n">layerCanvas</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        <span class="n">root</span><span class="p">.</span><span class="n">forceDraw</span><span class="p">(</span><span class="n">layerCanvas</span><span class="p">);</span>
        <span class="c1">// ...</span>
        <span class="c1">// cache the current context so that we can defer flushing it until</span>
        <span class="c1">// either all the layers have been rendered or the context changes</span>
        <span class="n">GrContext</span><span class="o">*</span> <span class="n">currentContext</span> <span class="o">=</span> <span class="n">layerNode</span><span class="o">-&gt;</span><span class="n">getLayerSurface</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getCanvas</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getGrContext</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cachedContext</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">!=</span> <span class="n">currentContext</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cachedContext</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">ATRACE_NAME</span><span class="p">(</span><span class="s">"flush layers (context changed)"</span><span class="p">);</span>
                <span class="n">cachedContext</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">cachedContext</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">SkSafeRef</span><span class="p">(</span><span class="n">currentContext</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
    <span class="n">cachedContext</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RenderNodeDrawable</span><span class="o">::</span><span class="n">forceDraw</span><span class="p">(</span><span class="n">SkCanvas</span><span class="o">*</span> <span class="n">canvas</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">RenderNodeDrawable</span><span class="o">::</span><span class="n">drawContent</span><span class="p">(</span><span class="n">SkCanvas</span><span class="o">*</span> <span class="n">canvas</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">// displayList 是 layerNode 的，canvas 是 layerNode 对应的 layer surface 的</span>
    <span class="c1">// 下面看看这个由 layer surface 作为 backend 的 canvas 做了什么</span>
    <span class="n">displayList</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="n">canvas</span><span class="p">);</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>RenderNode → mSkiaLayer → layerSurface，这里我们接触到 <code class="language-plaintext highlighter-rouge">RenderNode</code> 的一个属性/概念 layer</p><p>它是 <code class="language-plaintext highlighter-rouge">SkiaLayer</code> 结构体，主要包含一个 <code class="language-plaintext highlighter-rouge">layerSurface</code>，它是一个 offscreen render target，backend 可以是纹理、pixels buffer 等</p><p>它在 <code class="language-plaintext highlighter-rouge">SkiaPipeline::createOrUpdateLayer</code> 里通过 <code class="language-plaintext highlighter-rouge">RenderNode::setLayerSurface</code> 被赋予 <code class="language-plaintext highlighter-rouge">SkSurface_Gpu</code>；那么上面的 canvas 则是以 <code class="language-plaintext highlighter-rouge">SkGpuDevice</code> 为 backend 的 <code class="language-plaintext highlighter-rouge">SkCanvas</code>，所有的 draw 操作（onDrawXXX）都被重定向到 <code class="language-plaintext highlighter-rouge">SkGpuDevice</code>（drawXXX）；而在 <code class="language-plaintext highlighter-rouge">SkGpuDevice</code> 里，draw 操作又被重定向到 <code class="language-plaintext highlighter-rouge">GrRenderTargetContext</code>；在 <code class="language-plaintext highlighter-rouge">GrRenderTargetContext</code> 里，draw 操作被封装为 <code class="language-plaintext highlighter-rouge">GrDrawOp</code>，通过 <code class="language-plaintext highlighter-rouge">GrOpsTask::addDrawOp</code> 加入到 <code class="language-plaintext highlighter-rouge">GrRenderTargetContext::fOpsTask</code>；而 <code class="language-plaintext highlighter-rouge">GrRenderTargetContext::fOpsTask</code> 会被 <code class="language-plaintext highlighter-rouge">GrDrawingManager::fDAG</code> 持有</p><p>drawing op 在这里被再次包装，由 <code class="language-plaintext highlighter-rouge">DisplayList</code> 包装为 <code class="language-plaintext highlighter-rouge">GrDrawOp</code></p><p><code class="language-plaintext highlighter-rouge">RenderNode</code> 的 <code class="language-plaintext highlighter-rouge">DisplayList</code> 会被渲染到 layer 上</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="cm">/**
 * Call to ensure all drawing to the context has been issued to the underlying 3D API.
 */</span>
<span class="kt">void</span> <span class="n">GrContext</span><span class="o">::</span><span class="n">flush</span><span class="p">()</span>

<span class="n">GrSemaphoresSubmitted</span> <span class="n">GrContext</span><span class="o">::</span><span class="n">flush</span><span class="p">(</span><span class="k">const</span> <span class="n">GrFlushInfo</span><span class="o">&amp;</span> <span class="n">info</span><span class="p">,</span> <span class="k">const</span> <span class="n">GrPrepareForExternalIORequests</span><span class="o">&amp;</span> <span class="n">externalRequests</span><span class="p">)</span>

<span class="n">GrSemaphoresSubmitted</span> <span class="n">GrDrawingManager</span><span class="o">::</span><span class="n">flush</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">auto</span> <span class="n">direct</span> <span class="o">=</span> <span class="n">fContext</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">().</span><span class="n">asDirectContext</span><span class="p">();</span>
    <span class="n">GrGpu</span><span class="o">*</span> <span class="n">gpu</span> <span class="o">=</span> <span class="n">direct</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">().</span><span class="n">getGpu</span><span class="p">();</span>
    <span class="n">fFlushing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">resourceProvider</span> <span class="o">=</span> <span class="n">direct</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">().</span><span class="n">resourceProvider</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">resourceCache</span> <span class="o">=</span> <span class="n">direct</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">().</span><span class="n">getResourceCache</span><span class="p">();</span>
    <span class="n">GrOpFlushState</span> <span class="n">flushState</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="n">resourceProvider</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fTokenTracker</span><span class="p">,</span> <span class="n">fCpuBufferCache</span><span class="p">);</span>
    <span class="n">GrOnFlushResourceProvider</span> <span class="n">onFlushProvider</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="kt">int</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">stopIndex</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">flushed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">alloc</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">startIndex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stopIndex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">executeRenderTasks</span><span class="p">(</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">stopIndex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flushState</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numRenderTasksExecuted</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">flushed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">fDAG</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">clearDDLTargets</span><span class="p">();</span>
    <span class="n">GrSemaphoresSubmitted</span> <span class="n">result</span> <span class="o">=</span> <span class="n">gpu</span><span class="o">-&gt;</span><span class="n">finishFlush</span><span class="p">(</span><span class="n">proxies</span><span class="p">,</span> <span class="n">numProxies</span><span class="p">,</span> <span class="n">access</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">externalRequests</span><span class="p">);</span>
    <span class="c1">// Give the cache a chance to purge resources that become purgeable due to flushing.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flushed</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">resourceCache</span><span class="o">-&gt;</span><span class="n">purgeAsNeeded</span><span class="p">();</span>
        <span class="n">flushed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">GrOnFlushCallbackObject</span><span class="o">*</span> <span class="n">onFlushCBObject</span> <span class="o">:</span> <span class="n">fOnFlushCBObjects</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">onFlushCBObject</span><span class="o">-&gt;</span><span class="n">postFlush</span><span class="p">(</span><span class="n">fTokenTracker</span><span class="p">.</span><span class="n">nextTokenToFlush</span><span class="p">(),</span> <span class="n">fFlushingRenderTaskIDs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
                                   <span class="n">fFlushingRenderTaskIDs</span><span class="p">.</span><span class="n">count</span><span class="p">());</span>
        <span class="n">flushed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flushed</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">resourceCache</span><span class="o">-&gt;</span><span class="n">purgeAsNeeded</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">fFlushingRenderTaskIDs</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
    <span class="n">fFlushing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">GrDrawingManager</span><span class="o">::</span><span class="n">executeRenderTasks</span><span class="p">(</span><span class="kt">int</span> <span class="n">startIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stopIndex</span><span class="p">,</span> <span class="n">GrOpFlushState</span><span class="o">*</span> <span class="n">flushState</span><span class="p">,</span>
                                          <span class="kt">int</span><span class="o">*</span> <span class="n">numRenderTasksExecuted</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SkASSERT</span><span class="p">(</span><span class="n">startIndex</span> <span class="o">&lt;=</span> <span class="n">stopIndex</span> <span class="o">&amp;&amp;</span> <span class="n">stopIndex</span> <span class="o">&lt;=</span> <span class="n">fDAG</span><span class="p">.</span><span class="n">numRenderTasks</span><span class="p">());</span>

<span class="cp">#if GR_FLUSH_TIME_OP_SPEW
</span>    <span class="n">SkDebugf</span><span class="p">(</span><span class="s">"Flushing opsTask: %d to %d out of [%d, %d]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">stopIndex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fDAG</span><span class="p">.</span><span class="n">numRenderTasks</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startIndex</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stopIndex</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fDAG</span><span class="p">.</span><span class="n">renderTask</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">fDAG</span><span class="p">.</span><span class="n">renderTask</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="cp">#endif
</span>
    <span class="kt">bool</span> <span class="n">anyRenderTasksExecuted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startIndex</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stopIndex</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">GrRenderTask</span><span class="o">*</span> <span class="n">renderTask</span> <span class="o">=</span> <span class="n">fDAG</span><span class="p">.</span><span class="n">renderTask</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">renderTask</span> <span class="o">||</span> <span class="o">!</span><span class="n">renderTask</span><span class="o">-&gt;</span><span class="n">isInstantiated</span><span class="p">())</span> <span class="p">{</span>
             <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">SkASSERT</span><span class="p">(</span><span class="n">renderTask</span><span class="o">-&gt;</span><span class="n">deferredProxiesAreInstantiated</span><span class="p">());</span>
        <span class="n">renderTask</span><span class="o">-&gt;</span><span class="n">prepare</span><span class="p">(</span><span class="n">flushState</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Upload all data to the GPU</span>
    <span class="n">flushState</span><span class="o">-&gt;</span><span class="n">preExecuteDraws</span><span class="p">();</span>

    <span class="c1">// For Vulkan, if we have too many oplists to be flushed we end up allocating a lot of resources</span>
    <span class="c1">// for each command buffer associated with the oplists. If this gets too large we can cause the</span>
    <span class="c1">// devices to go OOM. In practice we usually only hit this case in our tests, but to be safe we</span>
    <span class="c1">// put a cap on the number of oplists we will execute before flushing to the GPU to relieve some</span>
    <span class="c1">// memory pressure.</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">kMaxRenderTasksBeforeFlush</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

    <span class="c1">// Execute the onFlush renderTasks first, if any.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">sk_sp</span><span class="o">&lt;</span><span class="n">GrRenderTask</span><span class="o">&gt;&amp;</span> <span class="n">onFlushRenderTask</span> <span class="o">:</span> <span class="n">fOnFlushRenderTasks</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">onFlushRenderTask</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">flushState</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">SkDebugf</span><span class="p">(</span><span class="s">"WARNING: onFlushRenderTask failed to execute.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">SkASSERT</span><span class="p">(</span><span class="n">onFlushRenderTask</span><span class="o">-&gt;</span><span class="n">unique</span><span class="p">());</span>
        <span class="n">onFlushRenderTask</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">(</span><span class="o">*</span><span class="n">numRenderTasksExecuted</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">numRenderTasksExecuted</span> <span class="o">&gt;=</span> <span class="n">kMaxRenderTasksBeforeFlush</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">flushState</span><span class="o">-&gt;</span><span class="n">gpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">finishFlush</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SkSurface</span><span class="o">::</span><span class="n">BackendSurfaceAccess</span><span class="o">::</span><span class="n">kNoAccess</span><span class="p">,</span>
                                           <span class="n">GrFlushInfo</span><span class="p">(),</span> <span class="n">GrPrepareForExternalIORequests</span><span class="p">());</span>
            <span class="o">*</span><span class="n">numRenderTasksExecuted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">fOnFlushRenderTasks</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>

    <span class="c1">// Execute the normal op lists.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startIndex</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stopIndex</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">GrRenderTask</span><span class="o">*</span> <span class="n">renderTask</span> <span class="o">=</span> <span class="n">fDAG</span><span class="p">.</span><span class="n">renderTask</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">renderTask</span> <span class="o">||</span> <span class="o">!</span><span class="n">renderTask</span><span class="o">-&gt;</span><span class="n">isInstantiated</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">renderTask</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="n">flushState</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">anyRenderTasksExecuted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">(</span><span class="o">*</span><span class="n">numRenderTasksExecuted</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">numRenderTasksExecuted</span> <span class="o">&gt;=</span> <span class="n">kMaxRenderTasksBeforeFlush</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">flushState</span><span class="o">-&gt;</span><span class="n">gpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">finishFlush</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SkSurface</span><span class="o">::</span><span class="n">BackendSurfaceAccess</span><span class="o">::</span><span class="n">kNoAccess</span><span class="p">,</span>
                                           <span class="n">GrFlushInfo</span><span class="p">(),</span> <span class="n">GrPrepareForExternalIORequests</span><span class="p">());</span>
            <span class="o">*</span><span class="n">numRenderTasksExecuted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">SkASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">flushState</span><span class="o">-&gt;</span><span class="n">opsRenderPass</span><span class="p">());</span>
    <span class="n">SkASSERT</span><span class="p">(</span><span class="n">fTokenTracker</span><span class="p">.</span><span class="n">nextDrawToken</span><span class="p">()</span> <span class="o">==</span> <span class="n">fTokenTracker</span><span class="p">.</span><span class="n">nextTokenToFlush</span><span class="p">());</span>

    <span class="c1">// We reset the flush state before the RenderTasks so that the last resources to be freed are</span>
    <span class="c1">// those that are written to in the RenderTasks. This helps to make sure the most recently used</span>
    <span class="c1">// resources are the last to be purged by the resource cache.</span>
    <span class="n">flushState</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span>
    <span class="n">fDAG</span><span class="p">.</span><span class="n">removeRenderTasks</span><span class="p">(</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">stopIndex</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">anyRenderTasksExecuted</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最终 <code class="language-plaintext highlighter-rouge">flush</code> 将 <code class="language-plaintext highlighter-rouge">GrDrawOp</code> 转换为 opengl 命令并提交给 gpu 执行，下面看看绘制一个矩形 <code class="language-plaintext highlighter-rouge">GrFillRectOp</code> 是怎么转换为 opengl 命令的</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">SkCanvas</span><span class="o">::</span><span class="n">drawRect</span><span class="p">(</span><span class="k">const</span> <span class="n">SkRect</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="n">SkPaint</span><span class="o">&amp;</span> <span class="n">paint</span><span class="p">)</span>

<span class="kt">void</span> <span class="n">SkCanvas</span><span class="o">::</span><span class="n">onDrawRect</span><span class="p">(</span><span class="k">const</span> <span class="n">SkRect</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="n">SkPaint</span><span class="o">&amp;</span> <span class="n">paint</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">needs_autodrawlooper</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">paint</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">LOOPER_BEGIN_CHECK_COMPLETE_OVERWRITE</span><span class="p">(</span><span class="n">paint</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">iter</span><span class="p">.</span><span class="n">fDevice</span><span class="o">-&gt;</span><span class="n">drawRect</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">looper</span><span class="p">.</span><span class="n">paint</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="n">LOOPER_END</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">SkGpuDevice</span><span class="o">::</span><span class="n">drawRect</span><span class="p">(</span><span class="k">const</span> <span class="n">SkRect</span><span class="o">&amp;</span> <span class="n">rect</span><span class="p">,</span> <span class="k">const</span> <span class="n">SkPaint</span><span class="o">&amp;</span> <span class="n">paint</span><span class="p">)</span>

<span class="kt">void</span> <span class="n">GrRenderTargetContext</span><span class="o">::</span><span class="n">drawRect</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">const</span> <span class="n">SkStrokeRec</span><span class="o">&amp;</span> <span class="n">stroke</span> <span class="o">=</span> <span class="n">style</span><span class="o">-&gt;</span><span class="n">strokeRec</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">stroke</span><span class="p">.</span><span class="n">getStyle</span><span class="p">()</span> <span class="o">==</span> <span class="n">SkStrokeRec</span><span class="o">::</span><span class="n">kFill_Style</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">drawFilledRect</span><span class="p">(</span><span class="n">clip</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">paint</span><span class="p">),</span> <span class="n">aa</span><span class="p">,</span> <span class="n">viewMatrix</span><span class="p">,</span> <span class="n">rect</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">GrRenderTargetContext</span><span class="o">::</span><span class="n">drawFilledRect</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">GrAAType</span> <span class="n">aaType</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">chooseAAType</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">GrAllowMixedSamples</span><span class="o">::</span><span class="n">kNo</span><span class="p">);</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">addDrawOp</span><span class="p">(</span><span class="n">clip</span><span class="p">,</span> <span class="n">GrFillRectOp</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="n">fContext</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">paint</span><span class="p">),</span> <span class="n">aaType</span><span class="p">,</span> <span class="n">viewMatrix</span><span class="p">,</span>
                                             <span class="n">croppedRect</span><span class="p">,</span> <span class="n">ss</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>看看 <code class="language-plaintext highlighter-rouge">GrFillRectOp</code> 的定义</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">GrDrawOp</span><span class="o">&gt;</span> <span class="n">GrFillRectOp</span><span class="o">::</span><span class="n">Make</span><span class="p">(...)</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">GrDrawOp</span><span class="o">&gt;</span> <span class="n">Make</span><span class="p">(...)</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Op</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">OpArgs</span><span class="p">&gt;</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">GrDrawOp</span><span class="o">&gt;</span> <span class="n">FactoryHelper</span><span class="p">(</span><span class="n">GrRecordingContext</span><span class="o">*</span> <span class="n">context</span><span class="p">,</span> <span class="n">GrPaint</span><span class="o">&amp;&amp;</span> <span class="n">paint</span><span class="p">,</span> <span class="n">OpArgs</span><span class="p">...</span> <span class="n">opArgs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">GrSimpleMeshDrawOpHelper</span><span class="o">::</span><span class="n">FactoryHelper</span><span class="o">&lt;</span><span class="n">Op</span><span class="p">,</span> <span class="n">OpArgs</span><span class="p">...</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">paint</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">OpArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">opArgs</span><span class="p">)...);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Op</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">OpArgs</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">GrDrawOp</span><span class="o">&gt;</span> <span class="n">GrSimpleMeshDrawOpHelper</span><span class="o">::</span><span class="n">FactoryHelper</span><span class="p">(</span><span class="n">GrRecordingContext</span><span class="o">*</span> <span class="n">context</span><span class="p">,</span>
                                                                  <span class="n">GrPaint</span><span class="o">&amp;&amp;</span> <span class="n">paint</span><span class="p">,</span>
                                                                  <span class="n">OpArgs</span><span class="p">...</span> <span class="n">opArgs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GrOpMemoryPool</span><span class="o">*</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">().</span><span class="n">opMemoryPool</span><span class="p">();</span>
    <span class="n">MakeArgs</span> <span class="n">makeArgs</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">paint</span><span class="p">.</span><span class="n">isTrivial</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">makeArgs</span><span class="p">.</span><span class="n">fProcessorSet</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">allocate</span><span class="o">&lt;</span><span class="n">Op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">makeArgs</span><span class="p">,</span> <span class="n">paint</span><span class="p">.</span><span class="n">getColor4f</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">OpArgs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">opArgs</span><span class="p">)...);</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="n">FillRectOp</span><span class="p">(</span><span class="n">Helper</span><span class="o">::</span><span class="n">MakeArgs</span> <span class="n">args</span><span class="p">,</span> <span class="n">SkPMColor4f</span> <span class="n">paintColor</span><span class="p">,</span> <span class="n">GrAAType</span> <span class="n">aaType</span><span class="p">,</span>
               <span class="n">DrawQuad</span><span class="o">*</span> <span class="n">quad</span><span class="p">,</span> <span class="k">const</span> <span class="n">GrUserStencilSettings</span><span class="o">*</span> <span class="n">stencil</span><span class="p">,</span> <span class="n">Helper</span><span class="o">::</span><span class="n">InputFlags</span> <span class="n">inputFlags</span><span class="p">)</span>
            <span class="o">:</span> <span class="n">INHERITED</span><span class="p">(</span><span class="n">ClassID</span><span class="p">())</span>
            <span class="p">,</span> <span class="n">fHelper</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">aaType</span><span class="p">,</span> <span class="n">stencil</span><span class="p">,</span> <span class="n">inputFlags</span><span class="p">)</span>
            <span class="p">,</span> <span class="n">fQuads</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">!</span><span class="n">fHelper</span><span class="p">.</span><span class="n">isTrivial</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">GrRenderTargetContext</span><span class="o">::</span><span class="n">addDrawOp</span><span class="p">(</span><span class="k">const</span> <span class="n">GrClip</span><span class="o">&amp;</span> <span class="n">clip</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">GrDrawOp</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">WillAddOpFn</span><span class="o">&gt;&amp;</span> <span class="n">willAddFn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">opList</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getRTOpList</span><span class="p">();</span>
    <span class="c1">// ...</span>
    <span class="n">opList</span><span class="o">-&gt;</span><span class="n">addDrawOp</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="n">analysis</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">appliedClip</span><span class="p">),</span> <span class="n">dstProxy</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">caps</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">GrRenderTargetOpList</span><span class="o">*</span> <span class="n">GrRenderTargetContext</span><span class="o">::</span><span class="n">getRTOpList</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fOpList</span> <span class="o">||</span> <span class="n">fOpList</span><span class="o">-&gt;</span><span class="n">isClosed</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">fOpList</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">drawingManager</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">newRTOpList</span><span class="p">(</span><span class="n">fRenderTargetProxy</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">fManagedOpList</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">fOpList</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">sk_sp</span><span class="o">&lt;</span><span class="n">GrRenderTargetOpList</span><span class="o">&gt;</span> <span class="n">GrDrawingManager</span><span class="o">::</span><span class="n">newRTOpList</span><span class="p">(</span><span class="n">GrRenderTargetProxy</span><span class="o">*</span> <span class="n">rtp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">managedOpList</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">auto</span> <span class="n">resourceProvider</span> <span class="o">=</span> <span class="n">fContext</span><span class="o">-&gt;</span><span class="n">contextPriv</span><span class="p">().</span><span class="n">resourceProvider</span><span class="p">();</span>
    <span class="n">sk_sp</span><span class="o">&lt;</span><span class="n">GrRenderTargetOpList</span><span class="o">&gt;</span> <span class="n">opList</span><span class="p">(</span><span class="k">new</span> <span class="n">GrRenderTargetOpList</span><span class="p">(</span><span class="n">resourceProvider</span><span class="p">,</span> <span class="n">fContext</span><span class="o">-&gt;</span><span class="n">contextPriv</span><span class="p">().</span><span class="n">refOpMemoryPool</span><span class="p">(),</span> <span class="n">rtp</span><span class="p">,</span> <span class="n">fContext</span><span class="o">-&gt;</span><span class="n">contextPriv</span><span class="p">().</span><span class="n">getAuditTrail</span><span class="p">()));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">managedOpList</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fDAG</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">opList</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="n">opList</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">GrRenderTargetOpList</span><span class="o">::</span><span class="n">addDrawOp</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">addDependency</span> <span class="o">=</span> <span class="p">[</span> <span class="o">&amp;</span><span class="n">caps</span><span class="p">,</span> <span class="k">this</span> <span class="p">]</span> <span class="p">(</span><span class="n">GrSurfaceProxy</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">addDependency</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">caps</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="n">op</span><span class="o">-&gt;</span><span class="n">visitProxies</span><span class="p">(</span><span class="n">addDependency</span><span class="p">);</span>
    <span class="n">clip</span><span class="p">.</span><span class="n">visitProxies</span><span class="p">(</span><span class="n">addDependency</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dstProxy</span><span class="p">.</span><span class="n">proxy</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">addDependency</span><span class="p">(</span><span class="n">dstProxy</span><span class="p">.</span><span class="n">proxy</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">recordOp</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="n">processorAnalysis</span><span class="p">,</span> <span class="n">clip</span><span class="p">.</span><span class="n">doesClip</span><span class="p">()</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">clip</span> <span class="o">:</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dstProxy</span><span class="p">,</span> <span class="n">caps</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">FillRectOp</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GrMeshDrawOp</span> <span class="p">{</span>
    <span class="n">VertexSpec</span> <span class="n">vertexSpec</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">indexBufferOption</span> <span class="o">=</span> <span class="n">GrQuadPerEdgeAA</span><span class="o">::</span><span class="n">CalcIndexBufferOption</span><span class="p">(</span><span class="n">fHelper</span><span class="p">.</span><span class="n">aaType</span><span class="p">(),</span> <span class="n">fQuads</span><span class="p">.</span><span class="n">count</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">VertexSpec</span><span class="p">(</span><span class="n">fQuads</span><span class="p">.</span><span class="n">deviceQuadType</span><span class="p">(),</span> <span class="n">fColorType</span><span class="p">,</span> <span class="n">fQuads</span><span class="p">.</span><span class="n">localQuadType</span><span class="p">(),</span>
            <span class="n">fHelper</span><span class="p">.</span><span class="n">usesLocalCoords</span><span class="p">(),</span> <span class="n">GrQuadPerEdgeAA</span><span class="o">::</span><span class="n">Domain</span><span class="o">::</span><span class="n">kNo</span><span class="p">,</span>
            <span class="n">fHelper</span><span class="p">.</span><span class="n">aaType</span><span class="p">(),</span>
            <span class="n">fHelper</span><span class="p">.</span><span class="n">compatibleWithCoverageAsAlpha</span><span class="p">(),</span> <span class="n">indexBufferOption</span><span class="p">);</span>
    <span class="p">}</span>   

    <span class="kt">void</span> <span class="n">tessellate</span><span class="p">(</span><span class="k">const</span> <span class="n">VertexSpec</span><span class="o">&amp;</span> <span class="n">vertexSpec</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">dst</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">static</span> <span class="k">constexpr</span> <span class="n">SkRect</span> <span class="n">kEmptyDomain</span> <span class="o">=</span> <span class="n">SkRect</span><span class="o">::</span><span class="n">MakeEmpty</span><span class="p">();</span>
        <span class="n">GrQuadPerEdgeAA</span><span class="o">::</span><span class="n">Tessellator</span> <span class="n">tessellator</span><span class="p">(</span><span class="n">vertexSpec</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">fQuads</span><span class="p">.</span><span class="n">iterator</span><span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">info</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">metadata</span><span class="p">();</span>
            <span class="n">tessellator</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">deviceQuad</span><span class="p">(),</span> <span class="n">iter</span><span class="p">.</span><span class="n">localQuad</span><span class="p">(),</span> <span class="n">info</span><span class="p">.</span><span class="n">fColor</span><span class="p">,</span> <span class="n">kEmptyDomain</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">fAAFlags</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>   

    <span class="kt">void</span> <span class="n">onPrePrepareDraws</span><span class="p">(...)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">SkArenaAlloc</span><span class="o">*</span> <span class="n">arena</span> <span class="o">=</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">().</span><span class="n">recordTimeAllocator</span><span class="p">();</span>
        <span class="k">const</span> <span class="n">VertexSpec</span> <span class="n">vertexSpec</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">vertexSpec</span><span class="p">();</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">totalNumVertices</span> <span class="o">=</span> <span class="n">fQuads</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">*</span> <span class="n">vertexSpec</span><span class="p">.</span><span class="n">verticesPerQuad</span><span class="p">();</span>
        <span class="k">const</span> <span class="kt">size_t</span> <span class="n">totalVertexSizeInBytes</span> <span class="o">=</span> <span class="n">vertexSpec</span><span class="p">.</span><span class="n">vertexSize</span><span class="p">()</span> <span class="o">*</span> <span class="n">totalNumVertices</span><span class="p">;</span>
        <span class="n">fPrePreparedVertices</span> <span class="o">=</span> <span class="n">arena</span><span class="o">-&gt;</span><span class="n">makeArrayDefault</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">totalVertexSizeInBytes</span><span class="p">);</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">tessellate</span><span class="p">(</span><span class="n">vertexSpec</span><span class="p">,</span> <span class="n">fPrePreparedVertices</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/blog/categories/android/'>Android</a>, <a href='/blog/categories/framework/'>Framework</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/blog/tags/vsync/" class="post-tag no-text-decoration" >vsync</a> <a href="/blog/tags/render-thread/" class="post-tag no-text-decoration" >render thread</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Android 图形栈（三）render thread - Cyrus&url=https://cyruslin.com/blog/blog/posts/render-thread/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Android 图形栈（三）render thread - Cyrus&u=https://cyruslin.com/blog/blog/posts/render-thread/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Android 图形栈（三）render thread - Cyrus&url=https://cyruslin.com/blog/blog/posts/render-thread/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/posts/threadpool/">线程池 ThreadPool 的实现</a><li><a href="/blog/posts/juc-collection/">JUC 下一些线程安全的容器</a><li><a href="/blog/posts/reviews/">常见面试题备忘</a><li><a href="/blog/posts/https/">什么是 https ？</a><li><a href="/blog/posts/tcp-handshake-goodbye/">TCP 的三次握手和四次挥手</a></ul></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/posts/vsync/"><div class="card-body"> <span class="timeago small" > Dec 2, 2020 <i class="unloaded">2020-12-02T12:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Android 图形栈（一）vsync</h3><div class="text-muted small"><p> android 的垂直同步模型（vsync）是隐藏在 view 系统后面的很重要的一块，它控制着 view 渲染的节奏；而且 vsync 还是比较复杂的，我们从下到上，先从最熟悉的 View.invalidate 讲起，看看简单的一个 invalidate 后面隐藏着多么复杂的工作 从 View.invalidate() 说起 看上图，View.invalidate() 主要做了两件...</p></div></div></a></div><div class="card"> <a href="/blog/posts/ui-thread-in-vsync/"><div class="card-body"> <span class="timeago small" > Dec 13, 2020 <i class="unloaded">2020-12-13T12:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Android 图形栈（二）ui thread</h3><div class="text-muted small"><p> 从一段 systrace 开始 这是一段 systrace 记录，看得出来页面是比较流畅的，ui thread 全都在一个 VSYNC_app 内完成绘制，surfaceflinger 也在一个 VSYNC_sf 内完成各个层的合成；但有没发现在 ui thread 完成 doFrame 后，总是会有一个 ReaderThread 跟在后面，看名字像是跟渲染相关的线程，它跟 ui 绘制...</p></div></div></a></div><div class="card"> <a href="/blog/posts/how-application-being-created-and-init/"><div class="card-body"> <span class="timeago small" > Mar 2 <i class="unloaded">2021-03-02T12:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Application 是如何被创建和初始化的？</h3><div class="text-muted small"><p> 时序图 从 startActivity 开始，比如打开一个 app 的首页，当 app 未启动时就会走创建 Application 这条路 AMS 承担的工作 其中的转折点在 resumeTopActivityInnerLocked，发现 app process 不存在，走启动 app process 的流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/posts/ui-thread-in-vsync/" class="btn btn-outline-primary" prompt="Older"><p>Android 图形栈（二）ui thread</p></a> <a href="/blog/posts/aqs-basic/" class="btn btn-outline-primary" prompt="Newer"><p>Lock（一）AQS 基础</p></a></div></div></div></div></div></div>
