<!DOCTYPE html><html lang="zh-CN" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Android 图形栈（一）vsync" /><meta name="author" content="Cyrus" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="android 的垂直同步模型（vsync）是隐藏在 view 系统后面的很重要的一块，它控制着 view 渲染的节奏；而且 vsync 还是比较复杂的，我们从下到上，先从最熟悉的 View.invalidate 讲起，看看简单的一个 invalidate 后面隐藏着多么复杂的工作" /><meta property="og:description" content="android 的垂直同步模型（vsync）是隐藏在 view 系统后面的很重要的一块，它控制着 view 渲染的节奏；而且 vsync 还是比较复杂的，我们从下到上，先从最熟悉的 View.invalidate 讲起，看看简单的一个 invalidate 后面隐藏着多么复杂的工作" /><link rel="canonical" href="https://cyruslin.com/blog/blog/posts/vsync/" /><meta property="og:url" content="https://cyruslin.com/blog/blog/posts/vsync/" /><meta property="og:site_name" content="Cyrus" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-12-02T12:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Android 图形栈（一）vsync" /><meta name="twitter:site" content="@magicboy_linw" /><meta name="twitter:creator" content="@Cyrus" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"headline":"Android 图形栈（一）vsync","dateModified":"2021-03-22T10:45:38+08:00","datePublished":"2020-12-02T12:00:00+08:00","description":"android 的垂直同步模型（vsync）是隐藏在 view 系统后面的很重要的一块，它控制着 view 渲染的节奏；而且 vsync 还是比较复杂的，我们从下到上，先从最熟悉的 View.invalidate 讲起，看看简单的一个 invalidate 后面隐藏着多么复杂的工作","url":"https://cyruslin.com/blog/blog/posts/vsync/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://cyruslin.com/blog/blog/posts/vsync/"},"author":{"@type":"Person","name":"Cyrus"},"@context":"https://schema.org"}</script><title>Android 图形栈（一）vsync | Cyrus</title><link rel="shortcut icon" href="/blog/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/blog/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/blog/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/blog/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/blog/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/blog/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/blog/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/blog/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/blog/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/blog/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/blog/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/blog/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/blog/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/blog/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/blog/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/blog/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/blog/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/blog/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/blog/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/blog/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/blog/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/blog/assets/js/dist/post.min.js"></script> <script defer src="/blog/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="main-wrapper" style="margin-left: 0px;"><div id="main"><div class="row" style="padding-left: 0px;"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8" style="max-width: 75%;margin-top: 0rem;padding-left: 0.5rem;"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Android 图形栈（一）vsync</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 2, 2020, 12:00 PM +0800" > Dec 2, 2020 <i class="unloaded">2020-12-02T12:00:00+08:00</i> </span> by <span class="author"> Cyrus </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Mar 22, 2021, 10:45 AM +0800" > Mar 22 <i class="unloaded">2021-03-22T10:45:38+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3756 words">20 min</span></div></div><div class="post-content"><p>android 的垂直同步模型（vsync）是隐藏在 view 系统后面的很重要的一块，它控制着 view 渲染的节奏；而且 vsync 还是比较复杂的，我们从下到上，先从最熟悉的 <code class="language-plaintext highlighter-rouge">View.invalidate</code> 讲起，看看简单的一个 <code class="language-plaintext highlighter-rouge">invalidate</code> 后面隐藏着多么复杂的工作</p><h2 id="从-viewinvalidate-说起">从 <code class="language-plaintext highlighter-rouge">View.invalidate()</code> 说起</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/blog/assets/2020-12-02-vsync/invalidate.jpg" alt="invalidate.jpg" /></p><p>看上图，<code class="language-plaintext highlighter-rouge">View.invalidate()</code> 主要做了两件事：</p><ol><li>将 <code class="language-plaintext highlighter-rouge">ViewRootImpl.doTraversal()</code> 加入到 <code class="language-plaintext highlighter-rouge">Choreographer</code> 的任务列表里，等待下一次 vsync 信号到来时执行；<code class="language-plaintext highlighter-rouge">doTraversal()</code>主要执行 view tree 的三个重要方法：measure、layout 和 draw；<code class="language-plaintext highlighter-rouge">Choreographer</code>则是在一次 vsync 信号到来时，依次执行 <code class="language-plaintext highlighter-rouge">INPUT</code>，<code class="language-plaintext highlighter-rouge">ANIMATION</code> 和 <code class="language-plaintext highlighter-rouge">TRAVERSAL</code> 这三个类别的任务；也就是说 view tree 的渲染和 input 的处理都是从 vsync 到来时开始的，而且此时会开启同步栅栏，屏蔽非 ui 任务（用户任务），集中力量在下一次的 vsync 到来前完成一帧的渲染<li>唤醒 <code class="language-plaintext highlighter-rouge">EventThread</code> 去看看有没 vsync 信号的到来；<code class="language-plaintext highlighter-rouge">EventThread</code> 看名字就知道是一个线程，看它的 loop 流程，是将 <code class="language-plaintext highlighter-rouge">mPendingEvents</code> 分发给 consumer，那么我们可以猜想下，event 也许包含了 vsync，而 consumer 很有可能最终走到 <code class="language-plaintext highlighter-rouge">Choreographer.doFrame</code>里触发 view tree 的绘制</ol><p>按照从下到上追踪法，下一步就是看看是谁在什么时候把 event 放到 <code class="language-plaintext highlighter-rouge">mPendingEvents</code> 里，但这里我选择掉转方向盘，先从 surfaceflinger 讲起</p><p>继续之前，我们得先了解几个跟硬件有关的概念</p><h2 id="halhardware-abstract-layer硬件抽象层">HAL，Hardware Abstract Layer，硬件抽象层</h2><p>看名字就知道这是跟硬件、设备相关的东西，应该是最贴近硬件的那一层软件，我没有做过相关的开发，但是结合 google 和这两篇文章：<a href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a>，<a href="https://blog.csdn.net/qq_19923217/article/details/88398660">Android HIDL HAL 接口定义语言详解</a>，我大概了解了它是干什么的，我说说我的理解：</p><ul><li>它用接口的方式定义协议，而协议则定义了组件间的沟通规范；Android app 开发其实也就这个概念，就是各个业务、基础能力的 interface；我做过 java web 开发，所以对这个概念比较熟悉；整个 java web 是由很多协议构成的：Servlet、JSP、JDBC 等，sun 给出包含这些协议 interface 的 jar 包出来（它自己也可能会给出一个默认实现比如 glassfish），各个厂商给出自己对协议的实现如：Tomcat、Jboss、Resin 等；而 web app 开发者只需根据协议 jar 包开发业务，部署时根据条件可以放在各种厂商的容器上<li>HAL 也是这个道理，android HWC HAL 定义了各种 interface（在 <code class="language-plaintext highlighter-rouge">hardware/interfaces/graphics/composer/2.1/</code> 目录下），各个厂商需要实现这些接口并给出 so 文件；打包 android image 的时候，根据硬件设备挑选合适的 HAL 实现，把 so 文件放到镜像里；而 android framework 开发者只需根据 HAL 接口进行业务开发即可，无需关心实现细节</ul><h2 id="hidlhal-interface-definition-languagehal-接口定义语言">HIDL，HAL Interface Definition Language，HAL 接口定义语言</h2><p>看名字好像跟 AIDL 有点渊源啊，对的，它是 HAL 的代码生成器；具体怎么用我们了解下即可：<a href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a>，<a href="https://blog.csdn.net/qq_19923217/article/details/88398660">Android HIDL HAL 接口定义语言详解</a>，<a href="https://blog.csdn.net/qq_19923217/article/details/89173162">Android HIDL 之 hal 进程启动及服务注册过程</a></p><p>总结下关键点：</p><ul><li>各个 HAL 是独立进程的（看看 <code class="language-plaintext highlighter-rouge">hardware/interfaces/graphics/composer/2.1/default/</code> 是怎么启动 HWC 进程并加载厂商 so 库的），surfaceflinger 进程通过 binder 与 HWC 进程通讯（也就是 C/S 架构，HWC 是 server，surfaceflinger 是 client）<li>HWC 将服务注册到 <code class="language-plaintext highlighter-rouge">hwservicemanager</code>，surfaceflinger 从 <code class="language-plaintext highlighter-rouge">hwservicemanager</code> 获取 composer 服务<li>所以用从下到上的方法找调用栈的时候会发现，onVsync 方法找不到调用的地方，那是因为发送 vsync 信号的代码是厂商代码（framework 提供 callback interface），不在 aosp 里面</ul><h2 id="hwc硬件图层合成器">HWC，硬件图层合成器</h2><p><a href="https://www.jianshu.com/p/944d2fb9cead">Android图形系统系统篇之HWC</a> 这里也介绍了，它是一个合成多个图层的组件（原来状态栏、导航栏、壁纸、app 等不是一起渲染，而是独自渲染最后合成为屏幕内容的），这里只关心它会发出 vsync 信号</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/blog/assets/2020-12-02-vsync/vsync_flow.jpg" alt="vsync_flow.jpg" /></p><p>我们先理解这张图，屏幕（硬件）发出 vsync 信号（就是上图的 HW_VSYNC），经过软件的一系列的调整生成 SW_VSYNC，然后输出到两路：</p><ol><li><code class="language-plaintext highlighter-rouge">SF_VSYNC</code>，输出到 surfaceflinger<li><code class="language-plaintext highlighter-rouge">APP_VSYNC</code>，输出到 app</ol><h2 id="hw_vsync---硬件垂直同步信号">HW_VSYNC - 硬件垂直同步信号</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/blog/assets/2020-12-02-vsync/hw_vsync.jpg" alt="hw_vsync.jpg" /></p><p>surfaceflinger 是一个很重要的服务进程，它跟图像和显示有关，源码在 <code class="language-plaintext highlighter-rouge">/frameworks/native/services/surfaceflinger</code>；目录下有个编译配置文件 <code class="language-plaintext highlighter-rouge">Android.bp</code> ，看下它的内容，它输出了可执行文件 surfaceflinger、共享库 libsurfaceflinger.so 和 libSurfaceFlingerProp.so；然后有个 <code class="language-plaintext highlighter-rouge">surfaceflinger.rc</code>，它是一个启动配置文件，意味着 surfaceflinger 会在系统启动后被 init 进程启动为服务进程，看下里面的内容，可执行文件是 <code class="language-plaintext highlighter-rouge">/system/bin/surfaceflinger</code>，<code class="language-plaintext highlighter-rouge">main</code> 函数入口在 main_surfaceflinger.cpp</p><p>从上图可以看到 surfaceflinger 进程启动后，会查找 HWC server 并注册 callback，当设备发出 hw_vsync 时，<code class="language-plaintext highlighter-rouge">SurfaceFlinger.onVsyncReceived</code> 被执行，看上面那张图，hw_vsync 不是直接被使用，而是被调整转换为 sw_vsync，也就是 <code class="language-plaintext highlighter-rouge">DispSync.addResyncSample</code></p><h2 id="sw_vsync---软件垂直同步信号">SW_VSYNC - 软件垂直同步信号</h2><p><code class="language-plaintext highlighter-rouge">DispSyncThread</code> 和 <code class="language-plaintext highlighter-rouge">DispSync</code> 收集 HW_VSYNC，计算并输出 SW_VSYNC；主循环是 <code class="language-plaintext highlighter-rouge">DispSyncThread.threadLoop()</code>，但在分析 main loop 之前，我们需要先了解 <code class="language-plaintext highlighter-rouge">DispSync</code> 几个重要的属性（参考<a href="https://www.jianshu.com/p/d3e4b1805c92">「Android SurfaceFlinger SW Vsync模型」</a>）</p><p><code class="language-plaintext highlighter-rouge">mResyncSamples</code> 数组 - 通过上面的分析我们知道 <code class="language-plaintext highlighter-rouge">addResyncSample</code> 把 HW_VSYNC 加入 <code class="language-plaintext highlighter-rouge">DispSync</code>，但 <code class="language-plaintext highlighter-rouge">mResyncSamples</code> 只会保留最新的 32 个以供后续计算；它是个首尾相连、环状的循环列表，容量为 32</p><p><code class="language-plaintext highlighter-rouge">mPeriod</code> - 两个 HW_VSYNC 之间的时间间隔，相当于刷新率，我们看下它是怎么计算的</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">DispSync</span><span class="o">::</span><span class="n">updateModelLocked</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ALOGV</span><span class="p">(</span><span class="s">"[%s] updateModelLocked %zu"</span><span class="p">,</span> <span class="n">mName</span><span class="p">,</span> <span class="n">mNumResyncSamples</span><span class="p">);</span>
    <span class="c1">// 只有收集到足够多（≥ 6）的 HW_VSYNC 才去计算刷新率（以及其他参数）</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mNumResyncSamples</span> <span class="o">&gt;=</span> <span class="n">MIN_RESYNC_SAMPLES_FOR_UPDATE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ALOGV</span><span class="p">(</span><span class="s">"[%s] Computing..."</span><span class="p">,</span> <span class="n">mName</span><span class="p">);</span>
        <span class="n">nsecs_t</span> <span class="n">durationSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">nsecs_t</span> <span class="n">minDuration</span> <span class="o">=</span> <span class="n">INT64_MAX</span><span class="p">;</span>
        <span class="n">nsecs_t</span> <span class="n">maxDuration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// We skip the first 2 samples because the first vsync duration on some</span>
        <span class="c1">// devices may be much more inaccurate than on other devices, e.g. due</span>
        <span class="c1">// to delays in ramping up from a power collapse. By doing so this</span>
        <span class="c1">// actually increases the accuracy of the DispSync model even though</span>
        <span class="c1">// we're effectively relying on fewer sample points.</span>

        <span class="c1">// 把收集到的 HW_VSYNC 时间间隔去掉前两个，去掉最大值和最小值，剩下的求平均值</span>
        <span class="c1">// 这就算出了硬件的刷新率，它是计算出来的一个平均值，因为 HW_VSYNC 速率极可能是会变动的</span>
        <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">numSamplesSkipped</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">numSamplesSkipped</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mNumResyncSamples</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">mFirstResyncSample</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_RESYNC_SAMPLES</span><span class="p">;</span>
            <span class="kt">size_t</span> <span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">MAX_RESYNC_SAMPLES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_RESYNC_SAMPLES</span><span class="p">;</span>
            <span class="n">nsecs_t</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">mResyncSamples</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">mResyncSamples</span><span class="p">[</span><span class="n">prev</span><span class="p">];</span>
            <span class="n">durationSum</span> <span class="o">+=</span> <span class="n">duration</span><span class="p">;</span>
            <span class="n">minDuration</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">minDuration</span><span class="p">,</span> <span class="n">duration</span><span class="p">);</span>
            <span class="n">maxDuration</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxDuration</span><span class="p">,</span> <span class="n">duration</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Exclude the min and max from the average</span>
        <span class="n">durationSum</span> <span class="o">-=</span> <span class="n">minDuration</span> <span class="o">+</span> <span class="n">maxDuration</span><span class="p">;</span>
        <span class="n">mPeriod</span> <span class="o">=</span> <span class="n">durationSum</span> <span class="o">/</span> <span class="p">(</span><span class="n">mNumResyncSamples</span> <span class="o">-</span> <span class="n">numSamplesSkipped</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">mPhase</code> - <code class="language-plaintext highlighter-rouge">mPeriod</code> 的偏差值；我们知道 <code class="language-plaintext highlighter-rouge">mPeriod</code> 是一个计算出来的平均值，而且还去除了一些噪音（极大值、极小值等），那么它与真实的 HW_VSYNC 之间必定会有偏差，<code class="language-plaintext highlighter-rouge">mPhase</code> 就是这个平均偏差（要从数学理论上去理解）；这里不深入细节了</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">DispSync</span><span class="o">::</span><span class="n">updateModelLocked</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ALOGV</span><span class="p">(</span><span class="s">"[%s] updateModelLocked %zu"</span><span class="p">,</span> <span class="n">mName</span><span class="p">,</span> <span class="n">mNumResyncSamples</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mNumResyncSamples</span> <span class="o">&gt;=</span> <span class="n">MIN_RESYNC_SAMPLES_FOR_UPDATE</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="kt">double</span> <span class="n">sampleAvgX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">sampleAvgY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">scale</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">M_PI</span> <span class="o">/</span> <span class="kt">double</span><span class="p">(</span><span class="n">mPeriod</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">numSamplesSkipped</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mNumResyncSamples</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">mFirstResyncSample</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_RESYNC_SAMPLES</span><span class="p">;</span>
            <span class="n">nsecs_t</span> <span class="n">sample</span> <span class="o">=</span> <span class="n">mResyncSamples</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">mReferenceTime</span><span class="p">;</span>
            <span class="kt">double</span> <span class="n">samplePhase</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="n">sample</span> <span class="o">%</span> <span class="n">mPeriod</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
            <span class="n">sampleAvgX</span> <span class="o">+=</span> <span class="n">cos</span><span class="p">(</span><span class="n">samplePhase</span><span class="p">);</span>
            <span class="n">sampleAvgY</span> <span class="o">+=</span> <span class="n">sin</span><span class="p">(</span><span class="n">samplePhase</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">sampleAvgX</span> <span class="o">/=</span> <span class="kt">double</span><span class="p">(</span><span class="n">mNumResyncSamples</span> <span class="o">-</span> <span class="n">numSamplesSkipped</span><span class="p">);</span>
        <span class="n">sampleAvgY</span> <span class="o">/=</span> <span class="kt">double</span><span class="p">(</span><span class="n">mNumResyncSamples</span> <span class="o">-</span> <span class="n">numSamplesSkipped</span><span class="p">);</span>

        <span class="n">mPhase</span> <span class="o">=</span> <span class="n">nsecs_t</span><span class="p">(</span><span class="n">atan2</span><span class="p">(</span><span class="n">sampleAvgY</span><span class="p">,</span> <span class="n">sampleAvgX</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span><span class="p">);</span>

        <span class="n">ALOGV</span><span class="p">(</span><span class="s">"[%s] mPhase = %"</span> <span class="n">PRId64</span><span class="p">,</span> <span class="n">mName</span><span class="p">,</span> <span class="n">ns2us</span><span class="p">(</span><span class="n">mPhase</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">mPhase</span> <span class="o">&lt;</span> <span class="o">-</span><span class="p">(</span><span class="n">mPeriod</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">mPhase</span> <span class="o">+=</span> <span class="n">mPeriod</span><span class="p">;</span>
            <span class="n">ALOGV</span><span class="p">(</span><span class="s">"[%s] Adjusting mPhase -&gt; %"</span> <span class="n">PRId64</span><span class="p">,</span> <span class="n">mName</span><span class="p">,</span> <span class="n">ns2us</span><span class="p">(</span><span class="n">mPhase</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">// Artificially inflate the period if requested.</span>
        <span class="n">mPeriod</span> <span class="o">+=</span> <span class="n">mPeriod</span> <span class="o">*</span> <span class="n">mRefreshSkipCount</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">mReferenceTime</code>，这个最新那个 HW_VSYNC 的时间，每次计算下一个 SW_VSYNC 时都是以该时间作为基准，这样可以减少误差。如果每一个 SW_VSYNC 都以上一个 SW_VSYNC 作为基准，那误差就会不停的累加；而如果以第一个 HW_VSYNC 作基准，那每次 SW_VSYNC 误差是不会累加的</p><p>现在我们看下 main loop</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">threadLoop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">status_t</span> <span class="n">err</span><span class="p">;</span>
    <span class="n">nsecs_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">systemTime</span><span class="p">(</span><span class="n">SYSTEM_TIME_MONOTONIC</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CallbackInvocation</span><span class="o">&gt;</span> <span class="n">callbackInvocations</span><span class="p">;</span>
        <span class="n">nsecs_t</span> <span class="n">targetTime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">{</span> <span class="c1">// Scope for lock</span>
            <span class="n">Mutex</span><span class="o">::</span><span class="n">Autolock</span> <span class="n">lock</span><span class="p">(</span><span class="n">mMutex</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mTraceDetailedInfo</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ATRACE_INT64</span><span class="p">(</span><span class="s">"DispSync:Frame"</span><span class="p">,</span> <span class="n">mFrameNumber</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">ALOGV</span><span class="p">(</span><span class="s">"[%s] Frame %"</span> <span class="n">PRId64</span><span class="p">,</span> <span class="n">mName</span><span class="p">,</span> <span class="n">mFrameNumber</span><span class="p">);</span>
            <span class="o">++</span><span class="n">mFrameNumber</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mStop</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 收集到足够多的 HW_VSYNC 算出刷新率后，才计算 SW_VSYNC，否则 wait</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mPeriod</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">mCond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">mMutex</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">ALOGE</span><span class="p">(</span><span class="s">"error waiting for new events: %s (%d)"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">err</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// computeNextEventTimeLocked 这个方法很重要，我们知道随着 HW_VSYNC 样本的不断更新，</span>
            <span class="c1">// mPeriod、mPhase 和 mReferenceTime 也跟着轻微变动，上一次的 SW_VSYNC 是根据上一次的参数算出来的</span>
            <span class="c1">// 下一次的 SW_VSYNC 则在上次时间戳的基础上重新计算</span>
            <span class="n">targetTime</span> <span class="o">=</span> <span class="n">computeNextEventTimeLocked</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>

            <span class="c1">// 没到时间则 wait</span>
            <span class="kt">bool</span> <span class="n">isWakeup</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">&lt;</span> <span class="n">targetTime</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mTraceDetailedInfo</span><span class="p">)</span> <span class="n">ATRACE_NAME</span><span class="p">(</span><span class="s">"DispSync waiting"</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">targetTime</span> <span class="o">==</span> <span class="n">INT64_MAX</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">ALOGV</span><span class="p">(</span><span class="s">"[%s] Waiting forever"</span><span class="p">,</span> <span class="n">mName</span><span class="p">);</span>
                    <span class="n">err</span> <span class="o">=</span> <span class="n">mCond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">mMutex</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">ALOGV</span><span class="p">(</span><span class="s">"[%s] Waiting until %"</span> <span class="n">PRId64</span><span class="p">,</span> <span class="n">mName</span><span class="p">,</span> <span class="n">ns2us</span><span class="p">(</span><span class="n">targetTime</span><span class="p">));</span>
                    <span class="n">err</span> <span class="o">=</span> <span class="n">mCond</span><span class="p">.</span><span class="n">waitRelative</span><span class="p">(</span><span class="n">mMutex</span><span class="p">,</span> <span class="n">targetTime</span> <span class="o">-</span> <span class="n">now</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">TIMED_OUT</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">isWakeup</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">ALOGE</span><span class="p">(</span><span class="s">"error waiting for next event: %s (%d)"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">err</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">systemTime</span><span class="p">(</span><span class="n">SYSTEM_TIME_MONOTONIC</span><span class="p">);</span>
            <span class="c1">// Don't correct by more than 1.5 ms</span>
            <span class="k">static</span> <span class="k">const</span> <span class="n">nsecs_t</span> <span class="n">kMaxWakeupLatency</span> <span class="o">=</span> <span class="n">us2ns</span><span class="p">(</span><span class="mi">1500</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">isWakeup</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">mWakeupLatency</span> <span class="o">=</span> <span class="p">((</span><span class="n">mWakeupLatency</span> <span class="o">*</span> <span class="mi">63</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">targetTime</span><span class="p">))</span> <span class="o">/</span> <span class="mi">64</span><span class="p">;</span>
                <span class="n">mWakeupLatency</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">mWakeupLatency</span><span class="p">,</span> <span class="n">kMaxWakeupLatency</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mTraceDetailedInfo</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">ATRACE_INT64</span><span class="p">(</span><span class="s">"DispSync:WakeupLat"</span><span class="p">,</span> <span class="n">now</span> <span class="o">-</span> <span class="n">targetTime</span><span class="p">);</span>
                    <span class="n">ATRACE_INT64</span><span class="p">(</span><span class="s">"DispSync:AvgWakeupLat"</span><span class="p">,</span> <span class="n">mWakeupLatency</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// 发送时，再次计算发送时间，只有此时到达发送时间的才发送（时间算得很精确）</span>
            <span class="n">callbackInvocations</span> <span class="o">=</span> <span class="n">gatherCallbackInvocationsLocked</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">callbackInvocations</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fireCallbackInvocations</span><span class="p">(</span><span class="n">callbackInvocations</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>总的来说，SW_VSYNC 它去除了噪音，而且用过去 32 个 HW_VSYNC 样本的平均值作刷新率，对比 HW_VSYNC 显得平滑了很多</p><p>那谁接收 SW_VSYNC？</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">SurfaceFlinger</span><span class="o">::</span><span class="n">initScheduler</span><span class="p">(</span><span class="n">DisplayId</span> <span class="n">primaryDisplayId</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ... 一个是 app，叫做 APP_VSYNC 吧</span>
    <span class="n">mAppConnectionHandle</span> <span class="o">=</span>
            <span class="n">mScheduler</span><span class="o">-&gt;</span><span class="n">createConnection</span><span class="p">(</span><span class="s">"app"</span><span class="p">,</span> <span class="n">mVsyncModulator</span><span class="p">.</span><span class="n">getOffsets</span><span class="p">().</span><span class="n">app</span><span class="p">,</span>
                                         <span class="n">mPhaseOffsets</span><span class="o">-&gt;</span><span class="n">getOffsetThresholdForNextVsync</span><span class="p">(),</span>
                                         <span class="n">impl</span><span class="o">::</span><span class="n">EventThread</span><span class="o">::</span><span class="n">InterceptVSyncsCallback</span><span class="p">());</span>
    <span class="c1">// ... 一个是 sf，叫做 SF_VSYNC 吧</span>
    <span class="n">mSfConnectionHandle</span> <span class="o">=</span>
            <span class="n">mScheduler</span><span class="o">-&gt;</span><span class="n">createConnection</span><span class="p">(</span><span class="s">"sf"</span><span class="p">,</span> <span class="n">mVsyncModulator</span><span class="p">.</span><span class="n">getOffsets</span><span class="p">().</span><span class="n">sf</span><span class="p">,</span>
                                         <span class="n">mPhaseOffsets</span><span class="o">-&gt;</span><span class="n">getOffsetThresholdForNextVsync</span><span class="p">(),</span>
                                         <span class="p">[</span><span class="k">this</span><span class="p">](</span><span class="n">nsecs_t</span> <span class="n">timestamp</span><span class="p">)</span> <span class="p">{</span>
                                             <span class="n">mInterceptor</span><span class="o">-&gt;</span><span class="n">saveVSyncEvent</span><span class="p">(</span><span class="n">timestamp</span><span class="p">);</span>
                                         <span class="p">});</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="app_vsync---发送给-app-的垂直同步信号">APP_VSYNC - 发送给 app 的垂直同步信号</h2><p>还记得文章开头那张 <code class="language-plaintext highlighter-rouge">View.invalidate()</code> 时序图吗？最后面它唤醒了 <code class="language-plaintext highlighter-rouge">EventThread</code>，现在我们来看看 <code class="language-plaintext highlighter-rouge">EventThread</code> 的主循环都做了些什么</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">EventThread</span><span class="o">::</span><span class="n">threadMain</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;&amp;</span> <span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DisplayEventConsumers</span> <span class="n">consumers</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">mState</span> <span class="o">!=</span> <span class="n">State</span><span class="o">::</span><span class="n">Quit</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">DisplayEventReceiver</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">event</span><span class="p">;</span>

        <span class="c1">// 在文章的开头，我们就猜测 mPendingEvents 里放的是同步信号</span>
        <span class="c1">// 现在我们知道了里面包含 SW_VSYNC，那是谁放进去的呢？</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mPendingEvents</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">event</span> <span class="o">=</span> <span class="n">mPendingEvents</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">mPendingEvents</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
						<span class="p">...</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="n">vsyncRequested</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="c1">// Find connections that should consume this event.</span>
        <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">mDisplayEventConnections</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">mDisplayEventConnections</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">promote</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">vsyncRequested</span> <span class="o">|=</span> <span class="n">connection</span><span class="o">-&gt;</span><span class="n">vsyncRequest</span> <span class="o">!=</span> <span class="n">VSyncRequest</span><span class="o">::</span><span class="n">None</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">&amp;&amp;</span> <span class="n">shouldConsumeEvent</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">connection</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">consumers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">connection</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="o">++</span><span class="n">it</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">it</span> <span class="o">=</span> <span class="n">mDisplayEventConnections</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 分发给消费者，怎么回调给 Choreographer？</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">consumers</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">dispatchEvent</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="n">consumers</span><span class="p">);</span>
            <span class="n">consumers</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">DispSyncThread</code> 把 SW_VSYNC 压入 <code class="language-plaintext highlighter-rouge">EventThread.mPendingEvents</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/blog/assets/2020-12-02-vsync/on_vsync.jpg" alt="on_vsync.jpg" /></p><p>分发 SW_VSYNC 的流程</p><ul><li><code class="language-plaintext highlighter-rouge">ViewRootImpl</code> 里拿到的是接收 APP_VSYNC 的 <code class="language-plaintext highlighter-rouge">Choreographer</code><li><code class="language-plaintext highlighter-rouge">Choreographer</code> 在构造函数里通过 <code class="language-plaintext highlighter-rouge">SurfaceFlinger</code> 与 <code class="language-plaintext highlighter-rouge">EventThread</code> 建立连接；这个连接其实是个 <code class="language-plaintext highlighter-rouge">Parcelable</code>，一块可以 io 的内存，<code class="language-plaintext highlighter-rouge">EventThread</code> 往里面写入 SW_VSYNC，<code class="language-plaintext highlighter-rouge">DisplayEventReceiver</code> 则通过 <code class="language-plaintext highlighter-rouge">Looper.addFd</code> 监听（这是 app main looper）<li>当收到 SW_VSYNC 时<code class="language-plaintext highlighter-rouge">FrameDisplayEventReceiver</code> 把 <code class="language-plaintext highlighter-rouge">Choreographer.doFrame</code> 放入 message queue，这样 input、animate 和 view 绘制即将执行</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/blog/assets/2020-12-02-vsync/consumer.jpg" alt="consumer.jpg" /></p><h2 id="sf_vsync">SF_VSYNC</h2><p>上面我们在分析是谁接收 SW_VSYNC 时，除了 APP_VSYNC 外，还有一路 SF_VSYNC</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">SurfaceFlinger</span><span class="o">::</span><span class="n">initScheduler</span><span class="p">(</span><span class="n">DisplayId</span> <span class="n">primaryDisplayId</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ... 一个是 sf，叫做 SF_VSYNC 吧</span>
    <span class="n">mSfConnectionHandle</span> <span class="o">=</span>
    <span class="n">mScheduler</span><span class="o">-&gt;</span><span class="n">createConnection</span><span class="p">(</span><span class="s">"sf"</span><span class="p">,</span> <span class="n">mVsyncModulator</span><span class="p">.</span><span class="n">getOffsets</span><span class="p">().</span><span class="n">sf</span><span class="p">,</span>
                                 <span class="n">mPhaseOffsets</span><span class="o">-&gt;</span><span class="n">getOffsetThresholdForNextVsync</span><span class="p">(),</span>
                                 <span class="p">[</span><span class="k">this</span><span class="p">](</span><span class="n">nsecs_t</span> <span class="n">timestamp</span><span class="p">)</span> <span class="p">{</span>
                                     <span class="n">mInterceptor</span><span class="o">-&gt;</span><span class="n">saveVSyncEvent</span><span class="p">(</span><span class="n">timestamp</span><span class="p">);</span>
                                 <span class="p">});</span>
    <span class="c1">// 看看 mEventQueue-&gt;setEventConnection 做了什么</span>
    <span class="n">mEventQueue</span><span class="o">-&gt;</span><span class="n">setEventConnection</span><span class="p">(</span><span class="n">mScheduler</span><span class="o">-&gt;</span><span class="n">getEventConnection</span><span class="p">(</span><span class="n">mSfConnectionHandle</span><span class="p">));</span>
    <span class="c1">// ...</span>
<span class="p">}</span> 

<span class="c1">// 上面有分析过，vsync event 是写入到一块内存里，通过 fd 可以监听到，而回调是 MessageQueue::cb_eventReceiver</span>
<span class="kt">void</span> <span class="n">MessageQueue</span><span class="o">::</span><span class="n">setEventConnection</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">EventThreadConnection</span><span class="o">&gt;&amp;</span> <span class="n">connection</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mEventTube</span><span class="p">.</span><span class="n">getFd</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mLooper</span><span class="o">-&gt;</span><span class="n">removeFd</span><span class="p">(</span><span class="n">mEventTube</span><span class="p">.</span><span class="n">getFd</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="n">mEvents</span> <span class="o">=</span> <span class="n">connection</span><span class="p">;</span>
    <span class="n">mEvents</span><span class="o">-&gt;</span><span class="n">stealReceiveChannel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mEventTube</span><span class="p">);</span>
    <span class="n">mLooper</span><span class="o">-&gt;</span><span class="n">addFd</span><span class="p">(</span><span class="n">mEventTube</span><span class="p">.</span><span class="n">getFd</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Looper</span><span class="o">::</span><span class="n">EVENT_INPUT</span><span class="p">,</span> <span class="n">MessageQueue</span><span class="o">::</span><span class="n">cb_eventReceiver</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 继续看 eventReceiver 方法</span>
<span class="kt">int</span> <span class="n">MessageQueue</span><span class="o">::</span><span class="n">cb_eventReceiver</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">events</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MessageQueue</span><span class="o">*</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">MessageQueue</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">eventReceiver</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">events</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 把 events 解包成 DisplayEventReceiver::Event，当有 vsync 时执行 dispatchInvalidate</span>
<span class="kt">int</span> <span class="n">MessageQueue</span><span class="o">::</span><span class="n">eventReceiver</span><span class="p">(</span><span class="kt">int</span> <span class="cm">/*fd*/</span><span class="p">,</span> <span class="kt">int</span> <span class="cm">/*events*/</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">ssize_t</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">DisplayEventReceiver</span><span class="o">::</span><span class="n">Event</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">DisplayEventReceiver</span><span class="o">::</span><span class="n">getEvents</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mEventTube</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">header</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">DisplayEventReceiver</span><span class="o">::</span><span class="n">DISPLAY_EVENT_VSYNC</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">mHandler</span><span class="o">-&gt;</span><span class="n">dispatchInvalidate</span><span class="p">();</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 看来得找出 Handler.handleMessage，看看里面怎么处理 MessageQueue::INVALIDATE</span>
<span class="kt">void</span> <span class="n">MessageQueue</span><span class="o">::</span><span class="n">Handler</span><span class="o">::</span><span class="n">dispatchInvalidate</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">android_atomic_or</span><span class="p">(</span><span class="n">eventMaskInvalidate</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mEventMask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">eventMaskInvalidate</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mQueue</span><span class="p">.</span><span class="n">mLooper</span><span class="o">-&gt;</span><span class="n">sendMessage</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">Message</span><span class="p">(</span><span class="n">MessageQueue</span><span class="o">::</span><span class="n">INVALIDATE</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 最终发现是走到了 SurfaceFlinger::onMessageReceived</span>
<span class="kt">void</span> <span class="n">MessageQueue</span><span class="o">::</span><span class="n">Handler</span><span class="o">::</span><span class="n">handleMessage</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">what</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">INVALIDATE</span><span class="p">:</span>
            <span class="n">android_atomic_and</span><span class="p">(</span><span class="o">~</span><span class="n">eventMaskInvalidate</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mEventMask</span><span class="p">);</span>
            <span class="n">mQueue</span><span class="p">.</span><span class="n">mFlinger</span><span class="o">-&gt;</span><span class="n">onMessageReceived</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">what</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">REFRESH</span><span class="p">:</span>
            <span class="n">android_atomic_and</span><span class="p">(</span><span class="o">~</span><span class="n">eventMaskRefresh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mEventMask</span><span class="p">);</span>
            <span class="n">mQueue</span><span class="p">.</span><span class="n">mFlinger</span><span class="o">-&gt;</span><span class="n">onMessageReceived</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">what</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 代码比较长，这就不贴出来了，总结下：</span>
<span class="c1">// SF_VSYNC 最终会调用 onMessageReceived(MessageQueue::INVALIDATE)，然后又会调用 onMessageReceived(MessageQueue::REFRESH)</span>
<span class="kt">void</span> <span class="n">SurfaceFlinger</span><span class="o">::</span><span class="n">onMessageReceived</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">what</span><span class="p">)</span> <span class="p">{}</span>
</pre></table></code></div></div><h2 id="结合-systrace">结合 systrace</h2><p>为什么会有 APP_VSYNC 和 SF_VSYNC 呢？这就不得不从屏幕上的内容讲起</p><p>实际上，我们在屏幕上看到的内容是由多个 layer 组合而成的：前台 app（多窗口模式下会有多个 app 显示）、桌面、壁纸、systemui 等，每个 app ui thread 负责绘制自己的内容，然后由 SurfaceFlinger 将它们合成在一起并显示在屏幕上</p><p>也就是说 APP_VSYNC 触发各个 app 的绘制，而最终屏幕内容的改变是由 SF_VSYNC 触发的；是不是这样呢？我们来看下 systrace</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/blog/assets/2020-12-02-vsync/45517.png" alt="45517.png" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/blog/assets/2020-12-02-vsync/45545.png" alt="45545.png" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/blog/assets/2020-12-02-vsync/45553.png" alt="45553.png" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/blog/assets/2020-12-02-vsync/45532.png" alt="45532.png" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/blog/assets/2020-12-02-vsync/45628.png" alt="45628.png" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/blog/assets/2020-12-02-vsync/45643.png" alt="45643.png" /></p><p>可以看到 ui thread doFrame 的确跟随着 APP_VSYNC（render thread 是执行 opengl 的线程，在 ui thread 计算完后获取结果并输出至 gpu），surfaceflinger onMessageReceived 也是跟随着 SF_VSYNC 的；但有没发现，它们俩似乎是同时执行的？surfaceflinger 不是应该等待 app 渲染完它那一层再合成吗？</p><p>我们重新回顾 initScheduler，有没发现这两路 vsync 都有一个 offset 参数？没错，就是这个参数控制着收到 vsync 后到执行工作的这一段延迟时间；实际上图 surfaceflinger 的延迟差不多是一个 vsync 的周期时间那么大，每个 surfaceflinger 合成的内容却是上一个周期里 app 渲染的内容；而且在合成工作完成后，当前周期的 app 渲染工作（render thread）才开始，避免了 layer 的内容被覆盖；这几个线程就这样有节奏地工作在一起。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/blog/categories/android/'>Android</a>, <a href='/blog/categories/framework/'>Framework</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/blog/tags/vsync/" class="post-tag no-text-decoration" >vsync</a> <a href="/blog/tags/invalidate/" class="post-tag no-text-decoration" >invalidate</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Android 图形栈（一）vsync - Cyrus&url=https://cyruslin.com/blog/blog/posts/vsync/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Android 图形栈（一）vsync - Cyrus&u=https://cyruslin.com/blog/blog/posts/vsync/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Android 图形栈（一）vsync - Cyrus&url=https://cyruslin.com/blog/blog/posts/vsync/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/posts/threadpool/">线程池 ThreadPool 的实现</a><li><a href="/blog/posts/juc-collection/">JUC 下一些线程安全的容器</a><li><a href="/blog/posts/reviews/">常见面试题备忘</a><li><a href="/blog/posts/https/">什么是 https ？</a><li><a href="/blog/posts/tcp-handshake-goodbye/">TCP 的三次握手和四次挥手</a></ul></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/posts/ui-thread-in-vsync/"><div class="card-body"> <span class="timeago small" > Dec 13, 2020 <i class="unloaded">2020-12-13T12:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Android 图形栈（二）ui thread</h3><div class="text-muted small"><p> 从一段 systrace 开始 这是一段 systrace 记录，看得出来页面是比较流畅的，ui thread 全都在一个 VSYNC_app 内完成绘制，surfaceflinger 也在一个 VSYNC_sf 内完成各个层的合成；但有没发现在 ui thread 完成 doFrame 后，总是会有一个 ReaderThread 跟在后面，看名字像是跟渲染相关的线程，它跟 ui 绘制...</p></div></div></a></div><div class="card"> <a href="/blog/posts/render-thread/"><div class="card-body"> <span class="timeago small" > Dec 27, 2020 <i class="unloaded">2020-12-27T12:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Android 图形栈（三）render thread</h3><div class="text-muted small"><p> 接着上一篇文章，在上篇文章里我们知道了 ui thread 在 view drawing 阶段产生了 DisplayList，而 render thread 会根据 DisplayList 执行真正的渲染工作，主要是 DrawFrameTask.syncFrameState 和 CanvasContext.draw 这两个方法 syncFrameState 重要的方法有三个：makeCu...</p></div></div></a></div><div class="card"> <a href="/blog/posts/how-application-being-created-and-init/"><div class="card-body"> <span class="timeago small" > Mar 2 <i class="unloaded">2021-03-02T12:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Application 是如何被创建和初始化的？</h3><div class="text-muted small"><p> 时序图 从 startActivity 开始，比如打开一个 app 的首页，当 app 未启动时就会走创建 Application 这条路 AMS 承担的工作 其中的转折点在 resumeTopActivityInnerLocked，发现 app process 不存在，走启动 app process 的流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/posts/scoped-storage/" class="btn btn-outline-primary" prompt="Older"><p>Scoped Storage（沙盒）</p></a> <a href="/blog/posts/ui-thread-in-vsync/" class="btn btn-outline-primary" prompt="Newer"><p>Android 图形栈（二）ui thread</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script></div></div>
